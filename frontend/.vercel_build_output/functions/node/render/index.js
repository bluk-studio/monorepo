var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name, value] of form) {
    yield getHeader(boundary, name, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = src(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, src, Readable, wm, Blob, fetchBlob, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    src = dataUriToBuffer;
    ({ Readable } = import_stream.default);
    wm = new WeakMap();
    Blob = class {
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element;
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length || buffer.size || 0;
          return buffer;
        });
        const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    fetchBlob = Blob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && object[NAME] === "AbortSignal";
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (err) => {
            const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
            this[INTERNALS$2].error = error3;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new fetchBlob([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw err;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const err = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
        throw err;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value));
          return [String(name).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value));
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(receiver, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback) {
        for (const name of this.keys()) {
          callback(this.get(name), name);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status || 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal !== null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
    Object.defineProperties(globalThis, {
      fetch: {
        enumerable: true,
        value: fetch
      },
      Response: {
        enumerable: true,
        value: Response
      },
      Request: {
        enumerable: true,
        value: Request
      },
      Headers: {
        enumerable: true,
        value: Headers
      }
    });
  }
});

// node_modules/@sveltejs/adapter-vercel/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-vercel/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/feather-icons/dist/feather.js
var require_feather = __commonJS({
  "node_modules/feather-icons/dist/feather.js"(exports, module2) {
    init_shims();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["feather"] = factory();
      else
        root["feather"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__2(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__2.m = modules;
        __webpack_require__2.c = installedModules;
        __webpack_require__2.d = function(exports2, name, getter) {
          if (!__webpack_require__2.o(exports2, name)) {
            Object.defineProperty(exports2, name, {
              configurable: false,
              enumerable: true,
              get: getter
            });
          }
        };
        __webpack_require__2.r = function(exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__2.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__2.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__2.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__2.p = "";
        return __webpack_require__2(__webpack_require__2.s = 0);
      }({
        "./dist/icons.json": function(module3) {
          module3.exports = { "activity": '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', "airplay": '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', "anchor": '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', "aperture": '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', "archive": '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', "award": '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', "battery": '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "bell": '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', "bluetooth": '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', "bold": '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', "book": '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', "bookmark": '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', "box": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "briefcase": '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', "calendar": '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', "camera": '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', "cast": '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', "check": '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', "chrome": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', "circle": '<circle cx="12" cy="12" r="10"></circle>', "clipboard": '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', "clock": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', "cloud": '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', "code": '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', "codepen": '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', "codesandbox": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "coffee": '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', "columns": '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', "command": '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', "compass": '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', "copy": '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', "cpu": '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', "crop": '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', "crosshair": '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', "database": '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', "delete": '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', "disc": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', "divide": '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', "download": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', "dribbble": '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', "droplet": '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', "edit": '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "eye": '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', "facebook": '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', "feather": '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', "figma": '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', "file": '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', "film": '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', "filter": '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', "flag": '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', "folder": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', "framer": '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', "frown": '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "gift": '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', "github": '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', "gitlab": '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', "globe": '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', "grid": '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', "hash": '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', "headphones": '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', "heart": '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', "hexagon": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', "home": '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', "image": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', "inbox": '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', "info": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', "instagram": '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', "italic": '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', "key": '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', "layers": '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', "layout": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', "link": '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', "linkedin": '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', "list": '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', "loader": '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', "lock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', "mail": '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', "map": '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "maximize": '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', "meh": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "menu": '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "mic": '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "minimize": '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', "minus": '<line x1="5" y1="12" x2="19" y2="12"></line>', "monitor": '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', "moon": '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', "move": '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', "music": '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', "navigation": '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', "octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', "package": '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "paperclip": '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', "pause": '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', "percent": '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone": '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', "play": '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus": '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', "pocket": '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', "power": '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', "printer": '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', "radio": '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', "repeat": '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', "rewind": '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', "rss": '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', "save": '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', "scissors": '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', "search": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', "send": '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', "server": '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', "settings": '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', "share": '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "shield": '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', "shuffle": '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', "sidebar": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', "slack": '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', "slash": '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', "sliders": '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', "smartphone": '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "smile": '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "speaker": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', "square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', "star": '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', "sun": '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', "sunrise": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', "sunset": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', "tablet": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "tag": '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', "target": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', "terminal": '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', "thermometer": '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', "tool": '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', "trash": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', "trello": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', "triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', "truck": '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', "tv": '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', "twitch": '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>', "twitter": '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', "type": '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', "umbrella": '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', "underline": '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', "unlock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', "upload": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', "user": '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', "users": '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "video": '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', "voicemail": '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', "volume": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', "watch": '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wifi": '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wind": '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', "x": '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', "youtube": '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', "zap": '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' };
        },
        "./node_modules/classnames/dedupe.js": function(module3, exports2, __webpack_require__2) {
          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function() {
            "use strict";
            var classNames = function() {
              function StorageObject() {
              }
              StorageObject.prototype = Object.create(null);
              function _parseArray(resultSet, array) {
                var length = array.length;
                for (var i = 0; i < length; ++i) {
                  _parse(resultSet, array[i]);
                }
              }
              var hasOwn = {}.hasOwnProperty;
              function _parseNumber(resultSet, num) {
                resultSet[num] = true;
              }
              function _parseObject(resultSet, object) {
                for (var k in object) {
                  if (hasOwn.call(object, k)) {
                    resultSet[k] = !!object[k];
                  }
                }
              }
              var SPACE = /\s+/;
              function _parseString(resultSet, str) {
                var array = str.split(SPACE);
                var length = array.length;
                for (var i = 0; i < length; ++i) {
                  resultSet[array[i]] = true;
                }
              }
              function _parse(resultSet, arg) {
                if (!arg)
                  return;
                var argType = typeof arg;
                if (argType === "string") {
                  _parseString(resultSet, arg);
                } else if (Array.isArray(arg)) {
                  _parseArray(resultSet, arg);
                } else if (argType === "object") {
                  _parseObject(resultSet, arg);
                } else if (argType === "number") {
                  _parseNumber(resultSet, arg);
                }
              }
              function _classNames() {
                var len = arguments.length;
                var args = Array(len);
                for (var i = 0; i < len; i++) {
                  args[i] = arguments[i];
                }
                var classSet = new StorageObject();
                _parseArray(classSet, args);
                var list = [];
                for (var k in classSet) {
                  if (classSet[k]) {
                    list.push(k);
                  }
                }
                return list.join(" ");
              }
              return _classNames;
            }();
            if (typeof module3 !== "undefined" && module3.exports) {
              module3.exports = classNames;
            } else if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return classNames;
              }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
            }
          })();
        },
        "./node_modules/core-js/es/array/from.js": function(module3, exports2, __webpack_require__2) {
          __webpack_require__2("./node_modules/core-js/modules/es.string.iterator.js");
          __webpack_require__2("./node_modules/core-js/modules/es.array.from.js");
          var path = __webpack_require__2("./node_modules/core-js/internals/path.js");
          module3.exports = path.Array.from;
        },
        "./node_modules/core-js/internals/a-function.js": function(module3, exports2) {
          module3.exports = function(it) {
            if (typeof it != "function") {
              throw TypeError(String(it) + " is not a function");
            }
            return it;
          };
        },
        "./node_modules/core-js/internals/an-object.js": function(module3, exports2, __webpack_require__2) {
          var isObject = __webpack_require__2("./node_modules/core-js/internals/is-object.js");
          module3.exports = function(it) {
            if (!isObject(it)) {
              throw TypeError(String(it) + " is not an object");
            }
            return it;
          };
        },
        "./node_modules/core-js/internals/array-from.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var bind = __webpack_require__2("./node_modules/core-js/internals/bind-context.js");
          var toObject = __webpack_require__2("./node_modules/core-js/internals/to-object.js");
          var callWithSafeIterationClosing = __webpack_require__2("./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
          var isArrayIteratorMethod = __webpack_require__2("./node_modules/core-js/internals/is-array-iterator-method.js");
          var toLength = __webpack_require__2("./node_modules/core-js/internals/to-length.js");
          var createProperty = __webpack_require__2("./node_modules/core-js/internals/create-property.js");
          var getIteratorMethod = __webpack_require__2("./node_modules/core-js/internals/get-iterator-method.js");
          module3.exports = function from(arrayLike) {
            var O = toObject(arrayLike);
            var C = typeof this == "function" ? this : Array;
            var argumentsLength = arguments.length;
            var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
            var mapping = mapfn !== void 0;
            var index2 = 0;
            var iteratorMethod = getIteratorMethod(O);
            var length, result, step, iterator;
            if (mapping)
              mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
            if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
              iterator = iteratorMethod.call(O);
              result = new C();
              for (; !(step = iterator.next()).done; index2++) {
                createProperty(result, index2, mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value);
              }
            } else {
              length = toLength(O.length);
              result = new C(length);
              for (; length > index2; index2++) {
                createProperty(result, index2, mapping ? mapfn(O[index2], index2) : O[index2]);
              }
            }
            result.length = index2;
            return result;
          };
        },
        "./node_modules/core-js/internals/array-includes.js": function(module3, exports2, __webpack_require__2) {
          var toIndexedObject = __webpack_require__2("./node_modules/core-js/internals/to-indexed-object.js");
          var toLength = __webpack_require__2("./node_modules/core-js/internals/to-length.js");
          var toAbsoluteIndex = __webpack_require__2("./node_modules/core-js/internals/to-absolute-index.js");
          module3.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIndexedObject($this);
              var length = toLength(O.length);
              var index2 = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el)
                while (length > index2) {
                  value = O[index2++];
                  if (value != value)
                    return true;
                }
              else
                for (; length > index2; index2++)
                  if (IS_INCLUDES || index2 in O) {
                    if (O[index2] === el)
                      return IS_INCLUDES || index2 || 0;
                  }
              return !IS_INCLUDES && -1;
            };
          };
        },
        "./node_modules/core-js/internals/bind-context.js": function(module3, exports2, __webpack_require__2) {
          var aFunction = __webpack_require__2("./node_modules/core-js/internals/a-function.js");
          module3.exports = function(fn, that, length) {
            aFunction(fn);
            if (that === void 0)
              return fn;
            switch (length) {
              case 0:
                return function() {
                  return fn.call(that);
                };
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        },
        "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": function(module3, exports2, __webpack_require__2) {
          var anObject = __webpack_require__2("./node_modules/core-js/internals/an-object.js");
          module3.exports = function(iterator, fn, value, ENTRIES) {
            try {
              return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            } catch (error3) {
              var returnMethod = iterator["return"];
              if (returnMethod !== void 0)
                anObject(returnMethod.call(iterator));
              throw error3;
            }
          };
        },
        "./node_modules/core-js/internals/check-correctness-of-iteration.js": function(module3, exports2, __webpack_require__2) {
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var SAFE_CLOSING = false;
          try {
            var called = 0;
            var iteratorWithReturn = {
              next: function() {
                return { done: !!called++ };
              },
              "return": function() {
                SAFE_CLOSING = true;
              }
            };
            iteratorWithReturn[ITERATOR] = function() {
              return this;
            };
            Array.from(iteratorWithReturn, function() {
              throw 2;
            });
          } catch (error3) {
          }
          module3.exports = function(exec, SKIP_CLOSING) {
            if (!SKIP_CLOSING && !SAFE_CLOSING)
              return false;
            var ITERATION_SUPPORT = false;
            try {
              var object = {};
              object[ITERATOR] = function() {
                return {
                  next: function() {
                    return { done: ITERATION_SUPPORT = true };
                  }
                };
              };
              exec(object);
            } catch (error3) {
            }
            return ITERATION_SUPPORT;
          };
        },
        "./node_modules/core-js/internals/classof-raw.js": function(module3, exports2) {
          var toString = {}.toString;
          module3.exports = function(it) {
            return toString.call(it).slice(8, -1);
          };
        },
        "./node_modules/core-js/internals/classof.js": function(module3, exports2, __webpack_require__2) {
          var classofRaw = __webpack_require__2("./node_modules/core-js/internals/classof-raw.js");
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var CORRECT_ARGUMENTS = classofRaw(function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (error3) {
            }
          };
          module3.exports = function(it) {
            var O, tag, result;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
          };
        },
        "./node_modules/core-js/internals/copy-constructor-properties.js": function(module3, exports2, __webpack_require__2) {
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var ownKeys = __webpack_require__2("./node_modules/core-js/internals/own-keys.js");
          var getOwnPropertyDescriptorModule = __webpack_require__2("./node_modules/core-js/internals/object-get-own-property-descriptor.js");
          var definePropertyModule = __webpack_require__2("./node_modules/core-js/internals/object-define-property.js");
          module3.exports = function(target, source) {
            var keys = ownKeys(source);
            var defineProperty = definePropertyModule.f;
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!has(target, key))
                defineProperty(target, key, getOwnPropertyDescriptor(source, key));
            }
          };
        },
        "./node_modules/core-js/internals/correct-prototype-getter.js": function(module3, exports2, __webpack_require__2) {
          var fails = __webpack_require__2("./node_modules/core-js/internals/fails.js");
          module3.exports = !fails(function() {
            function F() {
            }
            F.prototype.constructor = null;
            return Object.getPrototypeOf(new F()) !== F.prototype;
          });
        },
        "./node_modules/core-js/internals/create-iterator-constructor.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var IteratorPrototype = __webpack_require__2("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
          var create = __webpack_require__2("./node_modules/core-js/internals/object-create.js");
          var createPropertyDescriptor = __webpack_require__2("./node_modules/core-js/internals/create-property-descriptor.js");
          var setToStringTag = __webpack_require__2("./node_modules/core-js/internals/set-to-string-tag.js");
          var Iterators = __webpack_require__2("./node_modules/core-js/internals/iterators.js");
          var returnThis = function() {
            return this;
          };
          module3.exports = function(IteratorConstructor, NAME2, next) {
            var TO_STRING_TAG = NAME2 + " Iterator";
            IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
            setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
            Iterators[TO_STRING_TAG] = returnThis;
            return IteratorConstructor;
          };
        },
        "./node_modules/core-js/internals/create-property-descriptor.js": function(module3, exports2) {
          module3.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        },
        "./node_modules/core-js/internals/create-property.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var toPrimitive = __webpack_require__2("./node_modules/core-js/internals/to-primitive.js");
          var definePropertyModule = __webpack_require__2("./node_modules/core-js/internals/object-define-property.js");
          var createPropertyDescriptor = __webpack_require__2("./node_modules/core-js/internals/create-property-descriptor.js");
          module3.exports = function(object, key, value) {
            var propertyKey = toPrimitive(key);
            if (propertyKey in object)
              definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
            else
              object[propertyKey] = value;
          };
        },
        "./node_modules/core-js/internals/define-iterator.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var $ = __webpack_require__2("./node_modules/core-js/internals/export.js");
          var createIteratorConstructor = __webpack_require__2("./node_modules/core-js/internals/create-iterator-constructor.js");
          var getPrototypeOf = __webpack_require__2("./node_modules/core-js/internals/object-get-prototype-of.js");
          var setPrototypeOf = __webpack_require__2("./node_modules/core-js/internals/object-set-prototype-of.js");
          var setToStringTag = __webpack_require__2("./node_modules/core-js/internals/set-to-string-tag.js");
          var hide = __webpack_require__2("./node_modules/core-js/internals/hide.js");
          var redefine = __webpack_require__2("./node_modules/core-js/internals/redefine.js");
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var IS_PURE = __webpack_require__2("./node_modules/core-js/internals/is-pure.js");
          var Iterators = __webpack_require__2("./node_modules/core-js/internals/iterators.js");
          var IteratorsCore = __webpack_require__2("./node_modules/core-js/internals/iterators-core.js");
          var IteratorPrototype = IteratorsCore.IteratorPrototype;
          var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
          var ITERATOR = wellKnownSymbol("iterator");
          var KEYS = "keys";
          var VALUES = "values";
          var ENTRIES = "entries";
          var returnThis = function() {
            return this;
          };
          module3.exports = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
            createIteratorConstructor(IteratorConstructor, NAME2, next);
            var getIterationMethod = function(KIND) {
              if (KIND === DEFAULT && defaultIterator)
                return defaultIterator;
              if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                return IterablePrototype[KIND];
              switch (KIND) {
                case KEYS:
                  return function keys() {
                    return new IteratorConstructor(this, KIND);
                  };
                case VALUES:
                  return function values() {
                    return new IteratorConstructor(this, KIND);
                  };
                case ENTRIES:
                  return function entries() {
                    return new IteratorConstructor(this, KIND);
                  };
              }
              return function() {
                return new IteratorConstructor(this);
              };
            };
            var TO_STRING_TAG = NAME2 + " Iterator";
            var INCORRECT_VALUES_NAME = false;
            var IterablePrototype = Iterable.prototype;
            var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
            var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
            var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
            var CurrentIteratorPrototype, methods, KEY;
            if (anyNativeIterator) {
              CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
              if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                  if (setPrototypeOf) {
                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                  } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                    hide(CurrentIteratorPrototype, ITERATOR, returnThis);
                  }
                }
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                if (IS_PURE)
                  Iterators[TO_STRING_TAG] = returnThis;
              }
            }
            if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
              INCORRECT_VALUES_NAME = true;
              defaultIterator = function values() {
                return nativeIterator.call(this);
              };
            }
            if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
              hide(IterablePrototype, ITERATOR, defaultIterator);
            }
            Iterators[NAME2] = defaultIterator;
            if (DEFAULT) {
              methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
              };
              if (FORCED)
                for (KEY in methods) {
                  if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine(IterablePrototype, KEY, methods[KEY]);
                  }
                }
              else
                $({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
            }
            return methods;
          };
        },
        "./node_modules/core-js/internals/descriptors.js": function(module3, exports2, __webpack_require__2) {
          var fails = __webpack_require__2("./node_modules/core-js/internals/fails.js");
          module3.exports = !fails(function() {
            return Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        },
        "./node_modules/core-js/internals/document-create-element.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var isObject = __webpack_require__2("./node_modules/core-js/internals/is-object.js");
          var document2 = global2.document;
          var exist = isObject(document2) && isObject(document2.createElement);
          module3.exports = function(it) {
            return exist ? document2.createElement(it) : {};
          };
        },
        "./node_modules/core-js/internals/enum-bug-keys.js": function(module3, exports2) {
          module3.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        },
        "./node_modules/core-js/internals/export.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var getOwnPropertyDescriptor = __webpack_require__2("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
          var hide = __webpack_require__2("./node_modules/core-js/internals/hide.js");
          var redefine = __webpack_require__2("./node_modules/core-js/internals/redefine.js");
          var setGlobal = __webpack_require__2("./node_modules/core-js/internals/set-global.js");
          var copyConstructorProperties = __webpack_require__2("./node_modules/core-js/internals/copy-constructor-properties.js");
          var isForced = __webpack_require__2("./node_modules/core-js/internals/is-forced.js");
          module3.exports = function(options2, source) {
            var TARGET = options2.target;
            var GLOBAL = options2.global;
            var STATIC = options2.stat;
            var FORCED, target, key, targetProperty, sourceProperty, descriptor;
            if (GLOBAL) {
              target = global2;
            } else if (STATIC) {
              target = global2[TARGET] || setGlobal(TARGET, {});
            } else {
              target = (global2[TARGET] || {}).prototype;
            }
            if (target)
              for (key in source) {
                sourceProperty = source[key];
                if (options2.noTargetGet) {
                  descriptor = getOwnPropertyDescriptor(target, key);
                  targetProperty = descriptor && descriptor.value;
                } else
                  targetProperty = target[key];
                FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
                if (!FORCED && targetProperty !== void 0) {
                  if (typeof sourceProperty === typeof targetProperty)
                    continue;
                  copyConstructorProperties(sourceProperty, targetProperty);
                }
                if (options2.sham || targetProperty && targetProperty.sham) {
                  hide(sourceProperty, "sham", true);
                }
                redefine(target, key, sourceProperty, options2);
              }
          };
        },
        "./node_modules/core-js/internals/fails.js": function(module3, exports2) {
          module3.exports = function(exec) {
            try {
              return !!exec();
            } catch (error3) {
              return true;
            }
          };
        },
        "./node_modules/core-js/internals/function-to-string.js": function(module3, exports2, __webpack_require__2) {
          var shared = __webpack_require__2("./node_modules/core-js/internals/shared.js");
          module3.exports = shared("native-function-to-string", Function.toString);
        },
        "./node_modules/core-js/internals/get-iterator-method.js": function(module3, exports2, __webpack_require__2) {
          var classof = __webpack_require__2("./node_modules/core-js/internals/classof.js");
          var Iterators = __webpack_require__2("./node_modules/core-js/internals/iterators.js");
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var ITERATOR = wellKnownSymbol("iterator");
          module3.exports = function(it) {
            if (it != void 0)
              return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
          };
        },
        "./node_modules/core-js/internals/global.js": function(module3, exports2, __webpack_require__2) {
          (function(global2) {
            var O = "object";
            var check = function(it) {
              return it && it.Math == Math && it;
            };
            module3.exports = check(typeof globalThis == O && globalThis) || check(typeof window == O && window) || check(typeof self == O && self) || check(typeof global2 == O && global2) || Function("return this")();
          }).call(this, __webpack_require__2("./node_modules/webpack/buildin/global.js"));
        },
        "./node_modules/core-js/internals/has.js": function(module3, exports2) {
          var hasOwnProperty = {}.hasOwnProperty;
          module3.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
          };
        },
        "./node_modules/core-js/internals/hidden-keys.js": function(module3, exports2) {
          module3.exports = {};
        },
        "./node_modules/core-js/internals/hide.js": function(module3, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2("./node_modules/core-js/internals/descriptors.js");
          var definePropertyModule = __webpack_require__2("./node_modules/core-js/internals/object-define-property.js");
          var createPropertyDescriptor = __webpack_require__2("./node_modules/core-js/internals/create-property-descriptor.js");
          module3.exports = DESCRIPTORS ? function(object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        },
        "./node_modules/core-js/internals/html.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var document2 = global2.document;
          module3.exports = document2 && document2.documentElement;
        },
        "./node_modules/core-js/internals/ie8-dom-define.js": function(module3, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2("./node_modules/core-js/internals/descriptors.js");
          var fails = __webpack_require__2("./node_modules/core-js/internals/fails.js");
          var createElement = __webpack_require__2("./node_modules/core-js/internals/document-create-element.js");
          module3.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        },
        "./node_modules/core-js/internals/indexed-object.js": function(module3, exports2, __webpack_require__2) {
          var fails = __webpack_require__2("./node_modules/core-js/internals/fails.js");
          var classof = __webpack_require__2("./node_modules/core-js/internals/classof-raw.js");
          var split2 = "".split;
          module3.exports = fails(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) == "String" ? split2.call(it, "") : Object(it);
          } : Object;
        },
        "./node_modules/core-js/internals/internal-state.js": function(module3, exports2, __webpack_require__2) {
          var NATIVE_WEAK_MAP = __webpack_require__2("./node_modules/core-js/internals/native-weak-map.js");
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var isObject = __webpack_require__2("./node_modules/core-js/internals/is-object.js");
          var hide = __webpack_require__2("./node_modules/core-js/internals/hide.js");
          var objectHas = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var sharedKey = __webpack_require__2("./node_modules/core-js/internals/shared-key.js");
          var hiddenKeys = __webpack_require__2("./node_modules/core-js/internals/hidden-keys.js");
          var WeakMap2 = global2.WeakMap;
          var set, get, has;
          var enforce = function(it) {
            return has(it) ? get(it) : set(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject(it) || (state = get(it)).type !== TYPE) {
                throw TypeError("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP) {
            var store = new WeakMap2();
            var wmget = store.get;
            var wmhas = store.has;
            var wmset = store.set;
            set = function(it, metadata) {
              wmset.call(store, it, metadata);
              return metadata;
            };
            get = function(it) {
              return wmget.call(store, it) || {};
            };
            has = function(it) {
              return wmhas.call(store, it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set = function(it, metadata) {
              hide(it, STATE, metadata);
              return metadata;
            };
            get = function(it) {
              return objectHas(it, STATE) ? it[STATE] : {};
            };
            has = function(it) {
              return objectHas(it, STATE);
            };
          }
          module3.exports = {
            set,
            get,
            has,
            enforce,
            getterFor
          };
        },
        "./node_modules/core-js/internals/is-array-iterator-method.js": function(module3, exports2, __webpack_require__2) {
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var Iterators = __webpack_require__2("./node_modules/core-js/internals/iterators.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var ArrayPrototype = Array.prototype;
          module3.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
          };
        },
        "./node_modules/core-js/internals/is-forced.js": function(module3, exports2, __webpack_require__2) {
          var fails = __webpack_require__2("./node_modules/core-js/internals/fails.js");
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize3(feature)];
            return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
          };
          var normalize3 = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module3.exports = isForced;
        },
        "./node_modules/core-js/internals/is-object.js": function(module3, exports2) {
          module3.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        },
        "./node_modules/core-js/internals/is-pure.js": function(module3, exports2) {
          module3.exports = false;
        },
        "./node_modules/core-js/internals/iterators-core.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var getPrototypeOf = __webpack_require__2("./node_modules/core-js/internals/object-get-prototype-of.js");
          var hide = __webpack_require__2("./node_modules/core-js/internals/hide.js");
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var IS_PURE = __webpack_require__2("./node_modules/core-js/internals/is-pure.js");
          var ITERATOR = wellKnownSymbol("iterator");
          var BUGGY_SAFARI_ITERATORS = false;
          var returnThis = function() {
            return this;
          };
          var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
          if ([].keys) {
            arrayIterator = [].keys();
            if (!("next" in arrayIterator))
              BUGGY_SAFARI_ITERATORS = true;
            else {
              PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
              if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                IteratorPrototype = PrototypeOfArrayIteratorPrototype;
            }
          }
          if (IteratorPrototype == void 0)
            IteratorPrototype = {};
          if (!IS_PURE && !has(IteratorPrototype, ITERATOR))
            hide(IteratorPrototype, ITERATOR, returnThis);
          module3.exports = {
            IteratorPrototype,
            BUGGY_SAFARI_ITERATORS
          };
        },
        "./node_modules/core-js/internals/iterators.js": function(module3, exports2) {
          module3.exports = {};
        },
        "./node_modules/core-js/internals/native-symbol.js": function(module3, exports2, __webpack_require__2) {
          var fails = __webpack_require__2("./node_modules/core-js/internals/fails.js");
          module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            return !String(Symbol());
          });
        },
        "./node_modules/core-js/internals/native-weak-map.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var nativeFunctionToString = __webpack_require__2("./node_modules/core-js/internals/function-to-string.js");
          var WeakMap2 = global2.WeakMap;
          module3.exports = typeof WeakMap2 === "function" && /native code/.test(nativeFunctionToString.call(WeakMap2));
        },
        "./node_modules/core-js/internals/object-create.js": function(module3, exports2, __webpack_require__2) {
          var anObject = __webpack_require__2("./node_modules/core-js/internals/an-object.js");
          var defineProperties = __webpack_require__2("./node_modules/core-js/internals/object-define-properties.js");
          var enumBugKeys = __webpack_require__2("./node_modules/core-js/internals/enum-bug-keys.js");
          var hiddenKeys = __webpack_require__2("./node_modules/core-js/internals/hidden-keys.js");
          var html = __webpack_require__2("./node_modules/core-js/internals/html.js");
          var documentCreateElement = __webpack_require__2("./node_modules/core-js/internals/document-create-element.js");
          var sharedKey = __webpack_require__2("./node_modules/core-js/internals/shared-key.js");
          var IE_PROTO = sharedKey("IE_PROTO");
          var PROTOTYPE = "prototype";
          var Empty = function() {
          };
          var createDict = function() {
            var iframe = documentCreateElement("iframe");
            var length = enumBugKeys.length;
            var lt = "<";
            var script = "script";
            var gt = ">";
            var js = "java" + script + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(js);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + script + gt + "document.F=Object" + lt + "/" + script + gt);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (length--)
              delete createDict[PROTOTYPE][enumBugKeys[length]];
            return createDict();
          };
          module3.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
              Empty[PROTOTYPE] = anObject(O);
              result = new Empty();
              Empty[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else
              result = createDict();
            return Properties === void 0 ? result : defineProperties(result, Properties);
          };
          hiddenKeys[IE_PROTO] = true;
        },
        "./node_modules/core-js/internals/object-define-properties.js": function(module3, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2("./node_modules/core-js/internals/descriptors.js");
          var definePropertyModule = __webpack_require__2("./node_modules/core-js/internals/object-define-property.js");
          var anObject = __webpack_require__2("./node_modules/core-js/internals/an-object.js");
          var objectKeys = __webpack_require__2("./node_modules/core-js/internals/object-keys.js");
          module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys = objectKeys(Properties);
            var length = keys.length;
            var i = 0;
            var key;
            while (length > i)
              definePropertyModule.f(O, key = keys[i++], Properties[key]);
            return O;
          };
        },
        "./node_modules/core-js/internals/object-define-property.js": function(module3, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2("./node_modules/core-js/internals/descriptors.js");
          var IE8_DOM_DEFINE = __webpack_require__2("./node_modules/core-js/internals/ie8-dom-define.js");
          var anObject = __webpack_require__2("./node_modules/core-js/internals/an-object.js");
          var toPrimitive = __webpack_require__2("./node_modules/core-js/internals/to-primitive.js");
          var nativeDefineProperty = Object.defineProperty;
          exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return nativeDefineProperty(O, P, Attributes);
              } catch (error3) {
              }
            if ("get" in Attributes || "set" in Attributes)
              throw TypeError("Accessors not supported");
            if ("value" in Attributes)
              O[P] = Attributes.value;
            return O;
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-descriptor.js": function(module3, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2("./node_modules/core-js/internals/descriptors.js");
          var propertyIsEnumerableModule = __webpack_require__2("./node_modules/core-js/internals/object-property-is-enumerable.js");
          var createPropertyDescriptor = __webpack_require__2("./node_modules/core-js/internals/create-property-descriptor.js");
          var toIndexedObject = __webpack_require__2("./node_modules/core-js/internals/to-indexed-object.js");
          var toPrimitive = __webpack_require__2("./node_modules/core-js/internals/to-primitive.js");
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var IE8_DOM_DEFINE = __webpack_require__2("./node_modules/core-js/internals/ie8-dom-define.js");
          var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPrimitive(P, true);
            if (IE8_DOM_DEFINE)
              try {
                return nativeGetOwnPropertyDescriptor(O, P);
              } catch (error3) {
              }
            if (has(O, P))
              return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-names.js": function(module3, exports2, __webpack_require__2) {
          var internalObjectKeys = __webpack_require__2("./node_modules/core-js/internals/object-keys-internal.js");
          var enumBugKeys = __webpack_require__2("./node_modules/core-js/internals/enum-bug-keys.js");
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
        },
        "./node_modules/core-js/internals/object-get-own-property-symbols.js": function(module3, exports2) {
          exports2.f = Object.getOwnPropertySymbols;
        },
        "./node_modules/core-js/internals/object-get-prototype-of.js": function(module3, exports2, __webpack_require__2) {
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var toObject = __webpack_require__2("./node_modules/core-js/internals/to-object.js");
          var sharedKey = __webpack_require__2("./node_modules/core-js/internals/shared-key.js");
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__2("./node_modules/core-js/internals/correct-prototype-getter.js");
          var IE_PROTO = sharedKey("IE_PROTO");
          var ObjectPrototype = Object.prototype;
          module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
            O = toObject(O);
            if (has(O, IE_PROTO))
              return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
              return O.constructor.prototype;
            }
            return O instanceof Object ? ObjectPrototype : null;
          };
        },
        "./node_modules/core-js/internals/object-keys-internal.js": function(module3, exports2, __webpack_require__2) {
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var toIndexedObject = __webpack_require__2("./node_modules/core-js/internals/to-indexed-object.js");
          var arrayIncludes = __webpack_require__2("./node_modules/core-js/internals/array-includes.js");
          var hiddenKeys = __webpack_require__2("./node_modules/core-js/internals/hidden-keys.js");
          var arrayIndexOf = arrayIncludes(false);
          module3.exports = function(object, names) {
            var O = toIndexedObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O)
              !has(hiddenKeys, key) && has(O, key) && result.push(key);
            while (names.length > i)
              if (has(O, key = names[i++])) {
                ~arrayIndexOf(result, key) || result.push(key);
              }
            return result;
          };
        },
        "./node_modules/core-js/internals/object-keys.js": function(module3, exports2, __webpack_require__2) {
          var internalObjectKeys = __webpack_require__2("./node_modules/core-js/internals/object-keys-internal.js");
          var enumBugKeys = __webpack_require__2("./node_modules/core-js/internals/enum-bug-keys.js");
          module3.exports = Object.keys || function keys(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
        },
        "./node_modules/core-js/internals/object-property-is-enumerable.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          } : nativePropertyIsEnumerable;
        },
        "./node_modules/core-js/internals/object-set-prototype-of.js": function(module3, exports2, __webpack_require__2) {
          var validateSetPrototypeOfArguments = __webpack_require__2("./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");
          module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var correctSetter = false;
            var test = {};
            var setter;
            try {
              setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
              setter.call(test, []);
              correctSetter = test instanceof Array;
            } catch (error3) {
            }
            return function setPrototypeOf(O, proto) {
              validateSetPrototypeOfArguments(O, proto);
              if (correctSetter)
                setter.call(O, proto);
              else
                O.__proto__ = proto;
              return O;
            };
          }() : void 0);
        },
        "./node_modules/core-js/internals/own-keys.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var getOwnPropertyNamesModule = __webpack_require__2("./node_modules/core-js/internals/object-get-own-property-names.js");
          var getOwnPropertySymbolsModule = __webpack_require__2("./node_modules/core-js/internals/object-get-own-property-symbols.js");
          var anObject = __webpack_require__2("./node_modules/core-js/internals/an-object.js");
          var Reflect2 = global2.Reflect;
          module3.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it) {
            var keys = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
          };
        },
        "./node_modules/core-js/internals/path.js": function(module3, exports2, __webpack_require__2) {
          module3.exports = __webpack_require__2("./node_modules/core-js/internals/global.js");
        },
        "./node_modules/core-js/internals/redefine.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var shared = __webpack_require__2("./node_modules/core-js/internals/shared.js");
          var hide = __webpack_require__2("./node_modules/core-js/internals/hide.js");
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var setGlobal = __webpack_require__2("./node_modules/core-js/internals/set-global.js");
          var nativeFunctionToString = __webpack_require__2("./node_modules/core-js/internals/function-to-string.js");
          var InternalStateModule = __webpack_require__2("./node_modules/core-js/internals/internal-state.js");
          var getInternalState = InternalStateModule.get;
          var enforceInternalState = InternalStateModule.enforce;
          var TEMPLATE = String(nativeFunctionToString).split("toString");
          shared("inspectSource", function(it) {
            return nativeFunctionToString.call(it);
          });
          (module3.exports = function(O, key, value, options2) {
            var unsafe = options2 ? !!options2.unsafe : false;
            var simple = options2 ? !!options2.enumerable : false;
            var noTargetGet = options2 ? !!options2.noTargetGet : false;
            if (typeof value == "function") {
              if (typeof key == "string" && !has(value, "name"))
                hide(value, "name", key);
              enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
            }
            if (O === global2) {
              if (simple)
                O[key] = value;
              else
                setGlobal(key, value);
              return;
            } else if (!unsafe) {
              delete O[key];
            } else if (!noTargetGet && O[key]) {
              simple = true;
            }
            if (simple)
              O[key] = value;
            else
              hide(O, key, value);
          })(Function.prototype, "toString", function toString() {
            return typeof this == "function" && getInternalState(this).source || nativeFunctionToString.call(this);
          });
        },
        "./node_modules/core-js/internals/require-object-coercible.js": function(module3, exports2) {
          module3.exports = function(it) {
            if (it == void 0)
              throw TypeError("Can't call method on " + it);
            return it;
          };
        },
        "./node_modules/core-js/internals/set-global.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var hide = __webpack_require__2("./node_modules/core-js/internals/hide.js");
          module3.exports = function(key, value) {
            try {
              hide(global2, key, value);
            } catch (error3) {
              global2[key] = value;
            }
            return value;
          };
        },
        "./node_modules/core-js/internals/set-to-string-tag.js": function(module3, exports2, __webpack_require__2) {
          var defineProperty = __webpack_require__2("./node_modules/core-js/internals/object-define-property.js").f;
          var has = __webpack_require__2("./node_modules/core-js/internals/has.js");
          var wellKnownSymbol = __webpack_require__2("./node_modules/core-js/internals/well-known-symbol.js");
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          module3.exports = function(it, TAG, STATIC) {
            if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
              defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
            }
          };
        },
        "./node_modules/core-js/internals/shared-key.js": function(module3, exports2, __webpack_require__2) {
          var shared = __webpack_require__2("./node_modules/core-js/internals/shared.js");
          var uid = __webpack_require__2("./node_modules/core-js/internals/uid.js");
          var keys = shared("keys");
          module3.exports = function(key) {
            return keys[key] || (keys[key] = uid(key));
          };
        },
        "./node_modules/core-js/internals/shared.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var setGlobal = __webpack_require__2("./node_modules/core-js/internals/set-global.js");
          var IS_PURE = __webpack_require__2("./node_modules/core-js/internals/is-pure.js");
          var SHARED = "__core-js_shared__";
          var store = global2[SHARED] || setGlobal(SHARED, {});
          (module3.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: "3.1.3",
            mode: IS_PURE ? "pure" : "global",
            copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
          });
        },
        "./node_modules/core-js/internals/string-at.js": function(module3, exports2, __webpack_require__2) {
          var toInteger = __webpack_require__2("./node_modules/core-js/internals/to-integer.js");
          var requireObjectCoercible = __webpack_require__2("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(that, pos, CONVERT_TO_STRING) {
            var S = String(requireObjectCoercible(that));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size)
              return CONVERT_TO_STRING ? "" : void 0;
            first = S.charCodeAt(position);
            return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
          };
        },
        "./node_modules/core-js/internals/to-absolute-index.js": function(module3, exports2, __webpack_require__2) {
          var toInteger = __webpack_require__2("./node_modules/core-js/internals/to-integer.js");
          var max = Math.max;
          var min = Math.min;
          module3.exports = function(index2, length) {
            var integer = toInteger(index2);
            return integer < 0 ? max(integer + length, 0) : min(integer, length);
          };
        },
        "./node_modules/core-js/internals/to-indexed-object.js": function(module3, exports2, __webpack_require__2) {
          var IndexedObject = __webpack_require__2("./node_modules/core-js/internals/indexed-object.js");
          var requireObjectCoercible = __webpack_require__2("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        },
        "./node_modules/core-js/internals/to-integer.js": function(module3, exports2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module3.exports = function(argument) {
            return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
          };
        },
        "./node_modules/core-js/internals/to-length.js": function(module3, exports2, __webpack_require__2) {
          var toInteger = __webpack_require__2("./node_modules/core-js/internals/to-integer.js");
          var min = Math.min;
          module3.exports = function(argument) {
            return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
          };
        },
        "./node_modules/core-js/internals/to-object.js": function(module3, exports2, __webpack_require__2) {
          var requireObjectCoercible = __webpack_require__2("./node_modules/core-js/internals/require-object-coercible.js");
          module3.exports = function(argument) {
            return Object(requireObjectCoercible(argument));
          };
        },
        "./node_modules/core-js/internals/to-primitive.js": function(module3, exports2, __webpack_require__2) {
          var isObject = __webpack_require__2("./node_modules/core-js/internals/is-object.js");
          module3.exports = function(it, S) {
            if (!isObject(it))
              return it;
            var fn, val;
            if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
              return val;
            if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
              return val;
            if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
              return val;
            throw TypeError("Can't convert object to primitive value");
          };
        },
        "./node_modules/core-js/internals/uid.js": function(module3, exports2) {
          var id = 0;
          var postfix = Math.random();
          module3.exports = function(key) {
            return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + postfix).toString(36));
          };
        },
        "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": function(module3, exports2, __webpack_require__2) {
          var isObject = __webpack_require__2("./node_modules/core-js/internals/is-object.js");
          var anObject = __webpack_require__2("./node_modules/core-js/internals/an-object.js");
          module3.exports = function(O, proto) {
            anObject(O);
            if (!isObject(proto) && proto !== null) {
              throw TypeError("Can't set " + String(proto) + " as a prototype");
            }
          };
        },
        "./node_modules/core-js/internals/well-known-symbol.js": function(module3, exports2, __webpack_require__2) {
          var global2 = __webpack_require__2("./node_modules/core-js/internals/global.js");
          var shared = __webpack_require__2("./node_modules/core-js/internals/shared.js");
          var uid = __webpack_require__2("./node_modules/core-js/internals/uid.js");
          var NATIVE_SYMBOL = __webpack_require__2("./node_modules/core-js/internals/native-symbol.js");
          var Symbol2 = global2.Symbol;
          var store = shared("wks");
          module3.exports = function(name) {
            return store[name] || (store[name] = NATIVE_SYMBOL && Symbol2[name] || (NATIVE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
          };
        },
        "./node_modules/core-js/modules/es.array.from.js": function(module3, exports2, __webpack_require__2) {
          var $ = __webpack_require__2("./node_modules/core-js/internals/export.js");
          var from = __webpack_require__2("./node_modules/core-js/internals/array-from.js");
          var checkCorrectnessOfIteration = __webpack_require__2("./node_modules/core-js/internals/check-correctness-of-iteration.js");
          var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
            Array.from(iterable);
          });
          $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
            from
          });
        },
        "./node_modules/core-js/modules/es.string.iterator.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var codePointAt = __webpack_require__2("./node_modules/core-js/internals/string-at.js");
          var InternalStateModule = __webpack_require__2("./node_modules/core-js/internals/internal-state.js");
          var defineIterator = __webpack_require__2("./node_modules/core-js/internals/define-iterator.js");
          var STRING_ITERATOR = "String Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
          defineIterator(String, "String", function(iterated) {
            setInternalState(this, {
              type: STRING_ITERATOR,
              string: String(iterated),
              index: 0
            });
          }, function next() {
            var state = getInternalState(this);
            var string = state.string;
            var index2 = state.index;
            var point;
            if (index2 >= string.length)
              return { value: void 0, done: true };
            point = codePointAt(string, index2, true);
            state.index += point.length;
            return { value: point, done: false };
          });
        },
        "./node_modules/webpack/buildin/global.js": function(module3, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || Function("return this")() || (1, eval)("this");
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module3.exports = g;
        },
        "./src/default-attrs.json": function(module3) {
          module3.exports = { "xmlns": "http://www.w3.org/2000/svg", "width": 24, "height": 24, "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" };
        },
        "./src/icon.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _dedupe = __webpack_require__2("./node_modules/classnames/dedupe.js");
          var _dedupe2 = _interopRequireDefault(_dedupe);
          var _defaultAttrs = __webpack_require__2("./src/default-attrs.json");
          var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          var Icon = function() {
            function Icon2(name, contents) {
              var tags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              _classCallCheck(this, Icon2);
              this.name = name;
              this.contents = contents;
              this.tags = tags;
              this.attrs = _extends({}, _defaultAttrs2.default, { class: "feather feather-" + name });
            }
            _createClass(Icon2, [{
              key: "toSvg",
              value: function toSvg() {
                var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });
                return "<svg " + attrsToString(combinedAttrs) + ">" + this.contents + "</svg>";
              }
            }, {
              key: "toString",
              value: function toString() {
                return this.contents;
              }
            }]);
            return Icon2;
          }();
          function attrsToString(attrs) {
            return Object.keys(attrs).map(function(key) {
              return key + '="' + attrs[key] + '"';
            }).join(" ");
          }
          exports2.default = Icon;
        },
        "./src/icons.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _icon = __webpack_require__2("./src/icon.js");
          var _icon2 = _interopRequireDefault(_icon);
          var _icons = __webpack_require__2("./dist/icons.json");
          var _icons2 = _interopRequireDefault(_icons);
          var _tags = __webpack_require__2("./src/tags.json");
          var _tags2 = _interopRequireDefault(_tags);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = Object.keys(_icons2.default).map(function(key) {
            return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
          }).reduce(function(object, icon) {
            object[icon.name] = icon;
            return object;
          }, {});
        },
        "./src/index.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          var _icons = __webpack_require__2("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          var _toSvg = __webpack_require__2("./src/to-svg.js");
          var _toSvg2 = _interopRequireDefault(_toSvg);
          var _replace = __webpack_require__2("./src/replace.js");
          var _replace2 = _interopRequireDefault(_replace);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          module3.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };
        },
        "./src/replace.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _dedupe = __webpack_require__2("./node_modules/classnames/dedupe.js");
          var _dedupe2 = _interopRequireDefault(_dedupe);
          var _icons = __webpack_require__2("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function replace() {
            var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (typeof document === "undefined") {
              throw new Error("`feather.replace()` only works in a browser environment.");
            }
            var elementsToReplace = document.querySelectorAll("[data-feather]");
            Array.from(elementsToReplace).forEach(function(element) {
              return replaceElement(element, attrs);
            });
          }
          function replaceElement(element) {
            var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var elementAttrs = getAttrs(element);
            var name = elementAttrs["data-feather"];
            delete elementAttrs["data-feather"];
            var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
            var svgDocument = new DOMParser().parseFromString(svgString, "image/svg+xml");
            var svgElement = svgDocument.querySelector("svg");
            element.parentNode.replaceChild(svgElement, element);
          }
          function getAttrs(element) {
            return Array.from(element.attributes).reduce(function(attrs, attr) {
              attrs[attr.name] = attr.value;
              return attrs;
            }, {});
          }
          exports2.default = replace;
        },
        "./src/tags.json": function(module3) {
          module3.exports = { "activity": ["pulse", "health", "action", "motion"], "airplay": ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], "anchor": [], "archive": ["index", "box"], "at-sign": ["mention", "at", "email", "message"], "award": ["achievement", "badge"], "aperture": ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], "battery": ["power", "electricity"], "battery-charging": ["power", "electricity"], "bell": ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], "bluetooth": ["wireless"], "book-open": ["read", "library"], "book": ["read", "dictionary", "booklet", "magazine", "library"], "bookmark": ["read", "clip", "marker", "tag"], "box": ["cube"], "briefcase": ["work", "bag", "baggage", "folder"], "calendar": ["date"], "camera": ["photo"], "cast": ["chromecast", "airplay"], "circle": ["off", "zero", "record"], "clipboard": ["copy"], "clock": ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], "cloud": ["weather"], "codepen": ["logo"], "codesandbox": ["logo"], "code": ["source", "programming"], "coffee": ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], "columns": ["layout"], "command": ["keyboard", "cmd", "terminal", "prompt"], "compass": ["navigation", "safari", "travel", "direction"], "copy": ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], "cpu": ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], "crop": ["photo", "image"], "crosshair": ["aim", "target"], "database": ["storage", "memory"], "delete": ["remove"], "disc": ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], "droplet": ["water"], "edit": ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], "eye": ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], "facebook": ["logo", "social"], "fast-forward": ["music"], "figma": ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], "film": ["movie", "video"], "filter": ["funnel", "hopper"], "flag": ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], "folder": ["directory"], "framer": ["logo", "design", "tool"], "frown": ["emoji", "face", "bad", "sad", "emotion"], "gift": ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], "github": ["logo", "version control"], "gitlab": ["logo", "version control"], "globe": ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], "hash": ["hashtag", "number", "pound"], "headphones": ["music", "audio", "sound"], "heart": ["like", "love", "emotion"], "help-circle": ["question mark"], "hexagon": ["shape", "node.js", "logo"], "home": ["house", "living"], "image": ["picture"], "inbox": ["email"], "instagram": ["logo", "camera"], "key": ["password", "login", "authentication", "secure"], "layers": ["stack"], "layout": ["window", "webpage"], "life-bouy": ["help", "life ring", "support"], "link": ["chain", "url"], "link-2": ["chain", "url"], "linkedin": ["logo", "social media"], "list": ["options"], "lock": ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], "mail": ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], "map": ["location", "navigation", "travel"], "maximize": ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], "meh": ["emoji", "face", "neutral", "emotion"], "menu": ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], "mic": ["record", "sound", "listen"], "minimize": ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], "minus": ["subtract"], "monitor": ["tv", "screen", "display"], "moon": ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], "move": ["arrows"], "music": ["note"], "navigation": ["location", "travel"], "navigation-2": ["location", "travel"], "octagon": ["stop"], "package": ["box", "container"], "paperclip": ["attachment"], "pause": ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], "percent": ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], "phone": ["call"], "play": ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], "plus": ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], "pocket": ["logo", "save"], "power": ["on", "off"], "printer": ["fax", "office", "device"], "radio": ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], "repeat": ["loop", "arrows"], "rewind": ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], "rss": ["feed", "subscribe"], "save": ["floppy disk"], "scissors": ["cut"], "search": ["find", "magnifier", "magnifying glass"], "send": ["message", "mail", "email", "paper airplane", "paper aeroplane"], "settings": ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], "shield": ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], "shuffle": ["music"], "skip-back": ["music"], "skip-forward": ["music"], "slack": ["logo"], "slash": ["ban", "no"], "sliders": ["settings", "controls"], "smartphone": ["cellphone", "device"], "smile": ["emoji", "face", "happy", "good", "emotion"], "speaker": ["audio", "music"], "star": ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], "sun": ["brightness", "weather", "light"], "sunrise": ["weather", "time", "morning", "day"], "sunset": ["weather", "time", "evening", "night"], "tablet": ["device"], "tag": ["label"], "target": ["logo", "bullseye"], "terminal": ["code", "command line", "prompt"], "thermometer": ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], "tool": ["settings", "spanner"], "trash": ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], "triangle": ["delta"], "truck": ["delivery", "van", "shipping", "transport", "lorry"], "tv": ["television", "stream"], "twitch": ["logo"], "twitter": ["logo", "social"], "type": ["text"], "umbrella": ["rain", "weather"], "unlock": ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], "user": ["person", "account"], "users": ["group"], "video-off": ["camera", "movie", "film"], "video": ["camera", "movie", "film"], "voicemail": ["phone"], "volume": ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], "watch": ["clock", "time"], "wifi-off": ["disabled"], "wifi": ["connection", "signal", "wireless"], "wind": ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], "x": ["cancel", "close", "delete", "remove", "times", "clear"], "youtube": ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], "zap": ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
        },
        "./src/to-svg.js": function(module3, exports2, __webpack_require__2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _icons = __webpack_require__2("./src/icons.js");
          var _icons2 = _interopRequireDefault(_icons);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toSvg(name) {
            var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.");
            if (!name) {
              throw new Error("The required `key` (icon name) parameter is missing.");
            }
            if (!_icons2.default[name]) {
              throw new Error("No icon matching '" + name + "'. See the complete list of icons at https://feathericons.com");
            }
            return _icons2.default[name].toSvg(attrs);
          }
          exports2.default = toSvg;
        },
        0: function(module3, exports2, __webpack_require__2) {
          __webpack_require__2("./node_modules/core-js/es/array/from.js");
          module3.exports = __webpack_require__2("./src/index.js");
        }
      });
    });
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    init_shims();
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b) {
        d2.__proto__ = b;
      } || function(d2, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d2[p] = b[p];
      };
      __extends = function(d2, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d2, b);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t[p] = s2[p];
        }
        return t;
      };
      __rest = function(s2, e) {
        var t = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
            t[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
              t[p[i]] = s2[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error3) {
          e = { error: error3 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
          s2 += arguments[i].length;
        for (var r = Array(s2), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || from);
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d2, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/ts-invariant/lib/invariant.js
var require_invariant = __commonJS({
  "node_modules/ts-invariant/lib/invariant.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = require_tslib();
    var genericMessage = "Invariant Violation";
    var _a = Object.setPrototypeOf;
    var setPrototypeOf = _a === void 0 ? function(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    } : _a;
    var InvariantError = function(_super) {
      tslib.__extends(InvariantError2, _super);
      function InvariantError2(message) {
        if (message === void 0) {
          message = genericMessage;
        }
        var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
        _this.framesToPop = 1;
        _this.name = genericMessage;
        setPrototypeOf(_this, InvariantError2.prototype);
        return _this;
      }
      return InvariantError2;
    }(Error);
    function invariant(condition, message) {
      if (!condition) {
        throw new InvariantError(message);
      }
    }
    var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
    var verbosityLevel = verbosityLevels.indexOf("log");
    function wrapConsoleMethod(name) {
      return function() {
        if (verbosityLevels.indexOf(name) >= verbosityLevel) {
          var method = console[name] || console.log;
          return method.apply(console, arguments);
        }
      };
    }
    (function(invariant2) {
      invariant2.debug = wrapConsoleMethod("debug");
      invariant2.log = wrapConsoleMethod("log");
      invariant2.warn = wrapConsoleMethod("warn");
      invariant2.error = wrapConsoleMethod("error");
    })(invariant || (invariant = {}));
    function setVerbosity(level) {
      var old = verbosityLevels[verbosityLevel];
      verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
      return old;
    }
    var invariant$1 = invariant;
    exports.InvariantError = InvariantError;
    exports["default"] = invariant$1;
    exports.invariant = invariant;
    exports.setVerbosity = setVerbosity;
  }
});

// node_modules/ts-invariant/process/main.js
var require_main = __commonJS({
  "node_modules/ts-invariant/process/main.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function maybe(thunk) {
      try {
        return thunk();
      } catch (_) {
      }
    }
    var safeGlobal = maybe(function() {
      return globalThis;
    }) || maybe(function() {
      return window;
    }) || maybe(function() {
      return self;
    }) || maybe(function() {
      return global;
    }) || maybe(function() {
      return Function("return this")();
    });
    var needToRemove = false;
    function install() {
      if (safeGlobal && !maybe(function() {
        return process.env.NODE_ENV;
      }) && !maybe(function() {
        return process;
      })) {
        Object.defineProperty(safeGlobal, "process", {
          value: {
            env: {
              NODE_ENV: "production"
            }
          },
          configurable: true,
          enumerable: false,
          writable: true
        });
        needToRemove = true;
      }
    }
    install();
    function remove() {
      if (needToRemove) {
        delete safeGlobal.process;
        needToRemove = false;
      }
    }
    exports.install = install;
    exports.remove = remove;
  }
});

// node_modules/graphql/version.js
var require_version = __commonJS({
  "node_modules/graphql/version.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.versionInfo = exports.version = void 0;
    var version = "15.8.0";
    exports.version = version;
    var versionInfo = Object.freeze({
      major: 15,
      minor: 8,
      patch: 0,
      preReleaseTag: null
    });
    exports.versionInfo = versionInfo;
  }
});

// node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/graphql/jsutils/isPromise.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPromise;
    function isPromise(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/graphql/jsutils/isObjectLike.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isObjectLike;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function isObjectLike(value) {
      return _typeof(value) == "object" && value !== null;
    }
  }
});

// node_modules/graphql/polyfills/symbols.js
var require_symbols = __commonJS({
  "node_modules/graphql/polyfills/symbols.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SYMBOL_TO_STRING_TAG = exports.SYMBOL_ASYNC_ITERATOR = exports.SYMBOL_ITERATOR = void 0;
    var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
    exports.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
    var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
    exports.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
    var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
    exports.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/graphql/language/location.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getLocation = getLocation;
    function getLocation(source, position) {
      var lineRegexp = /\r\n|[\n\r]/g;
      var line = 1;
      var column = position + 1;
      var match;
      while ((match = lineRegexp.exec(source.body)) && match.index < position) {
        line += 1;
        column = position + 1 - (match.index + match[0].length);
      }
      return {
        line,
        column
      };
    }
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/graphql/language/printLocation.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printLocation = printLocation;
    exports.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
    }
    function printSourceLocation(source, sourceLocation) {
      var firstLineColumnOffset = source.locationOffset.column - 1;
      var body = whitespace(firstLineColumnOffset) + source.body;
      var lineIndex = sourceLocation.line - 1;
      var lineOffset = source.locationOffset.line - 1;
      var lineNum = sourceLocation.line + lineOffset;
      var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      var columnNum = sourceLocation.column + columnOffset;
      var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
      var lines = body.split(/\r\n|[\n\r]/g);
      var locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        var subLineIndex = Math.floor(columnNum / 80);
        var subLineColumnNum = columnNum % 80;
        var subLines = [];
        for (var i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
          return ["", subLine];
        }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
      }
      return locationStr + printPrefixedLines([
        ["".concat(lineNum - 1), lines[lineIndex - 1]],
        ["".concat(lineNum), locationLine],
        ["", whitespace(columnNum - 1) + "^"],
        ["".concat(lineNum + 1), lines[lineIndex + 1]]
      ]);
    }
    function printPrefixedLines(lines) {
      var existingLines = lines.filter(function(_ref) {
        var _ = _ref[0], line = _ref[1];
        return line !== void 0;
      });
      var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
        var prefix = _ref2[0];
        return prefix.length;
      }));
      return existingLines.map(function(_ref3) {
        var prefix = _ref3[0], line = _ref3[1];
        return leftPad(padLen, prefix) + (line ? " | " + line : " |");
      }).join("\n");
    }
    function whitespace(len) {
      return Array(len + 1).join(" ");
    }
    function leftPad(len, str) {
      return whitespace(len - str.length) + str;
    }
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/graphql/error/GraphQLError.js"(exports) {
    init_shims();
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printError = printError;
    exports.GraphQLError = void 0;
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _symbols = require_symbols();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var GraphQLError = /* @__PURE__ */ function(_Error) {
      _inherits(GraphQLError2, _Error);
      var _super = _createSuper(GraphQLError2);
      function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
        var _nodeLocations, _nodeLocations2, _nodeLocations3;
        var _this;
        _classCallCheck(this, GraphQLError2);
        _this = _super.call(this, message);
        _this.name = "GraphQLError";
        _this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
        var nodeLocations = [];
        for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== void 0 ? _this$nodes : []; _i2 < _ref3.length; _i2++) {
          var _this$nodes;
          var _ref4 = _ref3[_i2];
          var loc = _ref4.loc;
          if (loc != null) {
            nodeLocations.push(loc);
          }
        }
        nodeLocations = undefinedIfEmpty(nodeLocations);
        _this.source = source !== null && source !== void 0 ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === void 0 ? void 0 : _nodeLocations[0].source;
        _this.positions = positions !== null && positions !== void 0 ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === void 0 ? void 0 : _nodeLocations2.map(function(loc2) {
          return loc2.start;
        });
        _this.locations = positions && source ? positions.map(function(pos) {
          return (0, _location.getLocation)(source, pos);
        }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === void 0 ? void 0 : _nodeLocations3.map(function(loc2) {
          return (0, _location.getLocation)(loc2.source, loc2.start);
        });
        _this.path = path !== null && path !== void 0 ? path : void 0;
        var originalExtensions = originalError === null || originalError === void 0 ? void 0 : originalError.extensions;
        if (extensions == null && (0, _isObjectLike.default)(originalExtensions)) {
          _this.extensions = _objectSpread({}, originalExtensions);
        } else {
          _this.extensions = extensions !== null && extensions !== void 0 ? extensions : {};
        }
        Object.defineProperties(_assertThisInitialized(_this), {
          message: {
            enumerable: true
          },
          locations: {
            enumerable: _this.locations != null
          },
          path: {
            enumerable: _this.path != null
          },
          extensions: {
            enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(_assertThisInitialized(_this), "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
          return _possibleConstructorReturn(_this);
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
        } else {
          Object.defineProperty(_assertThisInitialized(_this), "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
        return _this;
      }
      _createClass(GraphQLError2, [{
        key: "toString",
        value: function toString() {
          return printError(this);
        }
      }, {
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "Object";
        }
      }]);
      return GraphQLError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    exports.GraphQLError = GraphQLError;
    function undefinedIfEmpty(array) {
      return array === void 0 || array.length === 0 ? void 0 : array;
    }
    function printError(error3) {
      var output = error3.message;
      if (error3.nodes) {
        for (var _i4 = 0, _error$nodes2 = error3.nodes; _i4 < _error$nodes2.length; _i4++) {
          var node = _error$nodes2[_i4];
          if (node.loc) {
            output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
          }
        }
      } else if (error3.source && error3.locations) {
        for (var _i6 = 0, _error$locations2 = error3.locations; _i6 < _error$locations2.length; _i6++) {
          var location = _error$locations2[_i6];
          output += "\n\n" + (0, _printLocation.printSourceLocation)(error3.source, location);
        }
      }
      return output;
    }
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/graphql/error/syntaxError.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
    }
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "node_modules/graphql/language/kinds.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Kind = void 0;
    var Kind = Object.freeze({
      NAME: "Name",
      DOCUMENT: "Document",
      OPERATION_DEFINITION: "OperationDefinition",
      VARIABLE_DEFINITION: "VariableDefinition",
      SELECTION_SET: "SelectionSet",
      FIELD: "Field",
      ARGUMENT: "Argument",
      FRAGMENT_SPREAD: "FragmentSpread",
      INLINE_FRAGMENT: "InlineFragment",
      FRAGMENT_DEFINITION: "FragmentDefinition",
      VARIABLE: "Variable",
      INT: "IntValue",
      FLOAT: "FloatValue",
      STRING: "StringValue",
      BOOLEAN: "BooleanValue",
      NULL: "NullValue",
      ENUM: "EnumValue",
      LIST: "ListValue",
      OBJECT: "ObjectValue",
      OBJECT_FIELD: "ObjectField",
      DIRECTIVE: "Directive",
      NAMED_TYPE: "NamedType",
      LIST_TYPE: "ListType",
      NON_NULL_TYPE: "NonNullType",
      SCHEMA_DEFINITION: "SchemaDefinition",
      OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
      SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
      OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
      FIELD_DEFINITION: "FieldDefinition",
      INPUT_VALUE_DEFINITION: "InputValueDefinition",
      INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
      UNION_TYPE_DEFINITION: "UnionTypeDefinition",
      ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
      ENUM_VALUE_DEFINITION: "EnumValueDefinition",
      INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
      DIRECTIVE_DEFINITION: "DirectiveDefinition",
      SCHEMA_EXTENSION: "SchemaExtension",
      SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
      OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
      INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
      UNION_TYPE_EXTENSION: "UnionTypeExtension",
      ENUM_TYPE_EXTENSION: "EnumTypeExtension",
      INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
    });
    exports.Kind = Kind;
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant2 = __commonJS({
  "node_modules/graphql/jsutils/invariant.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = invariant;
    function invariant(condition, message) {
      var booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message != null ? message : "Unexpected invariant triggered.");
      }
    }
  }
});

// node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js
var require_nodejsCustomInspectSymbol = __commonJS({
  "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
    var _default = nodejsCustomInspectSymbol;
    exports.default = _default;
  }
});

// node_modules/graphql/jsutils/defineInspect.js
var require_defineInspect = __commonJS({
  "node_modules/graphql/jsutils/defineInspect.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = defineInspect;
    var _invariant = _interopRequireDefault(require_invariant2());
    var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function defineInspect(classObject) {
      var fn = classObject.prototype.toJSON;
      typeof fn === "function" || (0, _invariant.default)(0);
      classObject.prototype.inspect = fn;
      if (_nodejsCustomInspectSymbol.default) {
        classObject.prototype[_nodejsCustomInspectSymbol.default] = fn;
      }
    }
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/graphql/language/ast.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isNode = isNode;
    exports.Token = exports.Location = void 0;
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Location = /* @__PURE__ */ function() {
      function Location2(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      var _proto = Location2.prototype;
      _proto.toJSON = function toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      };
      return Location2;
    }();
    exports.Location = Location;
    (0, _defineInspect.default)(Location);
    var Token = /* @__PURE__ */ function() {
      function Token2(kind, start, end, line, column, prev, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = prev;
        this.next = null;
      }
      var _proto2 = Token2.prototype;
      _proto2.toJSON = function toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      };
      return Token2;
    }();
    exports.Token = Token;
    (0, _defineInspect.default)(Token);
    function isNode(maybeNode) {
      return maybeNode != null && typeof maybeNode.kind === "string";
    }
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/graphql/language/tokenKind.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TokenKind = void 0;
    var TokenKind = Object.freeze({
      SOF: "<SOF>",
      EOF: "<EOF>",
      BANG: "!",
      DOLLAR: "$",
      AMP: "&",
      PAREN_L: "(",
      PAREN_R: ")",
      SPREAD: "...",
      COLON: ":",
      EQUALS: "=",
      AT: "@",
      BRACKET_L: "[",
      BRACKET_R: "]",
      BRACE_L: "{",
      PIPE: "|",
      BRACE_R: "}",
      NAME: "Name",
      INT: "Int",
      FLOAT: "Float",
      STRING: "String",
      BLOCK_STRING: "BlockString",
      COMMENT: "Comment"
    });
    exports.TokenKind = TokenKind;
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/graphql/jsutils/inspect.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = inspect;
    var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    function inspect(value) {
      return formatValue(value, []);
    }
    function formatValue(value, seenValues) {
      switch (_typeof(value)) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? "[function ".concat(value.name, "]") : "[function]";
        case "object":
          if (value === null) {
            return "null";
          }
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (previouslySeenValues.indexOf(value) !== -1) {
        return "[Circular]";
      }
      var seenValues = [].concat(previouslySeenValues, [value]);
      var customInspectFn = getCustomFn(value);
      if (customInspectFn !== void 0) {
        var customValue = customInspectFn.call(value);
        if (customValue !== value) {
          return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function formatObject(object, seenValues) {
      var keys = Object.keys(object);
      if (keys.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object) + "]";
      }
      var properties = keys.map(function(key) {
        var value = formatValue(object[key], seenValues);
        return key + ": " + value;
      });
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      var len = Math.min(MAX_ARRAY_LENGTH, array.length);
      var remaining = array.length - len;
      var items = [];
      for (var i = 0; i < len; ++i) {
        items.push(formatValue(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push("... ".concat(remaining, " more items"));
      }
      return "[" + items.join(", ") + "]";
    }
    function getCustomFn(object) {
      var customInspectFn = object[String(_nodejsCustomInspectSymbol.default)];
      if (typeof customInspectFn === "function") {
        return customInspectFn;
      }
      if (typeof object.inspect === "function") {
        return object.inspect;
      }
    }
    function getObjectTag(object) {
      var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        var name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/graphql/jsutils/devAssert.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = devAssert;
    function devAssert(condition, message) {
      var booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/graphql/jsutils/instanceOf.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var _default = process.env.NODE_ENV === "production" ? function instanceOf(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (_typeof(value) === "object" && value !== null) {
        var _value$constructor;
        var className = constructor.prototype[Symbol.toStringTag];
        var valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
        if (className === valueClassName) {
          var stringifiedValue = (0, _inspect.default)(value);
          throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
        }
      }
      return false;
    };
    exports.default = _default;
  }
});

// node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/graphql/language/source.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSource = isSource;
    exports.Source = void 0;
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Source = /* @__PURE__ */ function() {
      function Source2(body) {
        var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
        var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          line: 1,
          column: 1
        };
        typeof body === "string" || (0, _devAssert.default)(0, "Body must be a string. Received: ".concat((0, _inspect.default)(body), "."));
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.default)(0, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || (0, _devAssert.default)(0, "column in locationOffset is 1-indexed and must be positive.");
      }
      _createClass(Source2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "Source";
        }
      }]);
      return Source2;
    }();
    exports.Source = Source;
    function isSource(source) {
      return (0, _instanceOf.default)(source, Source);
    }
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/graphql/language/directiveLocation.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DirectiveLocation = void 0;
    var DirectiveLocation = Object.freeze({
      QUERY: "QUERY",
      MUTATION: "MUTATION",
      SUBSCRIPTION: "SUBSCRIPTION",
      FIELD: "FIELD",
      FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
      FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
      INLINE_FRAGMENT: "INLINE_FRAGMENT",
      VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
      SCHEMA: "SCHEMA",
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      FIELD_DEFINITION: "FIELD_DEFINITION",
      ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      ENUM_VALUE: "ENUM_VALUE",
      INPUT_OBJECT: "INPUT_OBJECT",
      INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
    });
    exports.DirectiveLocation = DirectiveLocation;
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/graphql/language/blockString.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dedentBlockStringValue = dedentBlockStringValue;
    exports.getBlockStringIndentation = getBlockStringIndentation;
    exports.printBlockString = printBlockString;
    function dedentBlockStringValue(rawString) {
      var lines = rawString.split(/\r\n|[\n\r]/g);
      var commonIndent = getBlockStringIndentation(rawString);
      if (commonIndent !== 0) {
        for (var i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      var startLine = 0;
      while (startLine < lines.length && isBlank(lines[startLine])) {
        ++startLine;
      }
      var endLine = lines.length;
      while (endLine > startLine && isBlank(lines[endLine - 1])) {
        --endLine;
      }
      return lines.slice(startLine, endLine).join("\n");
    }
    function isBlank(str) {
      for (var i = 0; i < str.length; ++i) {
        if (str[i] !== " " && str[i] !== "	") {
          return false;
        }
      }
      return true;
    }
    function getBlockStringIndentation(value) {
      var _commonIndent;
      var isFirstLine = true;
      var isEmptyLine = true;
      var indent = 0;
      var commonIndent = null;
      for (var i = 0; i < value.length; ++i) {
        switch (value.charCodeAt(i)) {
          case 13:
            if (value.charCodeAt(i + 1) === 10) {
              ++i;
            }
          case 10:
            isFirstLine = false;
            isEmptyLine = true;
            indent = 0;
            break;
          case 9:
          case 32:
            ++indent;
            break;
          default:
            if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
              commonIndent = indent;
            }
            isEmptyLine = false;
        }
      }
      return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
    }
    function printBlockString(value) {
      var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var isSingleLine = value.indexOf("\n") === -1;
      var hasLeadingSpace = value[0] === " " || value[0] === "	";
      var hasTrailingQuote = value[value.length - 1] === '"';
      var hasTrailingSlash = value[value.length - 1] === "\\";
      var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
      var result = "";
      if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
        result += "\n" + indentation;
      }
      result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
      if (printAsMultipleLines) {
        result += "\n";
      }
      return '"""' + result.replace(/"""/g, '\\"""') + '"""';
    }
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/graphql/language/lexer.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPunctuatorTokenKind = isPunctuatorTokenKind;
    exports.Lexer = void 0;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _tokenKind = require_tokenKind();
    var _blockString = require_blockString();
    var Lexer = /* @__PURE__ */ function() {
      function Lexer2(source) {
        var startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      var _proto = Lexer2.prototype;
      _proto.advance = function advance() {
        this.lastToken = this.token;
        var token = this.token = this.lookahead();
        return token;
      };
      _proto.lookahead = function lookahead() {
        var token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            var _token$next;
            token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      };
      return Lexer2;
    }();
    exports.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    function printCharCode(code) {
      return isNaN(code) ? _tokenKind.TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
    }
    function readToken(lexer, prev) {
      var source = lexer.source;
      var body = source.body;
      var bodyLength = body.length;
      var pos = prev.end;
      while (pos < bodyLength) {
        var code = body.charCodeAt(pos);
        var _line = lexer.line;
        var _col = 1 + pos - lexer.lineStart;
        switch (code) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++pos;
            continue;
          case 10:
            ++pos;
            ++lexer.line;
            lexer.lineStart = pos;
            continue;
          case 13:
            if (body.charCodeAt(pos + 1) === 10) {
              pos += 2;
            } else {
              ++pos;
            }
            ++lexer.line;
            lexer.lineStart = pos;
            continue;
          case 33:
            return new _ast.Token(_tokenKind.TokenKind.BANG, pos, pos + 1, _line, _col, prev);
          case 35:
            return readComment(source, pos, _line, _col, prev);
          case 36:
            return new _ast.Token(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
          case 38:
            return new _ast.Token(_tokenKind.TokenKind.AMP, pos, pos + 1, _line, _col, prev);
          case 40:
            return new _ast.Token(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
          case 41:
            return new _ast.Token(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
          case 46:
            if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
              return new _ast.Token(_tokenKind.TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
            }
            break;
          case 58:
            return new _ast.Token(_tokenKind.TokenKind.COLON, pos, pos + 1, _line, _col, prev);
          case 61:
            return new _ast.Token(_tokenKind.TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
          case 64:
            return new _ast.Token(_tokenKind.TokenKind.AT, pos, pos + 1, _line, _col, prev);
          case 91:
            return new _ast.Token(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
          case 93:
            return new _ast.Token(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
          case 123:
            return new _ast.Token(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
          case 124:
            return new _ast.Token(_tokenKind.TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
          case 125:
            return new _ast.Token(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
          case 34:
            if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
              return readBlockString(source, pos, _line, _col, prev, lexer);
            }
            return readString(source, pos, _line, _col, prev);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return readNumber(source, pos, code, _line, _col, prev);
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 95:
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            return readName(source, pos, _line, _col, prev);
        }
        throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));
      }
      var line = lexer.line;
      var col = 1 + pos - lexer.lineStart;
      return new _ast.Token(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
    }
    function unexpectedCharacterMessage(code) {
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
      }
      if (code === 39) {
        return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
      }
      return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
    }
    function readComment(source, start, line, col, prev) {
      var body = source.body;
      var code;
      var position = start;
      do {
        code = body.charCodeAt(++position);
      } while (!isNaN(code) && (code > 31 || code === 9));
      return new _ast.Token(_tokenKind.TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
    }
    function readNumber(source, start, firstCode, line, col, prev) {
      var body = source.body;
      var code = firstCode;
      var position = start;
      var isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if (code >= 48 && code <= 57) {
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
        }
      } else {
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || isNameStart(code)) {
        throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
      }
      return new _ast.Token(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
    }
    function readDigits(source, start, firstCode) {
      var body = source.body;
      var position = start;
      var code = firstCode;
      if (code >= 48 && code <= 57) {
        do {
          code = body.charCodeAt(++position);
        } while (code >= 48 && code <= 57);
        return position;
      }
      throw (0, _syntaxError.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
    }
    function readString(source, start, line, col, prev) {
      var body = source.body;
      var position = start + 1;
      var chunkStart = position;
      var code = 0;
      var value = "";
      while (position < body.length && !isNaN(code = body.charCodeAt(position)) && code !== 10 && code !== 13) {
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return new _ast.Token(_tokenKind.TokenKind.STRING, start, position + 1, line, col, prev, value);
        }
        if (code < 32 && code !== 9) {
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        ++position;
        if (code === 92) {
          value += body.slice(chunkStart, position - 1);
          code = body.charCodeAt(position);
          switch (code) {
            case 34:
              value += '"';
              break;
            case 47:
              value += "/";
              break;
            case 92:
              value += "\\";
              break;
            case 98:
              value += "\b";
              break;
            case 102:
              value += "\f";
              break;
            case 110:
              value += "\n";
              break;
            case 114:
              value += "\r";
              break;
            case 116:
              value += "	";
              break;
            case 117: {
              var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
              if (charCode < 0) {
                var invalidSequence = body.slice(position + 1, position + 5);
                throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
              }
              value += String.fromCharCode(charCode);
              position += 4;
              break;
            }
            default:
              throw (0, _syntaxError.syntaxError)(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
          }
          ++position;
          chunkStart = position;
        }
      }
      throw (0, _syntaxError.syntaxError)(source, position, "Unterminated string.");
    }
    function readBlockString(source, start, line, col, prev, lexer) {
      var body = source.body;
      var position = start + 3;
      var chunkStart = position;
      var code = 0;
      var rawValue = "";
      while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          rawValue += body.slice(chunkStart, position);
          return new _ast.Token(_tokenKind.TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));
        }
        if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
          throw (0, _syntaxError.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        if (code === 10) {
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 13) {
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
        } else if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          rawValue += body.slice(chunkStart, position) + '"""';
          position += 4;
          chunkStart = position;
        } else {
          ++position;
        }
      }
      throw (0, _syntaxError.syntaxError)(source, position, "Unterminated string.");
    }
    function uniCharCode(a, b, c, d2) {
      return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d2);
    }
    function char2hex(a) {
      return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
    }
    function readName(source, start, line, col, prev) {
      var body = source.body;
      var bodyLength = body.length;
      var position = start + 1;
      var code = 0;
      while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
        ++position;
      }
      return new _ast.Token(_tokenKind.TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
    }
    function isNameStart(code) {
      return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/graphql/language/parser.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parse = parse;
    exports.parseValue = parseValue;
    exports.parseType = parseType;
    exports.Parser = void 0;
    var _syntaxError = require_syntaxError();
    var _kinds = require_kinds();
    var _ast = require_ast();
    var _tokenKind = require_tokenKind();
    var _source = require_source();
    var _directiveLocation = require_directiveLocation();
    var _lexer = require_lexer();
    function parse(source, options2) {
      var parser = new Parser(source, options2);
      return parser.parseDocument();
    }
    function parseValue(source, options2) {
      var parser = new Parser(source, options2);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      var value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseType(source, options2) {
      var parser = new Parser(source, options2);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      var type = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type;
    }
    var Parser = /* @__PURE__ */ function() {
      function Parser2(source, options2) {
        var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options2;
      }
      var _proto = Parser2.prototype;
      _proto.parseName = function parseName() {
        var token = this.expectToken(_tokenKind.TokenKind.NAME);
        return {
          kind: _kinds.Kind.NAME,
          value: token.value,
          loc: this.loc(token)
        };
      };
      _proto.parseDocument = function parseDocument() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),
          loc: this.loc(start)
        };
      };
      _proto.parseDefinition = function parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          switch (this._lexer.token.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "schema":
            case "scalar":
            case "type":
            case "interface":
            case "union":
            case "enum":
            case "input":
            case "directive":
              return this.parseTypeSystemDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        } else if (this.peekDescription()) {
          return this.parseTypeSystemDefinition();
        }
        throw this.unexpected();
      };
      _proto.parseOperationDefinition = function parseOperationDefinition() {
        var start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: "query",
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }
        var operation = this.parseOperationType();
        var name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseOperationType = function parseOperationType() {
        var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return "query";
          case "mutation":
            return "mutation";
          case "subscription":
            return "subscription";
        }
        throw this.unexpected(operationToken);
      };
      _proto.parseVariableDefinitions = function parseVariableDefinitions() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseVariableDefinition = function parseVariableDefinition() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
          directives: this.parseDirectives(true),
          loc: this.loc(start)
        };
      };
      _proto.parseVariable = function parseVariable() {
        var start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      };
      _proto.parseSelectionSet = function parseSelectionSet() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      };
      _proto.parseSelection = function parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      };
      _proto.parseField = function parseField() {
        var start = this._lexer.token;
        var nameOrAlias = this.parseName();
        var alias;
        var name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
          loc: this.loc(start)
        };
      };
      _proto.parseArguments = function parseArguments(isConst) {
        var item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseArgument = function parseArgument() {
        var start = this._lexer.token;
        var name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(false),
          loc: this.loc(start)
        };
      };
      _proto.parseConstArgument = function parseConstArgument() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.ARGUMENT,
          name: this.parseName(),
          value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),
          loc: this.loc(start)
        };
      };
      _proto.parseFragment = function parseFragment() {
        var start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        var hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false),
            loc: this.loc(start)
          };
        }
        return {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseFragmentDefinition = function parseFragmentDefinition() {
        var _this$_options;
        var start = this._lexer.token;
        this.expectKeyword("fragment");
        if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
          return {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }
        return {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseFragmentName = function parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      };
      _proto.parseValueLiteral = function parseValueLiteral(isConst) {
        var token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this._lexer.advance();
            return {
              kind: _kinds.Kind.INT,
              value: token.value,
              loc: this.loc(token)
            };
          case _tokenKind.TokenKind.FLOAT:
            this._lexer.advance();
            return {
              kind: _kinds.Kind.FLOAT,
              value: token.value,
              loc: this.loc(token)
            };
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this._lexer.advance();
            switch (token.value) {
              case "true":
                return {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true,
                  loc: this.loc(token)
                };
              case "false":
                return {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false,
                  loc: this.loc(token)
                };
              case "null":
                return {
                  kind: _kinds.Kind.NULL,
                  loc: this.loc(token)
                };
              default:
                return {
                  kind: _kinds.Kind.ENUM,
                  value: token.value,
                  loc: this.loc(token)
                };
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (!isConst) {
              return this.parseVariable();
            }
            break;
        }
        throw this.unexpected();
      };
      _proto.parseStringLiteral = function parseStringLiteral() {
        var token = this._lexer.token;
        this._lexer.advance();
        return {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,
          loc: this.loc(token)
        };
      };
      _proto.parseList = function parseList(isConst) {
        var _this = this;
        var start = this._lexer.token;
        var item = function item2() {
          return _this.parseValueLiteral(isConst);
        };
        return {
          kind: _kinds.Kind.LIST,
          values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),
          loc: this.loc(start)
        };
      };
      _proto.parseObject = function parseObject(isConst) {
        var _this2 = this;
        var start = this._lexer.token;
        var item = function item2() {
          return _this2.parseObjectField(isConst);
        };
        return {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      };
      _proto.parseObjectField = function parseObjectField(isConst) {
        var start = this._lexer.token;
        var name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst),
          loc: this.loc(start)
        };
      };
      _proto.parseDirectives = function parseDirectives(isConst) {
        var directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      };
      _proto.parseDirective = function parseDirective(isConst) {
        var start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst),
          loc: this.loc(start)
        };
      };
      _proto.parseTypeReference = function parseTypeReference() {
        var start = this._lexer.token;
        var type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          type = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type = {
            kind: _kinds.Kind.LIST_TYPE,
            type,
            loc: this.loc(start)
          };
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type,
            loc: this.loc(start)
          };
        }
        return type;
      };
      _proto.parseNamedType = function parseNamedType() {
        var start = this._lexer.token;
        return {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      };
      _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
        var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.peekDescription = function peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      };
      _proto.parseDescription = function parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      };
      _proto.parseSchemaDefinition = function parseSchemaDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        return {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes,
          loc: this.loc(start)
        };
      };
      _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
        var start = this._lexer.token;
        var operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseNamedType();
        return {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type,
          loc: this.loc(start)
        };
      };
      _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("scalar");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("type");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
        var _this$_options2;
        if (!this.expectOptionalKeyword("implements")) {
          return [];
        }
        if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
          var types2 = [];
          this.expectOptionalToken(_tokenKind.TokenKind.AMP);
          do {
            types2.push(this.parseNamedType());
          } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || this.peek(_tokenKind.TokenKind.NAME));
          return types2;
        }
        return this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType);
      };
      _proto.parseFieldsDefinition = function parseFieldsDefinition() {
        var _this$_options3;
        if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {
          this._lexer.advance();
          this._lexer.advance();
          return [];
        }
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseFieldDefinition = function parseFieldDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        var args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseTypeReference();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseArgumentDefs = function parseArgumentDefs() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseInputValueDef = function parseInputValueDef() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseTypeReference();
        var defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseValueLiteral(true);
        }
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("interface");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("union");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var types2 = this.parseUnionMemberTypes();
        return {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types: types2,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      };
      _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("enum");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        return {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values,
          loc: this.loc(start)
        };
      };
      _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("input");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        return {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
        var keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.parseSchemaExtension = function parseSchemaExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes,
          loc: this.loc(start)
        };
      };
      _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        var name = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var types2 = this.parseUnionMemberTypes();
        if (directives.length === 0 && types2.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types: types2,
          loc: this.loc(start)
        };
      };
      _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values,
          loc: this.loc(start)
        };
      };
      _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        var name = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields,
          loc: this.loc(start)
        };
      };
      _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        var name = this.parseName();
        var args = this.parseArgumentDefs();
        var repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        var locations = this.parseDirectiveLocations();
        return {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations,
          loc: this.loc(start)
        };
      };
      _proto.parseDirectiveLocations = function parseDirectiveLocations() {
        return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
      };
      _proto.parseDirectiveLocation = function parseDirectiveLocation() {
        var start = this._lexer.token;
        var name = this.parseName();
        if (_directiveLocation.DirectiveLocation[name.value] !== void 0) {
          return name;
        }
        throw this.unexpected(start);
      };
      _proto.loc = function loc(startToken) {
        var _this$_options4;
        if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
          return new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
        }
      };
      _proto.peek = function peek(kind) {
        return this._lexer.token.kind === kind;
      };
      _proto.expectToken = function expectToken(kind) {
        var token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
      };
      _proto.expectOptionalToken = function expectOptionalToken(kind) {
        var token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        return void 0;
      };
      _proto.expectKeyword = function expectKeyword(value) {
        var token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this._lexer.advance();
        } else {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
        }
      };
      _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
        var token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this._lexer.advance();
          return true;
        }
        return false;
      };
      _proto.unexpected = function unexpected(atToken) {
        var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
      };
      _proto.any = function any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      };
      _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          var nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      };
      _proto.many = function many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      };
      _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      };
      return Parser2;
    }();
    exports.Parser = Parser;
    function getTokenDesc(token) {
      var value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
    }
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? '"'.concat(kind, '"') : kind;
    }
  }
});

// node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "node_modules/graphql/language/visitor.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.visit = visit;
    exports.visitInParallel = visitInParallel;
    exports.getVisitFn = getVisitFn;
    exports.BREAK = exports.QueryDocumentKeys = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    var _ast = require_ast();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
      InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports.QueryDocumentKeys = QueryDocumentKeys;
    var BREAK = Object.freeze({});
    exports.BREAK = BREAK;
    function visit(root, visitor) {
      var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
      var stack = void 0;
      var inArray = Array.isArray(root);
      var keys = [root];
      var index2 = -1;
      var edits = [];
      var node = void 0;
      var key = void 0;
      var parent = void 0;
      var path = [];
      var ancestors = [];
      var newRoot = root;
      do {
        index2++;
        var isLeaving = index2 === keys.length;
        var isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
            } else {
              var clone2 = {};
              for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
                var k = _Object$keys2[_i2];
                clone2[k] = node[k];
              }
              node = clone2;
            }
            var editOffset = 0;
            for (var ii = 0; ii < edits.length; ii++) {
              var editKey = edits[ii][0];
              var editValue = edits[ii][1];
              if (inArray) {
                editKey -= editOffset;
              }
              if (inArray && editValue === null) {
                node.splice(editKey, 1);
                editOffset++;
              } else {
                node[editKey] = editValue;
              }
            }
          }
          index2 = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else {
          key = parent ? inArray ? index2 : keys[index2] : void 0;
          node = parent ? parent[key] : newRoot;
          if (node === null || node === void 0) {
            continue;
          }
          if (parent) {
            path.push(key);
          }
        }
        var result = void 0;
        if (!Array.isArray(node)) {
          if (!(0, _ast.isNode)(node)) {
            throw new Error("Invalid AST Node: ".concat((0, _inspect.default)(node), "."));
          }
          var visitFn = getVisitFn(visitor, node.kind, isLeaving);
          if (visitFn) {
            result = visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _visitorKeys$node$kin;
          stack = {
            inArray,
            index: index2,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
          index2 = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        newRoot = edits[edits.length - 1][1];
      }
      return newRoot;
    }
    function visitInParallel(visitors) {
      var skipping = new Array(visitors.length);
      return {
        enter: function enter(node) {
          for (var i = 0; i < visitors.length; i++) {
            if (skipping[i] == null) {
              var fn = getVisitFn(visitors[i], node.kind, false);
              if (fn) {
                var result = fn.apply(visitors[i], arguments);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          }
        },
        leave: function leave(node) {
          for (var i = 0; i < visitors.length; i++) {
            if (skipping[i] == null) {
              var fn = getVisitFn(visitors[i], node.kind, true);
              if (fn) {
                var result = fn.apply(visitors[i], arguments);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              }
            } else if (skipping[i] === node) {
              skipping[i] = null;
            }
          }
        }
      };
    }
    function getVisitFn(visitor, kind, isLeaving) {
      var kindVisitor = visitor[kind];
      if (kindVisitor) {
        if (!isLeaving && typeof kindVisitor === "function") {
          return kindVisitor;
        }
        var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
        if (typeof kindSpecificVisitor === "function") {
          return kindSpecificVisitor;
        }
      } else {
        var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
        if (specificVisitor) {
          if (typeof specificVisitor === "function") {
            return specificVisitor;
          }
          var specificKindVisitor = specificVisitor[kind];
          if (typeof specificKindVisitor === "function") {
            return specificKindVisitor;
          }
        }
      }
    }
  }
});

// node_modules/graphql/polyfills/find.js
var require_find = __commonJS({
  "node_modules/graphql/polyfills/find.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var find = Array.prototype.find ? function(list, predicate) {
      return Array.prototype.find.call(list, predicate);
    } : function(list, predicate) {
      for (var _i2 = 0; _i2 < list.length; _i2++) {
        var value = list[_i2];
        if (predicate(value)) {
          return value;
        }
      }
    };
    var _default = find;
    exports.default = _default;
  }
});

// node_modules/graphql/polyfills/objectValues.js
var require_objectValues = __commonJS({
  "node_modules/graphql/polyfills/objectValues.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var objectValues = Object.values || function(obj) {
      return Object.keys(obj).map(function(key) {
        return obj[key];
      });
    };
    var _default = objectValues;
    exports.default = _default;
  }
});

// node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "node_modules/graphql/error/locatedError.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.locatedError = locatedError;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function locatedError(rawOriginalError, nodes, path) {
      var _nodes;
      var originalError = rawOriginalError instanceof Error ? rawOriginalError : new Error("Unexpected error value: " + (0, _inspect.default)(rawOriginalError));
      if (Array.isArray(originalError.path)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);
    }
  }
});

// node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "node_modules/graphql/utilities/assertValidName.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assertValidName = assertValidName;
    exports.isValidNameError = isValidNameError;
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _GraphQLError = require_GraphQLError();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
    function assertValidName(name) {
      var error3 = isValidNameError(name);
      if (error3) {
        throw error3;
      }
      return name;
    }
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.default)(0, "Expected name to be a string.");
      if (name.length > 1 && name[0] === "_" && name[1] === "_") {
        return new _GraphQLError.GraphQLError('Name "'.concat(name, '" must not begin with "__", which is reserved by GraphQL introspection.'));
      }
      if (!NAME_RX.test(name)) {
        return new _GraphQLError.GraphQLError('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "'.concat(name, '" does not.'));
      }
    }
  }
});

// node_modules/graphql/polyfills/objectEntries.js
var require_objectEntries = __commonJS({
  "node_modules/graphql/polyfills/objectEntries.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var objectEntries = Object.entries || function(obj) {
      return Object.keys(obj).map(function(key) {
        return [key, obj[key]];
      });
    };
    var _default = objectEntries;
    exports.default = _default;
  }
});

// node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "node_modules/graphql/jsutils/keyMap.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = keyMap;
    function keyMap(list, keyFn) {
      return list.reduce(function(map, item) {
        map[keyFn(item)] = item;
        return map;
      }, Object.create(null));
    }
  }
});

// node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "node_modules/graphql/jsutils/mapValue.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mapValue;
    var _objectEntries3 = _interopRequireDefault(require_objectEntries());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function mapValue(map, fn) {
      var result = Object.create(null);
      for (var _i2 = 0, _objectEntries2 = (0, _objectEntries3.default)(map); _i2 < _objectEntries2.length; _i2++) {
        var _ref2 = _objectEntries2[_i2];
        var _key = _ref2[0];
        var _value = _ref2[1];
        result[_key] = fn(_value, _key);
      }
      return result;
    }
  }
});

// node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "node_modules/graphql/jsutils/toObjMap.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = toObjMap;
    var _objectEntries3 = _interopRequireDefault(require_objectEntries());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function toObjMap(obj) {
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      var map = Object.create(null);
      for (var _i2 = 0, _objectEntries2 = (0, _objectEntries3.default)(obj); _i2 < _objectEntries2.length; _i2++) {
        var _ref2 = _objectEntries2[_i2];
        var key = _ref2[0];
        var value = _ref2[1];
        map[key] = value;
      }
      return map;
    }
  }
});

// node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "node_modules/graphql/jsutils/keyValMap.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      return list.reduce(function(map, item) {
        map[keyFn(item)] = valFn(item);
        return map;
      }, Object.create(null));
    }
  }
});

// node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "node_modules/graphql/jsutils/didYouMean.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      var _ref = typeof firstArg === "string" ? [firstArg, secondArg] : [void 0, firstArg], subMessage = _ref[0], suggestionsArg = _ref[1];
      var message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      var suggestions = suggestionsArg.map(function(x) {
        return '"'.concat(x, '"');
      });
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      var selected = suggestions.slice(0, MAX_SUGGESTIONS);
      var lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
  }
});

// node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "node_modules/graphql/jsutils/identityFunc.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = identityFunc;
    function identityFunc(x) {
      return x;
    }
  }
});

// node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "node_modules/graphql/jsutils/naturalCompare.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = naturalCompare;
    function naturalCompare(aStr, bStr) {
      var aIdx = 0;
      var bIdx = 0;
      while (aIdx < aStr.length && bIdx < bStr.length) {
        var aChar = aStr.charCodeAt(aIdx);
        var bChar = bStr.charCodeAt(bIdx);
        if (isDigit(aChar) && isDigit(bChar)) {
          var aNum = 0;
          do {
            ++aIdx;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIdx);
          } while (isDigit(aChar) && aNum > 0);
          var bNum = 0;
          do {
            ++bIdx;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIdx);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIdx;
          ++bIdx;
        }
      }
      return aStr.length - bStr.length;
    }
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
  }
});

// node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "node_modules/graphql/jsutils/suggestionList.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = suggestionList;
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function suggestionList(input, options2) {
      var optionsByDistance = Object.create(null);
      var lexicalDistance = new LexicalDistance(input);
      var threshold = Math.floor(input.length * 0.4) + 1;
      for (var _i2 = 0; _i2 < options2.length; _i2++) {
        var option = options2[_i2];
        var distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort(function(a, b) {
        var distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.default)(a, b);
      });
    }
    var LexicalDistance = /* @__PURE__ */ function() {
      function LexicalDistance2(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];
      }
      var _proto = LexicalDistance2.prototype;
      _proto.measure = function measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        var optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        var a = stringToArray(optionLowerCase);
        var b = this._inputArray;
        if (a.length < b.length) {
          var tmp = a;
          a = b;
          b = tmp;
        }
        var aLength = a.length;
        var bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        var rows = this._rows;
        for (var j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (var i = 1; i <= aLength; i++) {
          var upRow = rows[(i - 1) % 3];
          var currentRow = rows[i % 3];
          var smallestCell = currentRow[0] = i;
          for (var _j = 1; _j <= bLength; _j++) {
            var cost = a[i - 1] === b[_j - 1] ? 0 : 1;
            var currentCell = Math.min(upRow[_j] + 1, currentRow[_j - 1] + 1, upRow[_j - 1] + cost);
            if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {
              var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[_j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        var distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      };
      return LexicalDistance2;
    }();
    function stringToArray(str) {
      var strLength = str.length;
      var array = new Array(strLength);
      for (var i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
  }
});

// node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "node_modules/graphql/language/printer.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.print = print;
    var _visitor = require_visitor();
    var _blockString = require_blockString();
    function print(ast) {
      return (0, _visitor.visit)(ast, {
        leave: printDocASTReducer
      });
    }
    var MAX_LINE_LENGTH = 80;
    var printDocASTReducer = {
      Name: function Name(node) {
        return node.value;
      },
      Variable: function Variable(node) {
        return "$" + node.name;
      },
      Document: function Document(node) {
        return join(node.definitions, "\n\n") + "\n";
      },
      OperationDefinition: function OperationDefinition(node) {
        var op = node.operation;
        var name = node.name;
        var varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        var directives = join(node.directives, " ");
        var selectionSet = node.selectionSet;
        return !name && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], " ");
      },
      VariableDefinition: function VariableDefinition(_ref) {
        var variable = _ref.variable, type = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
        return variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
      },
      SelectionSet: function SelectionSet(_ref2) {
        var selections = _ref2.selections;
        return block(selections);
      },
      Field: function Field(_ref3) {
        var alias = _ref3.alias, name = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
        var prefix = wrap("", alias, ": ") + name;
        var argsLine = prefix + wrap("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      },
      Argument: function Argument(_ref4) {
        var name = _ref4.name, value = _ref4.value;
        return name + ": " + value;
      },
      FragmentSpread: function FragmentSpread(_ref5) {
        var name = _ref5.name, directives = _ref5.directives;
        return "..." + name + wrap(" ", join(directives, " "));
      },
      InlineFragment: function InlineFragment(_ref6) {
        var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
        return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
      },
      FragmentDefinition: function FragmentDefinition(_ref7) {
        var name = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
        return "fragment ".concat(name).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet;
      },
      IntValue: function IntValue(_ref8) {
        var value = _ref8.value;
        return value;
      },
      FloatValue: function FloatValue(_ref9) {
        var value = _ref9.value;
        return value;
      },
      StringValue: function StringValue(_ref10, key) {
        var value = _ref10.value, isBlockString = _ref10.block;
        return isBlockString ? (0, _blockString.printBlockString)(value, key === "description" ? "" : "  ") : JSON.stringify(value);
      },
      BooleanValue: function BooleanValue(_ref11) {
        var value = _ref11.value;
        return value ? "true" : "false";
      },
      NullValue: function NullValue() {
        return "null";
      },
      EnumValue: function EnumValue(_ref12) {
        var value = _ref12.value;
        return value;
      },
      ListValue: function ListValue(_ref13) {
        var values = _ref13.values;
        return "[" + join(values, ", ") + "]";
      },
      ObjectValue: function ObjectValue(_ref14) {
        var fields = _ref14.fields;
        return "{" + join(fields, ", ") + "}";
      },
      ObjectField: function ObjectField(_ref15) {
        var name = _ref15.name, value = _ref15.value;
        return name + ": " + value;
      },
      Directive: function Directive(_ref16) {
        var name = _ref16.name, args = _ref16.arguments;
        return "@" + name + wrap("(", join(args, ", "), ")");
      },
      NamedType: function NamedType(_ref17) {
        var name = _ref17.name;
        return name;
      },
      ListType: function ListType(_ref18) {
        var type = _ref18.type;
        return "[" + type + "]";
      },
      NonNullType: function NonNullType(_ref19) {
        var type = _ref19.type;
        return type + "!";
      },
      SchemaDefinition: addDescription(function(_ref20) {
        var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
        return join(["schema", join(directives, " "), block(operationTypes)], " ");
      }),
      OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
        var operation = _ref21.operation, type = _ref21.type;
        return operation + ": " + type;
      },
      ScalarTypeDefinition: addDescription(function(_ref22) {
        var name = _ref22.name, directives = _ref22.directives;
        return join(["scalar", name, join(directives, " ")], " ");
      }),
      ObjectTypeDefinition: addDescription(function(_ref23) {
        var name = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
        return join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      }),
      FieldDefinition: addDescription(function(_ref24) {
        var name = _ref24.name, args = _ref24.arguments, type = _ref24.type, directives = _ref24.directives;
        return name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "));
      }),
      InputValueDefinition: addDescription(function(_ref25) {
        var name = _ref25.name, type = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
        return join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ");
      }),
      InterfaceTypeDefinition: addDescription(function(_ref26) {
        var name = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields = _ref26.fields;
        return join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      }),
      UnionTypeDefinition: addDescription(function(_ref27) {
        var name = _ref27.name, directives = _ref27.directives, types2 = _ref27.types;
        return join(["union", name, join(directives, " "), types2 && types2.length !== 0 ? "= " + join(types2, " | ") : ""], " ");
      }),
      EnumTypeDefinition: addDescription(function(_ref28) {
        var name = _ref28.name, directives = _ref28.directives, values = _ref28.values;
        return join(["enum", name, join(directives, " "), block(values)], " ");
      }),
      EnumValueDefinition: addDescription(function(_ref29) {
        var name = _ref29.name, directives = _ref29.directives;
        return join([name, join(directives, " ")], " ");
      }),
      InputObjectTypeDefinition: addDescription(function(_ref30) {
        var name = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
        return join(["input", name, join(directives, " "), block(fields)], " ");
      }),
      DirectiveDefinition: addDescription(function(_ref31) {
        var name = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
        return "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
      }),
      SchemaExtension: function SchemaExtension(_ref32) {
        var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
        return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
      },
      ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
        var name = _ref33.name, directives = _ref33.directives;
        return join(["extend scalar", name, join(directives, " ")], " ");
      },
      ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
        var name = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
        return join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      },
      InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
        var name = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields = _ref35.fields;
        return join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      },
      UnionTypeExtension: function UnionTypeExtension(_ref36) {
        var name = _ref36.name, directives = _ref36.directives, types2 = _ref36.types;
        return join(["extend union", name, join(directives, " "), types2 && types2.length !== 0 ? "= " + join(types2, " | ") : ""], " ");
      },
      EnumTypeExtension: function EnumTypeExtension(_ref37) {
        var name = _ref37.name, directives = _ref37.directives, values = _ref37.values;
        return join(["extend enum", name, join(directives, " "), block(values)], " ");
      },
      InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
        var name = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
        return join(["extend input", name, join(directives, " "), block(fields)], " ");
      }
    };
    function addDescription(cb) {
      return function(node) {
        return join([node.description, cb(node)], "\n");
      };
    }
    function join(maybeArray) {
      var _maybeArray$filter$jo;
      var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x) {
        return x;
      }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    function block(array) {
      return wrap("{\n", indent(join(array, "\n")), "\n}");
    }
    function wrap(start, maybeString) {
      var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    function indent(str) {
      return wrap("  ", str.replace(/\n/g, "\n  "));
    }
    function isMultiline(str) {
      return str.indexOf("\n") !== -1;
    }
    function hasMultilineItems(maybeArray) {
      return maybeArray != null && maybeArray.some(isMultiline);
    }
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "node_modules/graphql/utilities/valueFromASTUntyped.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.valueFromASTUntyped = valueFromASTUntyped;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _kinds = require_kinds();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map(function(node) {
            return valueFromASTUntyped(node, variables);
          });
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.default)(valueNode.fields, function(field) {
            return field.name.value;
          }, function(field) {
            return valueFromASTUntyped(field.value, variables);
          });
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
      (0, _invariant.default)(0, "Unexpected value node: " + (0, _inspect.default)(valueNode));
    }
  }
});

// node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "node_modules/graphql/type/definition.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isType = isType;
    exports.assertType = assertType;
    exports.isScalarType = isScalarType;
    exports.assertScalarType = assertScalarType;
    exports.isObjectType = isObjectType;
    exports.assertObjectType = assertObjectType;
    exports.isInterfaceType = isInterfaceType;
    exports.assertInterfaceType = assertInterfaceType;
    exports.isUnionType = isUnionType;
    exports.assertUnionType = assertUnionType;
    exports.isEnumType = isEnumType;
    exports.assertEnumType = assertEnumType;
    exports.isInputObjectType = isInputObjectType;
    exports.assertInputObjectType = assertInputObjectType;
    exports.isListType = isListType;
    exports.assertListType = assertListType;
    exports.isNonNullType = isNonNullType;
    exports.assertNonNullType = assertNonNullType;
    exports.isInputType = isInputType;
    exports.assertInputType = assertInputType;
    exports.isOutputType = isOutputType;
    exports.assertOutputType = assertOutputType;
    exports.isLeafType = isLeafType;
    exports.assertLeafType = assertLeafType;
    exports.isCompositeType = isCompositeType;
    exports.assertCompositeType = assertCompositeType;
    exports.isAbstractType = isAbstractType;
    exports.assertAbstractType = assertAbstractType;
    exports.GraphQLList = GraphQLList;
    exports.GraphQLNonNull = GraphQLNonNull;
    exports.isWrappingType = isWrappingType;
    exports.assertWrappingType = assertWrappingType;
    exports.isNullableType = isNullableType;
    exports.assertNullableType = assertNullableType;
    exports.getNullableType = getNullableType;
    exports.isNamedType = isNamedType;
    exports.assertNamedType = assertNamedType;
    exports.getNamedType = getNamedType;
    exports.argsToArgsConfig = argsToArgsConfig;
    exports.isRequiredArgument = isRequiredArgument;
    exports.isRequiredInputField = isRequiredInputField;
    exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = void 0;
    var _objectEntries = _interopRequireDefault(require_objectEntries());
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _mapValue = _interopRequireDefault(require_mapValue());
    var _toObjMap = _interopRequireDefault(require_toObjMap());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _identityFunc = _interopRequireDefault(require_identityFunc());
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
    }
    function assertType(type) {
      if (!isType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL type."));
      }
      return type;
    }
    function isScalarType(type) {
      return (0, _instanceOf.default)(type, GraphQLScalarType);
    }
    function assertScalarType(type) {
      if (!isScalarType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Scalar type."));
      }
      return type;
    }
    function isObjectType(type) {
      return (0, _instanceOf.default)(type, GraphQLObjectType);
    }
    function assertObjectType(type) {
      if (!isObjectType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Object type."));
      }
      return type;
    }
    function isInterfaceType(type) {
      return (0, _instanceOf.default)(type, GraphQLInterfaceType);
    }
    function assertInterfaceType(type) {
      if (!isInterfaceType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Interface type."));
      }
      return type;
    }
    function isUnionType(type) {
      return (0, _instanceOf.default)(type, GraphQLUnionType);
    }
    function assertUnionType(type) {
      if (!isUnionType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Union type."));
      }
      return type;
    }
    function isEnumType(type) {
      return (0, _instanceOf.default)(type, GraphQLEnumType);
    }
    function assertEnumType(type) {
      if (!isEnumType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Enum type."));
      }
      return type;
    }
    function isInputObjectType(type) {
      return (0, _instanceOf.default)(type, GraphQLInputObjectType);
    }
    function assertInputObjectType(type) {
      if (!isInputObjectType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Input Object type."));
      }
      return type;
    }
    function isListType(type) {
      return (0, _instanceOf.default)(type, GraphQLList);
    }
    function assertListType(type) {
      if (!isListType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL List type."));
      }
      return type;
    }
    function isNonNullType(type) {
      return (0, _instanceOf.default)(type, GraphQLNonNull);
    }
    function assertNonNullType(type) {
      if (!isNonNullType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL Non-Null type."));
      }
      return type;
    }
    function isInputType(type) {
      return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
    }
    function assertInputType(type) {
      if (!isInputType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL input type."));
      }
      return type;
    }
    function isOutputType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
    }
    function assertOutputType(type) {
      if (!isOutputType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL output type."));
      }
      return type;
    }
    function isLeafType(type) {
      return isScalarType(type) || isEnumType(type);
    }
    function assertLeafType(type) {
      if (!isLeafType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL leaf type."));
      }
      return type;
    }
    function isCompositeType(type) {
      return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
    }
    function assertCompositeType(type) {
      if (!isCompositeType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL composite type."));
      }
      return type;
    }
    function isAbstractType(type) {
      return isInterfaceType(type) || isUnionType(type);
    }
    function assertAbstractType(type) {
      if (!isAbstractType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL abstract type."));
      }
      return type;
    }
    function GraphQLList(ofType) {
      if (this instanceof GraphQLList) {
        this.ofType = assertType(ofType);
      } else {
        return new GraphQLList(ofType);
      }
    }
    GraphQLList.prototype.toString = function toString() {
      return "[" + String(this.ofType) + "]";
    };
    GraphQLList.prototype.toJSON = function toJSON() {
      return this.toString();
    };
    Object.defineProperty(GraphQLList.prototype, _symbols.SYMBOL_TO_STRING_TAG, {
      get: function get() {
        return "GraphQLList";
      }
    });
    (0, _defineInspect.default)(GraphQLList);
    function GraphQLNonNull(ofType) {
      if (this instanceof GraphQLNonNull) {
        this.ofType = assertNullableType(ofType);
      } else {
        return new GraphQLNonNull(ofType);
      }
    }
    GraphQLNonNull.prototype.toString = function toString() {
      return String(this.ofType) + "!";
    };
    GraphQLNonNull.prototype.toJSON = function toJSON() {
      return this.toString();
    };
    Object.defineProperty(GraphQLNonNull.prototype, _symbols.SYMBOL_TO_STRING_TAG, {
      get: function get() {
        return "GraphQLNonNull";
      }
    });
    (0, _defineInspect.default)(GraphQLNonNull);
    function isWrappingType(type) {
      return isListType(type) || isNonNullType(type);
    }
    function assertWrappingType(type) {
      if (!isWrappingType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL wrapping type."));
      }
      return type;
    }
    function isNullableType(type) {
      return isType(type) && !isNonNullType(type);
    }
    function assertNullableType(type) {
      if (!isNullableType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL nullable type."));
      }
      return type;
    }
    function getNullableType(type) {
      if (type) {
        return isNonNullType(type) ? type.ofType : type;
      }
    }
    function isNamedType(type) {
      return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
    }
    function assertNamedType(type) {
      if (!isNamedType(type)) {
        throw new Error("Expected ".concat((0, _inspect.default)(type), " to be a GraphQL named type."));
      }
      return type;
    }
    function getNamedType(type) {
      if (type) {
        var unwrappedType = type;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    function resolveThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    function undefineIfEmpty(arr) {
      return arr && arr.length > 0 ? arr : void 0;
    }
    var GraphQLScalarType = /* @__PURE__ */ function() {
      function GraphQLScalarType2(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral;
        var parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.default;
        this.name = config.name;
        this.description = config.description;
        this.specifiedByUrl = config.specifiedByUrl;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.default;
        this.parseValue = parseValue;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : function(node, variables) {
          return parseValue((0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables));
        };
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.specifiedByUrl == null || typeof config.specifiedByUrl === "string" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "specifiedByUrl" as a string, ') + "but got: ".concat((0, _inspect.default)(config.specifiedByUrl), "."));
        config.serialize == null || typeof config.serialize === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.'));
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide both "parseValue" and "parseLiteral" functions.'));
        }
      }
      var _proto = GraphQLScalarType2.prototype;
      _proto.toConfig = function toConfig() {
        var _this$extensionASTNod;
        return {
          name: this.name,
          description: this.description,
          specifiedByUrl: this.specifiedByUrl,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : []
        };
      };
      _proto.toString = function toString() {
        return this.name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLScalarType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLScalarType";
        }
      }]);
      return GraphQLScalarType2;
    }();
    exports.GraphQLScalarType = GraphQLScalarType;
    (0, _defineInspect.default)(GraphQLScalarType);
    var GraphQLObjectType = /* @__PURE__ */ function() {
      function GraphQLObjectType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.isTypeOf == null || typeof config.isTypeOf === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "isTypeOf" as a function, ') + "but got: ".concat((0, _inspect.default)(config.isTypeOf), "."));
      }
      var _proto2 = GraphQLObjectType2.prototype;
      _proto2.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto2.getInterfaces = function getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      };
      _proto2.toConfig = function toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes || []
        };
      };
      _proto2.toString = function toString() {
        return this.name;
      };
      _proto2.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLObjectType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLObjectType";
        }
      }]);
      return GraphQLObjectType2;
    }();
    exports.GraphQLObjectType = GraphQLObjectType;
    (0, _defineInspect.default)(GraphQLObjectType);
    function defineInterfaces(config) {
      var _resolveThunk;
      var interfaces = (_resolveThunk = resolveThunk(config.interfaces)) !== null && _resolveThunk !== void 0 ? _resolveThunk : [];
      Array.isArray(interfaces) || (0, _devAssert.default)(0, "".concat(config.name, " interfaces must be an Array or a function which returns an Array."));
      return interfaces;
    }
    function defineFieldMap(config) {
      var fieldMap = resolveThunk(config.fields);
      isPlainObj(fieldMap) || (0, _devAssert.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
      return (0, _mapValue.default)(fieldMap, function(fieldConfig, fieldName) {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object."));
        !("isDeprecated" in fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, ' should provide "deprecationReason" instead of "isDeprecated".'));
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat((0, _inspect.default)(fieldConfig.resolve), "."));
        var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
        var args = (0, _objectEntries.default)(argsConfig).map(function(_ref) {
          var argName = _ref[0], argConfig = _ref[1];
          return {
            name: argName,
            description: argConfig.description,
            type: argConfig.type,
            defaultValue: argConfig.defaultValue,
            deprecationReason: argConfig.deprecationReason,
            extensions: argConfig.extensions && (0, _toObjMap.default)(argConfig.extensions),
            astNode: argConfig.astNode
          };
        });
        return {
          name: fieldName,
          description: fieldConfig.description,
          type: fieldConfig.type,
          args,
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          isDeprecated: fieldConfig.deprecationReason != null,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: fieldConfig.extensions && (0, _toObjMap.default)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function isPlainObj(obj) {
      return (0, _isObjectLike.default)(obj) && !Array.isArray(obj);
    }
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.default)(fields, function(field) {
        return {
          description: field.description,
          type: field.type,
          args: argsToArgsConfig(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        };
      });
    }
    function argsToArgsConfig(args) {
      return (0, _keyValMap.default)(args, function(arg) {
        return arg.name;
      }, function(arg) {
        return {
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        };
      });
    }
    function isRequiredArgument(arg) {
      return isNonNullType(arg.type) && arg.defaultValue === void 0;
    }
    var GraphQLInterfaceType = /* @__PURE__ */ function() {
      function GraphQLInterfaceType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat((0, _inspect.default)(config.resolveType), "."));
      }
      var _proto3 = GraphQLInterfaceType2.prototype;
      _proto3.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto3.getInterfaces = function getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      };
      _proto3.toConfig = function toConfig() {
        var _this$extensionASTNod2;
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== void 0 ? _this$extensionASTNod2 : []
        };
      };
      _proto3.toString = function toString() {
        return this.name;
      };
      _proto3.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLInterfaceType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLInterfaceType";
        }
      }]);
      return GraphQLInterfaceType2;
    }();
    exports.GraphQLInterfaceType = GraphQLInterfaceType;
    (0, _defineInspect.default)(GraphQLInterfaceType);
    var GraphQLUnionType = /* @__PURE__ */ function() {
      function GraphQLUnionType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._types = defineTypes.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
        config.resolveType == null || typeof config.resolveType === "function" || (0, _devAssert.default)(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat((0, _inspect.default)(config.resolveType), "."));
      }
      var _proto4 = GraphQLUnionType2.prototype;
      _proto4.getTypes = function getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      };
      _proto4.toConfig = function toConfig() {
        var _this$extensionASTNod3;
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== void 0 ? _this$extensionASTNod3 : []
        };
      };
      _proto4.toString = function toString() {
        return this.name;
      };
      _proto4.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLUnionType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLUnionType";
        }
      }]);
      return GraphQLUnionType2;
    }();
    exports.GraphQLUnionType = GraphQLUnionType;
    (0, _defineInspect.default)(GraphQLUnionType);
    function defineTypes(config) {
      var types2 = resolveThunk(config.types);
      Array.isArray(types2) || (0, _devAssert.default)(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config.name, "."));
      return types2;
    }
    var GraphQLEnumType = /* @__PURE__ */ function() {
      function GraphQLEnumType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(this._values.map(function(enumValue) {
          return [enumValue.value, enumValue];
        }));
        this._nameLookup = (0, _keyMap.default)(this._values, function(value) {
          return value.name;
        });
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      }
      var _proto5 = GraphQLEnumType2.prototype;
      _proto5.getValues = function getValues() {
        return this._values;
      };
      _proto5.getValue = function getValue(name) {
        return this._nameLookup[name];
      };
      _proto5.serialize = function serialize(outputValue) {
        var enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent value: ').concat((0, _inspect.default)(outputValue)));
        }
        return enumValue.name;
      };
      _proto5.parseValue = function parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          var valueStr = (0, _inspect.default)(inputValue);
          throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent non-string value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr));
        }
        var enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError('Value "'.concat(inputValue, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, inputValue));
        }
        return enumValue.value;
      };
      _proto5.parseLiteral = function parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          var valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError('Enum "'.concat(this.name, '" cannot represent non-enum value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr), valueNode);
        }
        var enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          var _valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError('Value "'.concat(_valueStr, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, _valueStr), valueNode);
        }
        return enumValue.value;
      };
      _proto5.toConfig = function toConfig() {
        var _this$extensionASTNod4;
        var values = (0, _keyValMap.default)(this.getValues(), function(value) {
          return value.name;
        }, function(value) {
          return {
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          };
        });
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== void 0 ? _this$extensionASTNod4 : []
        };
      };
      _proto5.toString = function toString() {
        return this.name;
      };
      _proto5.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLEnumType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLEnumType";
        }
      }]);
      return GraphQLEnumType2;
    }();
    exports.GraphQLEnumType = GraphQLEnumType;
    (0, _defineInspect.default)(GraphQLEnumType);
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      var allNames = enumType.getValues().map(function(value) {
        return value.name;
      });
      var suggestedValues = (0, _suggestionList.default)(unknownValueStr, allNames);
      return (0, _didYouMean.default)("the enum value", suggestedValues);
    }
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.default)(0, "".concat(typeName, " values must be an object with value names as keys."));
      return (0, _objectEntries.default)(valueMap).map(function(_ref2) {
        var valueName = _ref2[0], valueConfig = _ref2[1];
        isPlainObj(valueConfig) || (0, _devAssert.default)(0, "".concat(typeName, ".").concat(valueName, ' must refer to an object with a "value" key ') + "representing an internal value but got: ".concat((0, _inspect.default)(valueConfig), "."));
        !("isDeprecated" in valueConfig) || (0, _devAssert.default)(0, "".concat(typeName, ".").concat(valueName, ' should provide "deprecationReason" instead of "isDeprecated".'));
        return {
          name: valueName,
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          isDeprecated: valueConfig.deprecationReason != null,
          deprecationReason: valueConfig.deprecationReason,
          extensions: valueConfig.extensions && (0, _toObjMap.default)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    var GraphQLInputObjectType = /* @__PURE__ */ function() {
      function GraphQLInputObjectType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineInputFieldMap.bind(void 0, config);
        typeof config.name === "string" || (0, _devAssert.default)(0, "Must provide name.");
      }
      var _proto6 = GraphQLInputObjectType2.prototype;
      _proto6.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto6.toConfig = function toConfig() {
        var _this$extensionASTNod5;
        var fields = (0, _mapValue.default)(this.getFields(), function(field) {
          return {
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          };
        });
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== void 0 ? _this$extensionASTNod5 : []
        };
      };
      _proto6.toString = function toString() {
        return this.name;
      };
      _proto6.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLInputObjectType2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLInputObjectType";
        }
      }]);
      return GraphQLInputObjectType2;
    }();
    exports.GraphQLInputObjectType = GraphQLInputObjectType;
    (0, _defineInspect.default)(GraphQLInputObjectType);
    function defineInputFieldMap(config) {
      var fieldMap = resolveThunk(config.fields);
      isPlainObj(fieldMap) || (0, _devAssert.default)(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
      return (0, _mapValue.default)(fieldMap, function(fieldConfig, fieldName) {
        !("resolve" in fieldConfig) || (0, _devAssert.default)(0, "".concat(config.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
        return {
          name: fieldName,
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: fieldConfig.extensions && (0, _toObjMap.default)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    function isRequiredInputField(field) {
      return isNonNullType(field.type) && field.defaultValue === void 0;
    }
  }
});

// node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "node_modules/graphql/utilities/typeComparators.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isEqualType = isEqualType;
    exports.isTypeSubTypeOf = isTypeSubTypeOf;
    exports.doTypesOverlap = doTypesOverlap;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
    }
    function doTypesOverlap(schema, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.getPossibleTypes(typeA).some(function(type) {
            return schema.isSubType(typeB, type);
          });
        }
        return schema.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.isSubType(typeB, typeA);
      }
      return false;
    }
  }
});

// node_modules/graphql/polyfills/arrayFrom.js
var require_arrayFrom = __commonJS({
  "node_modules/graphql/polyfills/arrayFrom.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _symbols = require_symbols();
    var arrayFrom = Array.from || function(obj, mapFn, thisArg) {
      if (obj == null) {
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      }
      var iteratorMethod = obj[_symbols.SYMBOL_ITERATOR];
      if (typeof iteratorMethod === "function") {
        var iterator = iteratorMethod.call(obj);
        var result = [];
        var step;
        for (var i = 0; !(step = iterator.next()).done; ++i) {
          result.push(mapFn.call(thisArg, step.value, i));
          if (i > 9999999) {
            throw new TypeError("Near-infinite iteration.");
          }
        }
        return result;
      }
      var length = obj.length;
      if (typeof length === "number" && length >= 0 && length % 1 === 0) {
        var _result = [];
        for (var _i = 0; _i < length; ++_i) {
          if (Object.prototype.hasOwnProperty.call(obj, _i)) {
            _result.push(mapFn.call(thisArg, obj[_i], _i));
          }
        }
        return _result;
      }
      return [];
    };
    var _default = arrayFrom;
    exports.default = _default;
  }
});

// node_modules/graphql/polyfills/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/graphql/polyfills/isFinite.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var isFinitePolyfill = Number.isFinite || function(value) {
      return typeof value === "number" && isFinite(value);
    };
    var _default = isFinitePolyfill;
    exports.default = _default;
  }
});

// node_modules/graphql/jsutils/safeArrayFrom.js
var require_safeArrayFrom = __commonJS({
  "node_modules/graphql/jsutils/safeArrayFrom.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = safeArrayFrom;
    var _symbols = require_symbols();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function safeArrayFrom(collection) {
      var mapFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(item) {
        return item;
      };
      if (collection == null || _typeof(collection) !== "object") {
        return null;
      }
      if (Array.isArray(collection)) {
        return collection.map(mapFn);
      }
      var iteratorMethod = collection[_symbols.SYMBOL_ITERATOR];
      if (typeof iteratorMethod === "function") {
        var iterator = iteratorMethod.call(collection);
        var result = [];
        var step;
        for (var i = 0; !(step = iterator.next()).done; ++i) {
          result.push(mapFn(step.value, i));
        }
        return result;
      }
      var length = collection.length;
      if (typeof length === "number" && length >= 0 && length % 1 === 0) {
        var _result = [];
        for (var _i = 0; _i < length; ++_i) {
          if (!Object.prototype.hasOwnProperty.call(collection, _i)) {
            return null;
          }
          _result.push(mapFn(collection[String(_i)], _i));
        }
        return _result;
      }
      return null;
    }
  }
});

// node_modules/graphql/polyfills/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/graphql/polyfills/isInteger.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var isInteger = Number.isInteger || function(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    var _default = isInteger;
    exports.default = _default;
  }
});

// node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "node_modules/graphql/type/scalars.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSpecifiedScalarType = isSpecifiedScalarType;
    exports.specifiedScalarTypes = exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = void 0;
    var _isFinite = _interopRequireDefault(require_isFinite());
    var _isInteger = _interopRequireDefault(require_isInteger());
    var _inspect = _interopRequireDefault(require_inspect());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX_INT = 2147483647;
    var MIN_INT = -2147483648;
    function serializeInt(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      var num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (!(0, _isInteger.default)(num)) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(coercedValue)));
      }
      if (num > MAX_INT || num < MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, _inspect.default)(coercedValue));
      }
      return num;
    }
    function coerceInt(inputValue) {
      if (!(0, _isInteger.default)(inputValue)) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _inspect.default)(inputValue)));
      }
      if (inputValue > MAX_INT || inputValue < MIN_INT) {
        throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(inputValue));
      }
      return inputValue;
    }
    var GraphQLInt = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize: serializeInt,
      parseValue: coerceInt,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("Int cannot represent non-integer value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        var num = parseInt(valueNode.value, 10);
        if (num > MAX_INT || num < MIN_INT) {
          throw new _GraphQLError.GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(valueNode.value), valueNode);
        }
        return num;
      }
    });
    exports.GraphQLInt = GraphQLInt;
    function serializeFloat(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue ? 1 : 0;
      }
      var num = coercedValue;
      if (typeof coercedValue === "string" && coercedValue !== "") {
        num = Number(coercedValue);
      }
      if (!(0, _isFinite.default)(num)) {
        throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(coercedValue)));
      }
      return num;
    }
    function coerceFloat(inputValue) {
      if (!(0, _isFinite.default)(inputValue)) {
        throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _inspect.default)(inputValue)));
      }
      return inputValue;
    }
    var GraphQLFloat = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize: serializeFloat,
      parseValue: coerceFloat,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("Float cannot represent non numeric value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        return parseFloat(valueNode.value);
      }
    });
    exports.GraphQLFloat = GraphQLFloat;
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.default)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          var valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.default)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
    function serializeString(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if (typeof coercedValue === "boolean") {
        return coercedValue ? "true" : "false";
      }
      if ((0, _isFinite.default)(coercedValue)) {
        return coercedValue.toString();
      }
      throw new _GraphQLError.GraphQLError("String cannot represent value: ".concat((0, _inspect.default)(outputValue)));
    }
    function coerceString(inputValue) {
      if (typeof inputValue !== "string") {
        throw new _GraphQLError.GraphQLError("String cannot represent a non string value: ".concat((0, _inspect.default)(inputValue)));
      }
      return inputValue;
    }
    var GraphQLString = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize: serializeString,
      parseValue: coerceString,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError("String cannot represent a non string value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        return valueNode.value;
      }
    });
    exports.GraphQLString = GraphQLString;
    function serializeBoolean(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "boolean") {
        return coercedValue;
      }
      if ((0, _isFinite.default)(coercedValue)) {
        return coercedValue !== 0;
      }
      throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(coercedValue)));
    }
    function coerceBoolean(inputValue) {
      if (typeof inputValue !== "boolean") {
        throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _inspect.default)(inputValue)));
      }
      return inputValue;
    }
    var GraphQLBoolean = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize: serializeBoolean,
      parseValue: coerceBoolean,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError("Boolean cannot represent a non boolean value: ".concat((0, _printer.print)(valueNode)), valueNode);
        }
        return valueNode.value;
      }
    });
    exports.GraphQLBoolean = GraphQLBoolean;
    function serializeID(outputValue) {
      var coercedValue = serializeObject(outputValue);
      if (typeof coercedValue === "string") {
        return coercedValue;
      }
      if ((0, _isInteger.default)(coercedValue)) {
        return String(coercedValue);
      }
      throw new _GraphQLError.GraphQLError("ID cannot represent value: ".concat((0, _inspect.default)(outputValue)));
    }
    function coerceID(inputValue) {
      if (typeof inputValue === "string") {
        return inputValue;
      }
      if ((0, _isInteger.default)(inputValue)) {
        return inputValue.toString();
      }
      throw new _GraphQLError.GraphQLError("ID cannot represent value: ".concat((0, _inspect.default)(inputValue)));
    }
    var GraphQLID = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize: serializeID,
      parseValue: coerceID,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode), valueNode);
        }
        return valueNode.value;
      }
    });
    exports.GraphQLID = GraphQLID;
    var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);
    exports.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType(type) {
      return specifiedScalarTypes.some(function(_ref) {
        var name = _ref.name;
        return type.name === name;
      });
    }
  }
});

// node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "node_modules/graphql/utilities/astFromValue.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.astFromValue = astFromValue;
    var _isFinite = _interopRequireDefault(require_isFinite());
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
    var _kinds = require_kinds();
    var _scalars = require_scalars();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function astFromValue(value, type) {
      if ((0, _definition.isNonNullType)(type)) {
        var astValue = astFromValue(value, type.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        var itemType = type.ofType;
        var items = (0, _safeArrayFrom.default)(value);
        if (items != null) {
          var valuesNodes = [];
          for (var _i2 = 0; _i2 < items.length; _i2++) {
            var item = items[_i2];
            var itemNode = astFromValue(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.default)(value)) {
          return null;
        }
        var fieldNodes = [];
        for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {
          var field = _objectValues2[_i4];
          var fieldValue = astFromValue(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type)) {
        var serialized = type.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && (0, _isFinite.default)(serialized)) {
          var stringNum = String(serialized);
          return integerStringRegExp.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError("Cannot convert value to AST: ".concat((0, _inspect.default)(serialized), "."));
      }
      (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
    }
    var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "node_modules/graphql/type/introspection.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIntrospectionType = isIntrospectionType;
    exports.introspectionTypes = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = void 0;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _printer = require_printer();
    var _directiveLocation = require_directiveLocation();
    var _astFromValue = require_astFromValue();
    var _scalars = require_scalars();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: function fields() {
        return {
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(schema) {
              return schema.description;
            }
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))),
            resolve: function resolve2(schema) {
              return (0, _objectValues.default)(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type),
            resolve: function resolve2(schema) {
              return schema.getQueryType();
            }
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: function resolve2(schema) {
              return schema.getMutationType();
            }
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: function resolve2(schema) {
              return schema.getSubscriptionType();
            }
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__Directive))),
            resolve: function resolve2(schema) {
              return schema.getDirectives();
            }
          }
        };
      }
    });
    exports.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve2(directive) {
              return directive.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(directive) {
              return directive.description;
            }
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve2(directive) {
              return directive.isRepeatable;
            }
          },
          locations: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__DirectiveLocation))),
            resolve: function resolve2(directive) {
              return directive.locations;
            }
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve2(field, _ref) {
              var includeDeprecated = _ref.includeDeprecated;
              return includeDeprecated ? field.args : field.args.filter(function(arg) {
                return arg.deprecationReason == null;
              });
            }
          }
        };
      }
    });
    exports.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByUrl`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: function fields() {
        return {
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind),
            resolve: function resolve2(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind.NON_NULL;
              }
              (0, _invariant.default)(0, 'Unexpected type: "'.concat((0, _inspect.default)(type), '".'));
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(type) {
              return type.name !== void 0 ? type.name : void 0;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(type) {
              return type.description !== void 0 ? type.description : void 0;
            }
          },
          specifiedByUrl: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(obj) {
              return obj.specifiedByUrl !== void 0 ? obj.specifiedByUrl : void 0;
            }
          },
          fields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Field)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve2(type, _ref2) {
              var includeDeprecated = _ref2.includeDeprecated;
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                var fields2 = (0, _objectValues.default)(type.getFields());
                return includeDeprecated ? fields2 : fields2.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve: function resolve2(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
            resolve: function resolve2(type, _args, _context, _ref3) {
              var schema = _ref3.schema;
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__EnumValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve2(type, _ref4) {
              var includeDeprecated = _ref4.includeDeprecated;
              if ((0, _definition.isEnumType)(type)) {
                var values = type.getValues();
                return includeDeprecated ? values : values.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue)),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve2(type, _ref5) {
              var includeDeprecated = _ref5.includeDeprecated;
              if ((0, _definition.isInputObjectType)(type)) {
                var values = (0, _objectValues.default)(type.getFields());
                return includeDeprecated ? values : values.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: function resolve2(type) {
              return type.ofType !== void 0 ? type.ofType : void 0;
            }
          }
        };
      }
    });
    exports.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve2(field) {
              return field.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(field) {
              return field.description;
            }
          },
          args: {
            type: new _definition.GraphQLNonNull(new _definition.GraphQLList(new _definition.GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve2(field, _ref6) {
              var includeDeprecated = _ref6.includeDeprecated;
              return includeDeprecated ? field.args : field.args.filter(function(arg) {
                return arg.deprecationReason == null;
              });
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: function resolve2(field) {
              return field.type;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve2(field) {
              return field.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(field) {
              return field.deprecationReason;
            }
          }
        };
      }
    });
    exports.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve2(inputValue) {
              return inputValue.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(inputValue) {
              return inputValue.description;
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type),
            resolve: function resolve2(inputValue) {
              return inputValue.type;
            }
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve: function resolve2(inputValue) {
              var type = inputValue.type, defaultValue = inputValue.defaultValue;
              var valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve2(field) {
              return field.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(obj) {
              return obj.deprecationReason;
            }
          }
        };
      }
    });
    exports.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: function fields() {
        return {
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: function resolve2(enumValue) {
              return enumValue.name;
            }
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(enumValue) {
              return enumValue.description;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: function resolve2(enumValue) {
              return enumValue.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: function resolve2(enumValue) {
              return enumValue.deprecationReason;
            }
          }
        };
      }
    });
    exports.__EnumValue = __EnumValue;
    var TypeKind = Object.freeze({
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      INPUT_OBJECT: "INPUT_OBJECT",
      LIST: "LIST",
      NON_NULL: "NON_NULL"
    });
    exports.TypeKind = TypeKind;
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: function resolve2(_source, _args, _context, _ref7) {
        var schema = _ref7.schema;
        return schema;
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    exports.SchemaMetaFieldDef = SchemaMetaFieldDef;
    var TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [{
        name: "name",
        description: void 0,
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: void 0,
        astNode: void 0
      }],
      resolve: function resolve2(_source, _ref8, _context, _ref9) {
        var name = _ref8.name;
        var schema = _ref9.schema;
        return schema.getType(name);
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    exports.TypeMetaFieldDef = TypeMetaFieldDef;
    var TypeNameMetaFieldDef = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: function resolve2(_source, _args, _context, _ref10) {
        var parentType = _ref10.parentType;
        return parentType.name;
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    exports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
    var introspectionTypes = Object.freeze([__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind]);
    exports.introspectionTypes = introspectionTypes;
    function isIntrospectionType(type) {
      return introspectionTypes.some(function(_ref11) {
        var name = _ref11.name;
        return type.name === name;
      });
    }
  }
});

// node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "node_modules/graphql/type/directives.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDirective = isDirective;
    exports.assertDirective = assertDirective;
    exports.isSpecifiedDirective = isSpecifiedDirective;
    exports.specifiedDirectives = exports.GraphQLSpecifiedByDirective = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = void 0;
    var _objectEntries = _interopRequireDefault(require_objectEntries());
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _toObjMap = _interopRequireDefault(require_toObjMap());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    var _directiveLocation = require_directiveLocation();
    var _scalars = require_scalars();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isDirective(directive) {
      return (0, _instanceOf.default)(directive, GraphQLDirective);
    }
    function assertDirective(directive) {
      if (!isDirective(directive)) {
        throw new Error("Expected ".concat((0, _inspect.default)(directive), " to be a GraphQL directive."));
      }
      return directive;
    }
    var GraphQLDirective = /* @__PURE__ */ function() {
      function GraphQLDirective2(config) {
        var _config$isRepeatable, _config$args;
        this.name = config.name;
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        config.name || (0, _devAssert.default)(0, "Directive must be named.");
        Array.isArray(config.locations) || (0, _devAssert.default)(0, "@".concat(config.name, " locations must be an Array."));
        var args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.default)(args) && !Array.isArray(args) || (0, _devAssert.default)(0, "@".concat(config.name, " args must be an object with argument names as keys."));
        this.args = (0, _objectEntries.default)(args).map(function(_ref) {
          var argName = _ref[0], argConfig = _ref[1];
          return {
            name: argName,
            description: argConfig.description,
            type: argConfig.type,
            defaultValue: argConfig.defaultValue,
            deprecationReason: argConfig.deprecationReason,
            extensions: argConfig.extensions && (0, _toObjMap.default)(argConfig.extensions),
            astNode: argConfig.astNode
          };
        });
      }
      var _proto = GraphQLDirective2.prototype;
      _proto.toConfig = function toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      };
      _proto.toString = function toString() {
        return "@" + this.name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _createClass(GraphQLDirective2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLDirective";
        }
      }]);
      return GraphQLDirective2;
    }();
    exports.GraphQLDirective = GraphQLDirective;
    (0, _defineInspect.default)(GraphQLDirective);
    var GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports.GraphQLIncludeDirective = GraphQLIncludeDirective;
    var GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports.GraphQLSkipDirective = GraphQLSkipDirective;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [_directiveLocation.DirectiveLocation.FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION, _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ENUM_VALUE],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;
    var GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behaviour of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behaviour of this scalar."
        }
      }
    });
    exports.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective]);
    exports.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective(directive) {
      return specifiedDirectives.some(function(_ref2) {
        var name = _ref2.name;
        return name === directive.name;
      });
    }
  }
});

// node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "node_modules/graphql/type/schema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSchema = isSchema;
    exports.assertSchema = assertSchema;
    exports.GraphQLSchema = void 0;
    var _find = _interopRequireDefault(require_find());
    var _arrayFrom3 = _interopRequireDefault(require_arrayFrom());
    var _objectValues5 = _interopRequireDefault(require_objectValues());
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _toObjMap = _interopRequireDefault(require_toObjMap());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function isSchema(schema) {
      return (0, _instanceOf.default)(schema, GraphQLSchema);
    }
    function assertSchema(schema) {
      if (!isSchema(schema)) {
        throw new Error("Expected ".concat((0, _inspect.default)(schema), " to be a GraphQL schema."));
      }
      return schema;
    }
    var GraphQLSchema = /* @__PURE__ */ function() {
      function GraphQLSchema2(config) {
        var _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.default)(config) || (0, _devAssert.default)(0, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || (0, _devAssert.default)(0, '"types" must be Array if provided but got: '.concat((0, _inspect.default)(config.types), "."));
        !config.directives || Array.isArray(config.directives) || (0, _devAssert.default)(0, '"directives" must be Array if provided but got: ' + "".concat((0, _inspect.default)(config.directives), "."));
        this.description = config.description;
        this.extensions = config.extensions && (0, _toObjMap.default)(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = config.extensionASTNodes;
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        var allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {
            var type = _config$types2[_i2];
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {
          var directive = _this$_directives2[_i4];
          if ((0, _directives.isDirective)(directive)) {
            for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
              var arg = _directive$args2[_i6];
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = Object.create(null);
        this._subTypeMap = Object.create(null);
        this._implementationsMap = Object.create(null);
        for (var _i8 = 0, _arrayFrom2 = (0, _arrayFrom3.default)(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {
          var namedType = _arrayFrom2[_i8];
          if (namedType == null) {
            continue;
          }
          var typeName = namedType.name;
          typeName || (0, _devAssert.default)(0, "One of the provided types for building the Schema is missing a name.");
          if (this._typeMap[typeName] !== void 0) {
            throw new Error('Schema must contain uniquely named types but contains multiple types named "'.concat(typeName, '".'));
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {
              var iface = _namedType$getInterfa2[_i10];
              if ((0, _definition.isInterfaceType)(iface)) {
                var implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {
              var _iface = _namedType$getInterfa4[_i12];
              if ((0, _definition.isInterfaceType)(_iface)) {
                var _implementations = this._implementationsMap[_iface.name];
                if (_implementations === void 0) {
                  _implementations = this._implementationsMap[_iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                _implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      var _proto = GraphQLSchema2.prototype;
      _proto.getQueryType = function getQueryType() {
        return this._queryType;
      };
      _proto.getMutationType = function getMutationType() {
        return this._mutationType;
      };
      _proto.getSubscriptionType = function getSubscriptionType() {
        return this._subscriptionType;
      };
      _proto.getTypeMap = function getTypeMap() {
        return this._typeMap;
      };
      _proto.getType = function getType2(name) {
        return this.getTypeMap()[name];
      };
      _proto.getPossibleTypes = function getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      };
      _proto.getImplementations = function getImplementations(interfaceType) {
        var implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      };
      _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {
        return this.isSubType(abstractType, possibleType);
      };
      _proto.isSubType = function isSubType(abstractType, maybeSubType) {
        var map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {
              var type = _abstractType$getType2[_i14];
              map[type.name] = true;
            }
          } else {
            var implementations = this.getImplementations(abstractType);
            for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {
              var _type = _implementations$obje2[_i16];
              map[_type.name] = true;
            }
            for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {
              var _type2 = _implementations$inte2[_i18];
              map[_type2.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      };
      _proto.getDirectives = function getDirectives() {
        return this._directives;
      };
      _proto.getDirective = function getDirective(name) {
        return (0, _find.default)(this.getDirectives(), function(directive) {
          return directive.name === name;
        });
      };
      _proto.toConfig = function toConfig() {
        var _this$extensionASTNod;
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: (0, _objectValues5.default)(this.getTypeMap()),
          directives: this.getDirectives().slice(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],
          assumeValid: this.__validationErrors !== void 0
        };
      };
      _createClass(GraphQLSchema2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get() {
          return "GraphQLSchema";
        }
      }]);
      return GraphQLSchema2;
    }();
    exports.GraphQLSchema = GraphQLSchema;
    function collectReferencedTypes(type, typeSet) {
      var namedType = (0, _definition.getNamedType)(type);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {
            var memberType = _namedType$getTypes2[_i20];
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {
            var interfaceType = _namedType$getInterfa6[_i22];
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (var _i24 = 0, _objectValues2 = (0, _objectValues5.default)(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {
            var field = _objectValues2[_i24];
            collectReferencedTypes(field.type, typeSet);
            for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {
              var arg = _field$args2[_i26];
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (var _i28 = 0, _objectValues4 = (0, _objectValues5.default)(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {
            var _field = _objectValues4[_i28];
            collectReferencedTypes(_field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
  }
});

// node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "node_modules/graphql/type/validate.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validateSchema = validateSchema;
    exports.assertValidSchema = assertValidSchema;
    var _find = _interopRequireDefault(require_find());
    var _objectValues5 = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _assertValidName = require_assertValidName();
    var _typeComparators = require_typeComparators();
    var _schema = require_schema();
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validateSchema(schema) {
      (0, _schema.assertSchema)(schema);
      if (schema.__validationErrors) {
        return schema.__validationErrors;
      }
      var context = new SchemaValidationContext(schema);
      validateRootTypes(context);
      validateDirectives(context);
      validateTypes(context);
      var errors = context.getErrors();
      schema.__validationErrors = errors;
      return errors;
    }
    function assertValidSchema(schema) {
      var errors = validateSchema(schema);
      if (errors.length !== 0) {
        throw new Error(errors.map(function(error3) {
          return error3.message;
        }).join("\n\n"));
      }
    }
    var SchemaValidationContext = /* @__PURE__ */ function() {
      function SchemaValidationContext2(schema) {
        this._errors = [];
        this.schema = schema;
      }
      var _proto = SchemaValidationContext2.prototype;
      _proto.reportError = function reportError(message, nodes) {
        var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this.addError(new _GraphQLError.GraphQLError(message, _nodes));
      };
      _proto.addError = function addError(error3) {
        this._errors.push(error3);
      };
      _proto.getErrors = function getErrors() {
        return this._errors;
      };
      return SchemaValidationContext2;
    }();
    function validateRootTypes(context) {
      var schema = context.schema;
      var queryType = schema.getQueryType();
      if (!queryType) {
        context.reportError("Query root type must be provided.", schema.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context.reportError("Query root type must be Object type, it cannot be ".concat((0, _inspect.default)(queryType), "."), (_getOperationTypeNode = getOperationTypeNode(schema, "query")) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
      }
      var mutationType = schema.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context.reportError("Mutation root type must be Object type if provided, it cannot be " + "".concat((0, _inspect.default)(mutationType), "."), (_getOperationTypeNode2 = getOperationTypeNode(schema, "mutation")) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
      }
      var subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context.reportError("Subscription root type must be Object type if provided, it cannot be " + "".concat((0, _inspect.default)(subscriptionType), "."), (_getOperationTypeNode3 = getOperationTypeNode(schema, "subscription")) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
      }
    }
    function getOperationTypeNode(schema, operation) {
      var operationNodes = getAllSubNodes(schema, function(node2) {
        return node2.operationTypes;
      });
      for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {
        var node = operationNodes[_i2];
        if (node.operation === operation) {
          return node.type;
        }
      }
      return void 0;
    }
    function validateDirectives(context) {
      for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {
        var directive = _context$schema$getDi2[_i4];
        if (!(0, _directives.isDirective)(directive)) {
          context.reportError("Expected directive but got: ".concat((0, _inspect.default)(directive), "."), directive === null || directive === void 0 ? void 0 : directive.astNode);
          continue;
        }
        validateName(context, directive);
        for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
          var arg = _directive$args2[_i6];
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context.reportError("The type of @".concat(directive.name, "(").concat(arg.name, ":) must be Input Type ") + "but got: ".concat((0, _inspect.default)(arg.type), "."), arg.astNode);
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context.reportError("Required argument @".concat(directive.name, "(").concat(arg.name, ":) cannot be deprecated."), [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
            ]);
          }
        }
      }
    }
    function validateName(context, node) {
      var error3 = (0, _assertValidName.isValidNameError)(node.name);
      if (error3) {
        context.addError((0, _locatedError.locatedError)(error3, node.astNode));
      }
    }
    function validateTypes(context) {
      var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
      var typeMap = context.schema.getTypeMap();
      for (var _i8 = 0, _objectValues2 = (0, _objectValues5.default)(typeMap); _i8 < _objectValues2.length; _i8++) {
        var type = _objectValues2[_i8];
        if (!(0, _definition.isNamedType)(type)) {
          context.reportError("Expected GraphQL named type but got: ".concat((0, _inspect.default)(type), "."), type.astNode);
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type)) {
          validateName(context, type);
        }
        if ((0, _definition.isObjectType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isInterfaceType)(type)) {
          validateFields(context, type);
          validateInterfaces(context, type);
        } else if ((0, _definition.isUnionType)(type)) {
          validateUnionMembers(context, type);
        } else if ((0, _definition.isEnumType)(type)) {
          validateEnumValues(context, type);
        } else if ((0, _definition.isInputObjectType)(type)) {
          validateInputFields(context, type);
          validateInputObjectCircularRefs(type);
        }
      }
    }
    function validateFields(context, type) {
      var fields = (0, _objectValues5.default)(type.getFields());
      if (fields.length === 0) {
        context.reportError("Type ".concat(type.name, " must define one or more fields."), getAllNodes(type));
      }
      for (var _i10 = 0; _i10 < fields.length; _i10++) {
        var field = fields[_i10];
        validateName(context, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
        }
        for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {
          var arg = _field$args2[_i12];
          var argName = arg.name;
          validateName(context, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat((0, _inspect.default)(arg.type), "."), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context.reportError("Required argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) cannot be deprecated."), [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
            ]);
          }
        }
      }
    }
    function validateInterfaces(context, type) {
      var ifaceTypeNames = Object.create(null);
      for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {
        var iface = _type$getInterfaces2[_i14];
        if (!(0, _definition.isInterfaceType)(iface)) {
          context.reportError("Type ".concat((0, _inspect.default)(type), " must only implement Interface types, ") + "it cannot implement ".concat((0, _inspect.default)(iface), "."), getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        if (type === iface) {
          context.reportError("Type ".concat(type.name, " cannot implement itself because it would create a circular reference."), getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context.reportError("Type ".concat(type.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(type, iface));
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context, type, iface);
        validateTypeImplementsInterface(context, type, iface);
      }
    }
    function validateTypeImplementsInterface(context, type, iface) {
      var typeFieldMap = type.getFields();
      for (var _i16 = 0, _objectValues4 = (0, _objectValues5.default)(iface.getFields()); _i16 < _objectValues4.length; _i16++) {
        var ifaceField = _objectValues4[_i16];
        var fieldName = ifaceField.name;
        var typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ").concat(type.name, " does not provide it."), [ifaceField.astNode].concat(getAllNodes(type)));
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {
          var _ifaceField$astNode, _typeField$astNode;
          context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expects type ") + "".concat((0, _inspect.default)(ifaceField.type), " but ").concat(type.name, ".").concat(fieldName, " ") + "is type ".concat((0, _inspect.default)(typeField.type), "."), [
            (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
            (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
          ]);
        }
        var _loop = function _loop3(_i182, _ifaceField$args22) {
          var ifaceArg = _ifaceField$args22[_i182];
          var argName = ifaceArg.name;
          var typeArg = (0, _find.default)(typeField.args, function(arg) {
            return arg.name === argName;
          });
          if (!typeArg) {
            context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) expected but ").concat(type.name, ".").concat(fieldName, " does not provide it."), [ifaceArg.astNode, typeField.astNode]);
            return "continue";
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat((0, _inspect.default)(ifaceArg.type), " but ") + "".concat(type.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat((0, _inspect.default)(typeArg.type), "."), [
              (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
              (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
            ]);
          }
        };
        for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {
          var _ret = _loop(_i18, _ifaceField$args2);
          if (_ret === "continue")
            continue;
        }
        var _loop2 = function _loop22(_i202, _typeField$args22) {
          var typeArg = _typeField$args22[_i202];
          var argName = typeArg.name;
          var ifaceArg = (0, _find.default)(ifaceField.args, function(arg) {
            return arg.name === argName;
          });
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context.reportError("Object field ".concat(type.name, ".").concat(fieldName, " includes required argument ").concat(argName, " that is missing from the Interface field ").concat(iface.name, ".").concat(fieldName, "."), [typeArg.astNode, ifaceField.astNode]);
          }
        };
        for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {
          _loop2(_i20, _typeField$args2);
        }
      }
    }
    function validateTypeImplementsAncestors(context, type, iface) {
      var ifaceInterfaces = type.getInterfaces();
      for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {
        var transitive = _iface$getInterfaces2[_i22];
        if (ifaceInterfaces.indexOf(transitive) === -1) {
          context.reportError(transitive === type ? "Type ".concat(type.name, " cannot implement ").concat(iface.name, " because it would create a circular reference.") : "Type ".concat(type.name, " must implement ").concat(transitive.name, " because it is implemented by ").concat(iface.name, "."), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));
        }
      }
    }
    function validateUnionMembers(context, union) {
      var memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
      }
      var includedTypeNames = Object.create(null);
      for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {
        var memberType = memberTypes[_i24];
        if (includedTypeNames[memberType.name]) {
          context.reportError("Union type ".concat(union.name, " can only include type ").concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat((0, _inspect.default)(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
        }
      }
    }
    function validateEnumValues(context, enumType) {
      var enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
      }
      for (var _i26 = 0; _i26 < enumValues.length; _i26++) {
        var enumValue = enumValues[_i26];
        var valueName = enumValue.name;
        validateName(context, enumValue);
        if (valueName === "true" || valueName === "false" || valueName === "null") {
          context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
        }
      }
    }
    function validateInputFields(context, inputObj) {
      var fields = (0, _objectValues5.default)(inputObj.getFields());
      if (fields.length === 0) {
        context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
      }
      for (var _i28 = 0; _i28 < fields.length; _i28++) {
        var field = fields[_i28];
        validateName(context, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat((0, _inspect.default)(field.type), "."), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context.reportError("Required input field ".concat(inputObj.name, ".").concat(field.name, " cannot be deprecated."), [
            getDeprecatedDirectiveNode(field.astNode),
            (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
          ]);
        }
      }
    }
    function createInputObjectCircularRefsValidator(context) {
      var visitedTypes = Object.create(null);
      var fieldPath = [];
      var fieldPathIndexByTypeName = Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        var fields = (0, _objectValues5.default)(inputObj.getFields());
        for (var _i30 = 0; _i30 < fields.length; _i30++) {
          var field = fields[_i30];
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            var fieldType = field.type.ofType;
            var cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              var cyclePath = fieldPath.slice(cycleIndex);
              var pathStr = cyclePath.map(function(fieldObj) {
                return fieldObj.name;
              }).join(".");
              context.reportError('Cannot reference Input Object "'.concat(fieldType.name, '" within itself through a series of non-null fields: "').concat(pathStr, '".'), cyclePath.map(function(fieldObj) {
                return fieldObj.astNode;
              }));
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
    }
    function getAllNodes(object) {
      var astNode = object.astNode, extensionASTNodes = object.extensionASTNodes;
      return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];
    }
    function getAllSubNodes(object, getter) {
      var subNodes = [];
      for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {
        var _getter;
        var node = _getAllNodes2[_i32];
        subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);
      }
      return subNodes;
    }
    function getAllImplementsInterfaceNodes(type, iface) {
      return getAllSubNodes(type, function(typeNode) {
        return typeNode.interfaces;
      }).filter(function(ifaceNode) {
        return ifaceNode.name.value === iface.name;
      });
    }
    function getUnionMemberTypeNodes(union, typeName) {
      return getAllSubNodes(union, function(unionNode) {
        return unionNode.types;
      }).filter(function(typeNode) {
        return typeNode.name.value === typeName;
      });
    }
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function(node) {
        return node.name.value === _directives.GraphQLDeprecatedDirective.name;
      });
    }
  }
});

// node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "node_modules/graphql/utilities/typeFromAST.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.typeFromAST = typeFromAST;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _kinds = require_kinds();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function typeFromAST(schema, typeNode) {
      var innerType;
      if (typeNode.kind === _kinds.Kind.LIST_TYPE) {
        innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLList(innerType);
      }
      if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {
        innerType = typeFromAST(schema, typeNode.type);
        return innerType && new _definition.GraphQLNonNull(innerType);
      }
      if (typeNode.kind === _kinds.Kind.NAMED_TYPE) {
        return schema.getType(typeNode.name.value);
      }
      (0, _invariant.default)(0, "Unexpected type node: " + (0, _inspect.default)(typeNode));
    }
  }
});

// node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "node_modules/graphql/utilities/TypeInfo.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.visitWithTypeInfo = visitWithTypeInfo;
    exports.TypeInfo = void 0;
    var _find = _interopRequireDefault(require_find());
    var _kinds = require_kinds();
    var _ast = require_ast();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TypeInfo = /* @__PURE__ */ function() {
      function TypeInfo2(schema, getFieldDefFn, initialType) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      var _proto = TypeInfo2.prototype;
      _proto.getType = function getType2() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      };
      _proto.getParentType = function getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      };
      _proto.getInputType = function getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      };
      _proto.getParentInputType = function getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      };
      _proto.getFieldDef = function getFieldDef2() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      };
      _proto.getDefaultValue = function getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      };
      _proto.getDirective = function getDirective() {
        return this._directive;
      };
      _proto.getArgument = function getArgument() {
        return this._argument;
      };
      _proto.getEnumValue = function getEnumValue() {
        return this._enumValue;
      };
      _proto.enter = function enter(node) {
        var schema = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            var namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : void 0);
            break;
          }
          case _kinds.Kind.FIELD: {
            var parentType = this.getParentType();
            var fieldDef;
            var fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : void 0);
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            var type;
            switch (node.operation) {
              case "query":
                type = schema.getQueryType();
                break;
              case "mutation":
                type = schema.getMutationType();
                break;
              case "subscription":
                type = schema.getSubscriptionType();
                break;
            }
            this._typeStack.push((0, _definition.isObjectType)(type) ? type : void 0);
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            var typeConditionAST = node.typeCondition;
            var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : void 0);
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
            this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : void 0);
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            var argDef;
            var argType;
            var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = (0, _find.default)(fieldOrDirective.args, function(arg) {
                return arg.name === node.name.value;
              });
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : void 0);
            break;
          }
          case _kinds.Kind.LIST: {
            var listType = (0, _definition.getNullableType)(this.getInputType());
            var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : void 0);
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            var objectType = (0, _definition.getNamedType)(this.getInputType());
            var inputFieldType;
            var inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
            this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0);
            break;
          }
          case _kinds.Kind.ENUM: {
            var enumType = (0, _definition.getNamedType)(this.getInputType());
            var enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
        }
      };
      _proto.leave = function leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
        }
      };
      return TypeInfo2;
    }();
    exports.TypeInfo = TypeInfo;
    function getFieldDef(schema, parentType, fieldNode) {
      var name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter: function enter(node) {
          typeInfo.enter(node);
          var fn = (0, _visitor.getVisitFn)(visitor, node.kind, false);
          if (fn) {
            var result = fn.apply(visitor, arguments);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave: function leave(node) {
          var fn = (0, _visitor.getVisitFn)(visitor, node.kind, true);
          var result;
          if (fn) {
            result = fn.apply(visitor, arguments);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
  }
});

// node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "node_modules/graphql/language/predicates.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDefinitionNode = isDefinitionNode;
    exports.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports.isSelectionNode = isSelectionNode;
    exports.isValueNode = isValueNode;
    exports.isTypeNode = isTypeNode;
    exports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    exports.isTypeDefinitionNode = isTypeDefinitionNode;
    exports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports.isTypeExtensionNode = isTypeExtensionNode;
    var _kinds = require_kinds();
    function isDefinitionNode(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
    }
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    function isTypeSystemDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context) {
      return {
        Document: function Document(node) {
          for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {
            var definition = _node$definitions2[_i2];
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              var defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context.reportError(new _GraphQLError.GraphQLError("The ".concat(defName, " definition is not executable."), definition));
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context) {
      var knownOperationNames = Object.create(null);
      return {
        OperationDefinition: function OperationDefinition(node) {
          var operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context.reportError(new _GraphQLError.GraphQLError('There can be only one operation named "'.concat(operationName.value, '".'), [knownOperationNames[operationName.value], operationName]));
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: function FragmentDefinition() {
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    function LoneAnonymousOperationRule(context) {
      var operationCount = 0;
      return {
        Document: function Document(node) {
          operationCount = node.definitions.filter(function(definition) {
            return definition.kind === _kinds.Kind.OPERATION_DEFINITION;
          }).length;
        },
        OperationDefinition: function OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context.reportError(new _GraphQLError.GraphQLError("This anonymous operation must be the only defined operation.", node));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    function SingleFieldSubscriptionsRule(context) {
      return {
        OperationDefinition: function OperationDefinition(node) {
          if (node.operation === "subscription") {
            if (node.selectionSet.selections.length !== 1) {
              context.reportError(new _GraphQLError.GraphQLError(node.name ? 'Subscription "'.concat(node.name.value, '" must select only one top level field.') : "Anonymous Subscription must select only one top level field.", node.selectionSet.selections.slice(1)));
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function KnownTypeNamesRule(context) {
      var schema = context.getSchema();
      var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
      var definedTypes = Object.create(null);
      for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
        var def = _context$getDocument$2[_i2];
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
      return {
        NamedType: function NamedType(node, _1, parent, _2, ancestors) {
          var typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            var isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && isStandardTypeName(typeName)) {
              return;
            }
            var suggestedTypes = (0, _suggestionList.default)(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
            context.reportError(new _GraphQLError.GraphQLError('Unknown type "'.concat(typeName, '".') + (0, _didYouMean.default)(suggestedTypes), node));
          }
        }
      };
    }
    var standardTypeNames = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes).map(function(type) {
      return type.name;
    });
    function isStandardTypeName(typeName) {
      return standardTypeNames.indexOf(typeName) !== -1;
    }
    function isSDLNode(value) {
      return !Array.isArray(value) && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context) {
      return {
        InlineFragment: function InlineFragment(node) {
          var typeCondition = node.typeCondition;
          if (typeCondition) {
            var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);
            if (type && !(0, _definition.isCompositeType)(type)) {
              var typeStr = (0, _printer.print)(typeCondition);
              context.reportError(new _GraphQLError.GraphQLError('Fragment cannot condition on non composite type "'.concat(typeStr, '".'), typeCondition));
            }
          }
        },
        FragmentDefinition: function FragmentDefinition(node) {
          var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);
          if (type && !(0, _definition.isCompositeType)(type)) {
            var typeStr = (0, _printer.print)(node.typeCondition);
            context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(node.name.value, '" cannot condition on non composite type "').concat(typeStr, '".'), node.typeCondition));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context) {
      return {
        VariableDefinition: function VariableDefinition(node) {
          var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type);
          if (type && !(0, _definition.isInputType)(type)) {
            var variableName = node.variable.name.value;
            var typeName = (0, _printer.print)(node.type);
            context.reportError(new _GraphQLError.GraphQLError('Variable "$'.concat(variableName, '" cannot be non-input type "').concat(typeName, '".'), node.type));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ScalarLeafsRule(context) {
      return {
        Field: function Field(node) {
          var type = context.getType();
          var selectionSet = node.selectionSet;
          if (type) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
              if (selectionSet) {
                var fieldName = node.name.value;
                var typeStr = (0, _inspect.default)(type);
                context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(fieldName, '" must not have a selection since type "').concat(typeStr, '" has no subfields.'), selectionSet));
              }
            } else if (!selectionSet) {
              var _fieldName = node.name.value;
              var _typeStr = (0, _inspect.default)(type);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(_fieldName, '" of type "').concat(_typeStr, '" must have a selection of subfields. Did you mean "').concat(_fieldName, ' { ... }"?'), node));
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _arrayFrom = _interopRequireDefault(require_arrayFrom());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function FieldsOnCorrectTypeRule(context) {
      return {
        Field: function Field(node) {
          var type = context.getParentType();
          if (type) {
            var fieldDef = context.getFieldDef();
            if (!fieldDef) {
              var schema = context.getSchema();
              var fieldName = node.name.value;
              var suggestion = (0, _didYouMean.default)("to use an inline fragment on", getSuggestedTypeNames(schema, type, fieldName));
              if (suggestion === "") {
                suggestion = (0, _didYouMean.default)(getSuggestedFieldNames(type, fieldName));
              }
              context.reportError(new _GraphQLError.GraphQLError('Cannot query field "'.concat(fieldName, '" on type "').concat(type.name, '".') + suggestion, node));
            }
          }
        }
      };
    }
    function getSuggestedTypeNames(schema, type, fieldName) {
      if (!(0, _definition.isAbstractType)(type)) {
        return [];
      }
      var suggestedTypes = new Set();
      var usageCount = Object.create(null);
      for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {
        var possibleType = _schema$getPossibleTy2[_i2];
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {
          var _usageCount$possibleI;
          var possibleInterface = _possibleType$getInte2[_i4];
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return (0, _arrayFrom.default)(suggestedTypes).sort(function(typeA, typeB) {
        var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.default)(typeA.name, typeB.name);
      }).map(function(x) {
        return x.name;
      });
    }
    function getSuggestedFieldNames(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
        var possibleFieldNames = Object.keys(type.getFields());
        return (0, _suggestionList.default)(fieldName, possibleFieldNames);
      }
      return [];
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context) {
      var knownFragmentNames = Object.create(null);
      return {
        OperationDefinition: function OperationDefinition() {
          return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
          var fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one fragment named "'.concat(fragmentName, '".'), [knownFragmentNames[fragmentName], node.name]));
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context) {
      return {
        FragmentSpread: function FragmentSpread(node) {
          var fragmentName = node.name.value;
          var fragment = context.getFragment(fragmentName);
          if (!fragment) {
            context.reportError(new _GraphQLError.GraphQLError('Unknown fragment "'.concat(fragmentName, '".'), node.name));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context) {
      var operationDefs = [];
      var fragmentDefs = [];
      return {
        OperationDefinition: function OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave: function leave() {
            var fragmentNameUsed = Object.create(null);
            for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {
              var operation = operationDefs[_i2];
              for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {
                var fragment = _context$getRecursive2[_i4];
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {
              var fragmentDef = fragmentDefs[_i6];
              var fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(fragName, '" is never used.'), fragmentDef));
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _typeComparators = require_typeComparators();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function PossibleFragmentSpreadsRule(context) {
      return {
        InlineFragment: function InlineFragment(node) {
          var fragType = context.getType();
          var parentType = context.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
            var parentTypeStr = (0, _inspect.default)(parentType);
            var fragTypeStr = (0, _inspect.default)(fragType);
            context.reportError(new _GraphQLError.GraphQLError('Fragment cannot be spread here as objects of type "'.concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
          }
        },
        FragmentSpread: function FragmentSpread(node) {
          var fragName = node.name.value;
          var fragType = getFragmentType(context, fragName);
          var parentType = context.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {
            var parentTypeStr = (0, _inspect.default)(parentType);
            var fragTypeStr = (0, _inspect.default)(fragType);
            context.reportError(new _GraphQLError.GraphQLError('Fragment "'.concat(fragName, '" cannot be spread here as objects of type "').concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
          }
        }
      };
    }
    function getFragmentType(context, name) {
      var frag = context.getFragment(name);
      if (frag) {
        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);
        if ((0, _definition.isCompositeType)(type)) {
          return type;
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context) {
      var visitedFrags = Object.create(null);
      var spreadPath = [];
      var spreadPathIndexByName = Object.create(null);
      return {
        OperationDefinition: function OperationDefinition() {
          return false;
        },
        FragmentDefinition: function FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        var fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {
          var spreadNode = spreadNodes[_i2];
          var spreadName = spreadNode.name.value;
          var cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            var spreadFragment = context.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            var cyclePath = spreadPath.slice(cycleIndex);
            var viaPath = cyclePath.slice(0, -1).map(function(s2) {
              return '"' + s2.name.value + '"';
            }).join(", ");
            context.reportError(new _GraphQLError.GraphQLError('Cannot spread fragment "'.concat(spreadName, '" within itself') + (viaPath !== "" ? " via ".concat(viaPath, ".") : "."), cyclePath));
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context) {
      var knownVariableNames = Object.create(null);
      return {
        OperationDefinition: function OperationDefinition() {
          knownVariableNames = Object.create(null);
        },
        VariableDefinition: function VariableDefinition(node) {
          var variableName = node.variable.name.value;
          if (knownVariableNames[variableName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one variable named "$'.concat(variableName, '".'), [knownVariableNames[variableName], node.variable.name]));
          } else {
            knownVariableNames[variableName] = node.variable.name;
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context) {
      var variableNameDefined = Object.create(null);
      return {
        OperationDefinition: {
          enter: function enter() {
            variableNameDefined = Object.create(null);
          },
          leave: function leave(operation) {
            var usages = context.getRecursiveVariableUsages(operation);
            for (var _i2 = 0; _i2 < usages.length; _i2++) {
              var _ref2 = usages[_i2];
              var node = _ref2.node;
              var varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(operation.name ? 'Variable "$'.concat(varName, '" is not defined by operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(varName, '" is not defined.'), [node, operation]));
              }
            }
          }
        },
        VariableDefinition: function VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context) {
      var variableDefs = [];
      return {
        OperationDefinition: {
          enter: function enter() {
            variableDefs = [];
          },
          leave: function leave(operation) {
            var variableNameUsed = Object.create(null);
            var usages = context.getRecursiveVariableUsages(operation);
            for (var _i2 = 0; _i2 < usages.length; _i2++) {
              var _ref2 = usages[_i2];
              var node = _ref2.node;
              variableNameUsed[node.name.value] = true;
            }
            for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {
              var variableDef = _variableDefs2[_i4];
              var variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context.reportError(new _GraphQLError.GraphQLError(operation.name ? 'Variable "$'.concat(variableName, '" is never used in operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(variableName, '" is never used.'), variableDef));
              }
            }
          }
        },
        VariableDefinition: function VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directiveLocation = require_directiveLocation();
    var _directives = require_directives();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function KnownDirectivesRule(context) {
      var locationsMap = Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
        var directive = definedDirectives[_i2];
        locationsMap[directive.name] = directive.locations;
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map(function(name) {
            return name.value;
          });
        }
      }
      return {
        Directive: function Directive(node, _key, _parent, _path, ancestors) {
          var name = node.name.value;
          var locations = locationsMap[name];
          if (!locations) {
            context.reportError(new _GraphQLError.GraphQLError('Unknown directive "@'.concat(name, '".'), node));
            return;
          }
          var candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
            context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(name, '" may not be used on ').concat(candidateLocation, "."), node));
          }
        }
      };
    }
    function getDirectiveLocationForASTPath(ancestors) {
      var appliedTo = ancestors[ancestors.length - 1];
      !Array.isArray(appliedTo) || (0, _invariant.default)(0);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          var parentNode = ancestors[ancestors.length - 3];
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
      }
    }
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case "query":
          return _directiveLocation.DirectiveLocation.QUERY;
        case "mutation":
          return _directiveLocation.DirectiveLocation.MUTATION;
        case "subscription":
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
      (0, _invariant.default)(0, "Unexpected operation: " + (0, _inspect.default)(operation));
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context) {
      var uniqueDirectiveMap = Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
        var directive = definedDirectives[_i2];
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      var schemaDirectives = Object.create(null);
      var typeDirectivesMap = Object.create(null);
      return {
        enter: function enter(node) {
          if (node.directives == null) {
            return;
          }
          var seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            var typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
            }
          } else {
            seenDirectives = Object.create(null);
          }
          for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {
            var _directive = _node$directives2[_i6];
            var directiveName = _directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context.reportError(new _GraphQLError.GraphQLError('The directive "@'.concat(directiveName, '" can only be used once at this location.'), [seenDirectives[directiveName], _directive]));
              } else {
                seenDirectives[directiveName] = _directive;
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KnownArgumentNamesRule = KnownArgumentNamesRule;
    exports.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function KnownArgumentNamesRule(context) {
      return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
        Argument: function Argument(argNode) {
          var argDef = context.getArgument();
          var fieldDef = context.getFieldDef();
          var parentType = context.getParentType();
          if (!argDef && fieldDef && parentType) {
            var argName = argNode.name.value;
            var knownArgsNames = fieldDef.args.map(function(arg) {
              return arg.name;
            });
            var suggestions = (0, _suggestionList.default)(argName, knownArgsNames);
            context.reportError(new _GraphQLError.GraphQLError('Unknown argument "'.concat(argName, '" on field "').concat(parentType.name, ".").concat(fieldDef.name, '".') + (0, _didYouMean.default)(suggestions), argNode));
          }
        }
      });
    }
    function KnownArgumentNamesOnDirectivesRule(context) {
      var directiveArgs = Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
        var directive = definedDirectives[_i2];
        directiveArgs[directive.name] = directive.args.map(function(arg) {
          return arg.name;
        });
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
        var def = astDefinitions[_i4];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map(function(arg) {
            return arg.name.value;
          });
        }
      }
      return {
        Directive: function Directive(directiveNode) {
          var directiveName = directiveNode.name.value;
          var knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {
              var argNode = _directiveNode$argume2[_i6];
              var argName = argNode.name.value;
              if (knownArgs.indexOf(argName) === -1) {
                var suggestions = (0, _suggestionList.default)(argName, knownArgs);
                context.reportError(new _GraphQLError.GraphQLError('Unknown argument "'.concat(argName, '" on directive "@').concat(directiveName, '".') + (0, _didYouMean.default)(suggestions), argNode));
              }
            }
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context) {
      var knownArgNames = Object.create(null);
      return {
        Field: function Field() {
          knownArgNames = Object.create(null);
        },
        Directive: function Directive() {
          knownArgNames = Object.create(null);
        },
        Argument: function Argument(node) {
          var argName = node.name.value;
          if (knownArgNames[argName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one argument named "'.concat(argName, '".'), [knownArgNames[argName], node.name]));
          } else {
            knownArgNames[argName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ValuesOfCorrectTypeRule(context) {
      return {
        ListValue: function ListValue(node) {
          var type = (0, _definition.getNullableType)(context.getParentInputType());
          if (!(0, _definition.isListType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
        },
        ObjectValue: function ObjectValue(node) {
          var type = (0, _definition.getNamedType)(context.getInputType());
          if (!(0, _definition.isInputObjectType)(type)) {
            isValidValueNode(context, node);
            return false;
          }
          var fieldNodeMap = (0, _keyMap.default)(node.fields, function(field) {
            return field.name.value;
          });
          for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i2 < _objectValues2.length; _i2++) {
            var fieldDef = _objectValues2[_i2];
            var fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              var typeStr = (0, _inspect.default)(fieldDef.type);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(type.name, ".").concat(fieldDef.name, '" of required type "').concat(typeStr, '" was not provided.'), node));
            }
          }
        },
        ObjectField: function ObjectField(node) {
          var parentType = (0, _definition.getNamedType)(context.getParentInputType());
          var fieldType = context.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            var suggestions = (0, _suggestionList.default)(node.name.value, Object.keys(parentType.getFields()));
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(node.name.value, '" is not defined by type "').concat(parentType.name, '".') + (0, _didYouMean.default)(suggestions), node));
          }
        },
        NullValue: function NullValue(node) {
          var type = context.getInputType();
          if ((0, _definition.isNonNullType)(type)) {
            context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat((0, _inspect.default)(type), '", found ').concat((0, _printer.print)(node), "."), node));
          }
        },
        EnumValue: function EnumValue(node) {
          return isValidValueNode(context, node);
        },
        IntValue: function IntValue(node) {
          return isValidValueNode(context, node);
        },
        FloatValue: function FloatValue(node) {
          return isValidValueNode(context, node);
        },
        StringValue: function StringValue(node) {
          return isValidValueNode(context, node);
        },
        BooleanValue: function BooleanValue(node) {
          return isValidValueNode(context, node);
        }
      };
    }
    function isValidValueNode(context, node) {
      var locationType = context.getInputType();
      if (!locationType) {
        return;
      }
      var type = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type)) {
        var typeStr = (0, _inspect.default)(locationType);
        context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(typeStr, '", found ').concat((0, _printer.print)(node), "."), node));
        return;
      }
      try {
        var parseResult = type.parseLiteral(node, void 0);
        if (parseResult === void 0) {
          var _typeStr = (0, _inspect.default)(locationType);
          context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(_typeStr, '", found ').concat((0, _printer.print)(node), "."), node));
        }
      } catch (error3) {
        var _typeStr2 = (0, _inspect.default)(locationType);
        if (error3 instanceof _GraphQLError.GraphQLError) {
          context.reportError(error3);
        } else {
          context.reportError(new _GraphQLError.GraphQLError('Expected value of type "'.concat(_typeStr2, '", found ').concat((0, _printer.print)(node), "; ") + error3.message, node, void 0, void 0, void 0, error3));
        }
      }
    }
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    exports.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _directives = require_directives();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ProvidedRequiredArgumentsRule(context) {
      return _objectSpread(_objectSpread({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
        Field: {
          leave: function leave(fieldNode) {
            var _fieldNode$arguments;
            var fieldDef = context.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
            var argNodeMap = (0, _keyMap.default)(argNodes, function(arg) {
              return arg.name.value;
            });
            for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {
              var argDef = _fieldDef$args2[_i2];
              var argNode = argNodeMap[argDef.name];
              if (!argNode && (0, _definition.isRequiredArgument)(argDef)) {
                var argTypeStr = (0, _inspect.default)(argDef.type);
                context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(fieldDef.name, '" argument "').concat(argDef.name, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), fieldNode));
              }
            }
          }
        }
      });
    }
    function ProvidedRequiredArgumentsOnDirectivesRule(context) {
      var requiredArgsMap = Object.create(null);
      var schema = context.getSchema();
      var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {
        var directive = definedDirectives[_i4];
        requiredArgsMap[directive.name] = (0, _keyMap.default)(directive.args.filter(_definition.isRequiredArgument), function(arg) {
          return arg.name;
        });
      }
      var astDefinitions = context.getDocument().definitions;
      for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {
        var def = astDefinitions[_i6];
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.default)(argNodes.filter(isRequiredArgumentNode), function(arg) {
            return arg.name.value;
          });
        }
      }
      return {
        Directive: {
          leave: function leave(directiveNode) {
            var directiveName = directiveNode.name.value;
            var requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              var argNodeMap = (0, _keyMap.default)(_argNodes, function(arg) {
                return arg.name.value;
              });
              for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {
                var argName = _Object$keys2[_i8];
                if (!argNodeMap[argName]) {
                  var argType = requiredArgs[argName].type;
                  var argTypeStr = (0, _definition.isType)(argType) ? (0, _inspect.default)(argType) : (0, _printer.print)(argType);
                  context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveName, '" argument "').concat(argName, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), directiveNode));
                }
              }
            }
          }
        }
      };
    }
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _typeComparators = require_typeComparators();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function VariablesInAllowedPositionRule(context) {
      var varDefMap = Object.create(null);
      return {
        OperationDefinition: {
          enter: function enter() {
            varDefMap = Object.create(null);
          },
          leave: function leave(operation) {
            var usages = context.getRecursiveVariableUsages(operation);
            for (var _i2 = 0; _i2 < usages.length; _i2++) {
              var _ref2 = usages[_i2];
              var node = _ref2.node;
              var type = _ref2.type;
              var defaultValue = _ref2.defaultValue;
              var varName = node.name.value;
              var varDef = varDefMap[varName];
              if (varDef && type) {
                var schema = context.getSchema();
                var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                  var varTypeStr = (0, _inspect.default)(varType);
                  var typeStr = (0, _inspect.default)(type);
                  context.reportError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of type "').concat(varTypeStr, '" used in position expecting type "').concat(typeStr, '".'), [varDef, node]));
                }
              }
            }
          }
        },
        VariableDefinition: function VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        var hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        var nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
    }
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _find = _interopRequireDefault(require_find());
    var _objectEntries3 = _interopRequireDefault(require_objectEntries());
    var _inspect = _interopRequireDefault(require_inspect());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(function(_ref) {
          var responseName = _ref[0], subReason = _ref[1];
          return 'subfields "'.concat(responseName, '" conflict because ') + reasonMessage(subReason);
        }).join(" and ");
      }
      return reason;
    }
    function OverlappingFieldsCanBeMergedRule(context) {
      var comparedFragmentPairs = new PairSet();
      var cachedFieldsAndFragmentNames = new Map();
      return {
        SelectionSet: function SelectionSet(selectionSet) {
          var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
          for (var _i2 = 0; _i2 < conflicts.length; _i2++) {
            var _ref3 = conflicts[_i2];
            var _ref2$ = _ref3[0];
            var responseName = _ref2$[0];
            var reason = _ref2$[1];
            var fields1 = _ref3[1];
            var fields2 = _ref3[2];
            var reasonMsg = reasonMessage(reason);
            context.reportError(new _GraphQLError.GraphQLError('Fields "'.concat(responseName, '" conflict because ').concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields2)));
          }
        }
      };
    }
    function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
      var conflicts = [];
      var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1];
      collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
      if (fragmentNames.length !== 0) {
        for (var i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
          for (var j = i + 1; j < fragmentNames.length; j++) {
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
          }
        }
      }
      return conflicts;
    }
    function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      var fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1];
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
      for (var i = 0; i < fragmentNames2.length; i++) {
        collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
      }
    }
    function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      var fragment1 = context.getFragment(fragmentName1);
      var fragment2 = context.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
      var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1];
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
      for (var j = 0; j < fragmentNames2.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
      }
      for (var i = 0; i < fragmentNames1.length; i++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
      }
    }
    function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      var conflicts = [];
      var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
      var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1];
      collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
      if (fragmentNames2.length !== 0) {
        for (var j = 0; j < fragmentNames2.length; j++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
        }
      }
      if (fragmentNames1.length !== 0) {
        for (var i = 0; i < fragmentNames1.length; i++) {
          collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
        }
      }
      for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {
        for (var _j = 0; _j < fragmentNames2.length; _j++) {
          collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
        }
      }
      return conflicts;
    }
    function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
      for (var _i5 = 0, _objectEntries2 = (0, _objectEntries3.default)(fieldMap); _i5 < _objectEntries2.length; _i5++) {
        var _ref5 = _objectEntries2[_i5];
        var responseName = _ref5[0];
        var fields = _ref5[1];
        if (fields.length > 1) {
          for (var i = 0; i < fields.length; i++) {
            for (var j = i + 1; j < fields.length; j++) {
              var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {
        var responseName = _Object$keys2[_i7];
        var fields2 = fieldMap2[responseName];
        if (fields2) {
          var fields1 = fieldMap1[responseName];
          for (var i = 0; i < fields1.length; i++) {
            for (var j = 0; j < fields2.length; j++) {
              var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
      var parentType2 = field2[0], node2 = field2[1], def2 = field2[2];
      var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        var _node1$arguments, _node2$arguments;
        var name1 = node1.name.value;
        var name2 = node2.name.value;
        if (name1 !== name2) {
          return [[responseName, '"'.concat(name1, '" and "').concat(name2, '" are different fields')], [node1], [node2]];
        }
        var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : [];
        var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : [];
        if (!sameArguments(args1, args2)) {
          return [[responseName, "they have differing arguments"], [node1], [node2]];
        }
      }
      var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [[responseName, 'they return conflicting types "'.concat((0, _inspect.default)(type1), '" and "').concat((0, _inspect.default)(type2), '"')], [node1], [node2]];
      }
      var selectionSet1 = node1.selectionSet;
      var selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    function sameArguments(arguments1, arguments2) {
      if (arguments1.length !== arguments2.length) {
        return false;
      }
      return arguments1.every(function(argument1) {
        var argument2 = (0, _find.default)(arguments2, function(argument) {
          return argument.name.value === argument1.name.value;
        });
        if (!argument2) {
          return false;
        }
        return sameValue(argument1.value, argument2.value);
      });
    }
    function sameValue(value1, value2) {
      return (0, _printer.print)(value1) === (0, _printer.print)(value2);
    }
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      var cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (!cached) {
        var nodeAndDefs = Object.create(null);
        var fragmentNames = Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        cached = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, cached);
      }
      return cached;
    }
    function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
      var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);
      return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
    }
    function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {
        var selection = _selectionSet$selecti2[_i9];
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            var fieldName = selection.name.value;
            var fieldDef = void 0;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            var responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            var typeCondition = selection.typeCondition;
            var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
            break;
          }
        }
      }
    }
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [[responseName, conflicts.map(function(_ref6) {
          var reason = _ref6[0];
          return reason;
        })], conflicts.reduce(function(allFields, _ref7) {
          var fields1 = _ref7[1];
          return allFields.concat(fields1);
        }, [node1]), conflicts.reduce(function(allFields, _ref8) {
          var fields2 = _ref8[2];
          return allFields.concat(fields2);
        }, [node2])];
      }
    }
    var PairSet = /* @__PURE__ */ function() {
      function PairSet2() {
        this._data = Object.create(null);
      }
      var _proto = PairSet2.prototype;
      _proto.has = function has(a, b, areMutuallyExclusive) {
        var first = this._data[a];
        var result = first && first[b];
        if (result === void 0) {
          return false;
        }
        if (areMutuallyExclusive === false) {
          return result === false;
        }
        return true;
      };
      _proto.add = function add(a, b, areMutuallyExclusive) {
        this._pairSetAdd(a, b, areMutuallyExclusive);
        this._pairSetAdd(b, a, areMutuallyExclusive);
      };
      _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {
        var map = this._data[a];
        if (!map) {
          map = Object.create(null);
          this._data[a] = map;
        }
        map[b] = areMutuallyExclusive;
      };
      return PairSet2;
    }();
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context) {
      var knownNameStack = [];
      var knownNames = Object.create(null);
      return {
        ObjectValue: {
          enter: function enter() {
            knownNameStack.push(knownNames);
            knownNames = Object.create(null);
          },
          leave: function leave() {
            knownNames = knownNameStack.pop();
          }
        },
        ObjectField: function ObjectField(node) {
          var fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one input field named "'.concat(fieldName, '".'), [knownNames[fieldName], node.name]));
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context) {
      var _ref, _ref2, _oldSchema$astNode;
      var oldSchema = context.getSchema();
      var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      var schemaDefinitionsCount = 0;
      return {
        SchemaDefinition: function SchemaDefinition(node) {
          if (alreadyDefined) {
            context.reportError(new _GraphQLError.GraphQLError("Cannot define a new schema within a schema extension.", node));
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context.reportError(new _GraphQLError.GraphQLError("Must provide only one schema definition.", node));
          }
          ++schemaDefinitionsCount;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context) {
      var schema = context.getSchema();
      var definedOperationTypes = Object.create(null);
      var existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {
          var operationType = operationTypesNodes[_i2];
          var operation = operationType.operation;
          var alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context.reportError(new _GraphQLError.GraphQLError("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
          } else if (alreadyDefinedOperationType) {
            context.reportError(new _GraphQLError.GraphQLError("There can be only one ".concat(operation, " type in schema."), [alreadyDefinedOperationType, operationType]));
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context) {
      var knownTypeNames = Object.create(null);
      var schema = context.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        var typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
          context.reportError(new _GraphQLError.GraphQLError('Type "'.concat(typeName, '" already exists in the schema. It cannot also be defined in this type definition.'), node.name));
          return;
        }
        if (knownTypeNames[typeName]) {
          context.reportError(new _GraphQLError.GraphQLError('There can be only one type named "'.concat(typeName, '".'), [knownTypeNames[typeName], node.name]));
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context) {
      var schema = context.getSchema();
      var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
      var knownValueNames = Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        var typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = Object.create(null);
        }
        var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        var valueNames = knownValueNames[typeName];
        for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {
          var valueDef = valueNodes[_i2];
          var valueName = valueDef.name.value;
          var existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context.reportError(new _GraphQLError.GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" already exists in the schema. It cannot also be defined in this type extension.'), valueDef.name));
          } else if (valueNames[valueName]) {
            context.reportError(new _GraphQLError.GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" can only be defined once.'), [valueNames[valueName], valueDef.name]));
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context) {
      var schema = context.getSchema();
      var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
      var knownFieldNames = Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        var typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = Object.create(null);
        }
        var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        var fieldNames = knownFieldNames[typeName];
        for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {
          var fieldDef = fieldNodes[_i2];
          var fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" already exists in the schema. It cannot also be defined in this type extension.'), fieldDef.name));
          } else if (fieldNames[fieldName]) {
            context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" can only be defined once.'), [fieldNames[fieldName], fieldDef.name]));
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
    }
    function hasField(type, fieldName) {
      if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
        return type.getFields()[fieldName] != null;
      }
      return false;
    }
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context) {
      var knownDirectiveNames = Object.create(null);
      var schema = context.getSchema();
      return {
        DirectiveDefinition: function DirectiveDefinition(node) {
          var directiveName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
            context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveName, '" already exists in the schema. It cannot be redefined.'), node.name));
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context.reportError(new _GraphQLError.GraphQLError('There can be only one directive named "@'.concat(directiveName, '".'), [knownDirectiveNames[directiveName], node.name]));
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _defKindToExtKind;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function PossibleTypeExtensionsRule(context) {
      var schema = context.getSchema();
      var definedTypes = Object.create(null);
      for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
        var def = _context$getDocument$2[_i2];
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        var typeName = node.name.value;
        var defNode = definedTypes[typeName];
        var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        var expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            var kindStr = extensionKindToTypeName(node.kind);
            context.reportError(new _GraphQLError.GraphQLError("Cannot extend non-".concat(kindStr, ' type "').concat(typeName, '".'), defNode ? [defNode, node] : node));
          }
        } else {
          var allTypeNames = Object.keys(definedTypes);
          if (schema) {
            allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
          }
          var suggestedTypes = (0, _suggestionList.default)(typeName, allTypeNames);
          context.reportError(new _GraphQLError.GraphQLError('Cannot extend type "'.concat(typeName, '" because it is not defined.') + (0, _didYouMean.default)(suggestedTypes), node.name));
        }
      }
    }
    var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, _kinds.Kind.SCALAR_TYPE_DEFINITION, _kinds.Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.OBJECT_TYPE_DEFINITION, _kinds.Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INTERFACE_TYPE_DEFINITION, _kinds.Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.UNION_TYPE_DEFINITION, _kinds.Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.ENUM_TYPE_DEFINITION, _kinds.Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION, _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
    function typeToExtKind(type) {
      if ((0, _definition.isScalarType)(type)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
      }
      (0, _invariant.default)(0, "Unexpected kind: " + (0, _inspect.default)(kind));
    }
  }
});

// node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "node_modules/graphql/validation/specifiedRules.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.specifiedSDLRules = exports.specifiedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var specifiedRules = Object.freeze([_ExecutableDefinitionsRule.ExecutableDefinitionsRule, _UniqueOperationNamesRule.UniqueOperationNamesRule, _LoneAnonymousOperationRule.LoneAnonymousOperationRule, _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule, _KnownTypeNamesRule.KnownTypeNamesRule, _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule, _VariablesAreInputTypesRule.VariablesAreInputTypesRule, _ScalarLeafsRule.ScalarLeafsRule, _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule, _UniqueFragmentNamesRule.UniqueFragmentNamesRule, _KnownFragmentNamesRule.KnownFragmentNamesRule, _NoUnusedFragmentsRule.NoUnusedFragmentsRule, _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule, _NoFragmentCyclesRule.NoFragmentCyclesRule, _UniqueVariableNamesRule.UniqueVariableNamesRule, _NoUndefinedVariablesRule.NoUndefinedVariablesRule, _NoUnusedVariablesRule.NoUnusedVariablesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _KnownArgumentNamesRule.KnownArgumentNamesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule, _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule, _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule]);
    exports.specifiedRules = specifiedRules;
    var specifiedSDLRules = Object.freeze([_LoneSchemaDefinitionRule.LoneSchemaDefinitionRule, _UniqueOperationTypesRule.UniqueOperationTypesRule, _UniqueTypeNamesRule.UniqueTypeNamesRule, _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule, _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule, _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule, _KnownTypeNamesRule.KnownTypeNamesRule, _KnownDirectivesRule.KnownDirectivesRule, _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule, _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule, _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule, _UniqueArgumentNamesRule.UniqueArgumentNamesRule, _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule, _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule]);
    exports.specifiedSDLRules = specifiedSDLRules;
  }
});

// node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "node_modules/graphql/validation/ValidationContext.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var ASTValidationContext = /* @__PURE__ */ function() {
      function ASTValidationContext2(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = new Map();
        this._recursivelyReferencedFragments = new Map();
        this._onError = onError;
      }
      var _proto = ASTValidationContext2.prototype;
      _proto.reportError = function reportError(error3) {
        this._onError(error3);
      };
      _proto.getDocument = function getDocument() {
        return this._ast;
      };
      _proto.getFragment = function getFragment(name) {
        var fragments = this._fragments;
        if (!fragments) {
          this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
            if (statement.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              frags[statement.name.value] = statement;
            }
            return frags;
          }, Object.create(null));
        }
        return fragments[name];
      };
      _proto.getFragmentSpreads = function getFragmentSpreads(node) {
        var spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          var setsToVisit = [node];
          while (setsToVisit.length !== 0) {
            var set = setsToVisit.pop();
            for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {
              var selection = _set$selections2[_i2];
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      };
      _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
        var fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          var collectedNames = Object.create(null);
          var nodesToVisit = [operation.selectionSet];
          while (nodesToVisit.length !== 0) {
            var node = nodesToVisit.pop();
            for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {
              var spread = _this$getFragmentSpre2[_i4];
              var fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                var fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      };
      return ASTValidationContext2;
    }();
    exports.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = /* @__PURE__ */ function(_ASTValidationContext) {
      _inheritsLoose(SDLValidationContext2, _ASTValidationContext);
      function SDLValidationContext2(ast, schema, onError) {
        var _this;
        _this = _ASTValidationContext.call(this, ast, onError) || this;
        _this._schema = schema;
        return _this;
      }
      var _proto2 = SDLValidationContext2.prototype;
      _proto2.getSchema = function getSchema() {
        return this._schema;
      };
      return SDLValidationContext2;
    }(ASTValidationContext);
    exports.SDLValidationContext = SDLValidationContext;
    var ValidationContext = /* @__PURE__ */ function(_ASTValidationContext2) {
      _inheritsLoose(ValidationContext2, _ASTValidationContext2);
      function ValidationContext2(schema, ast, typeInfo, onError) {
        var _this2;
        _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
        _this2._schema = schema;
        _this2._typeInfo = typeInfo;
        _this2._variableUsages = new Map();
        _this2._recursiveVariableUsages = new Map();
        return _this2;
      }
      var _proto3 = ValidationContext2.prototype;
      _proto3.getSchema = function getSchema() {
        return this._schema;
      };
      _proto3.getVariableUsages = function getVariableUsages(node) {
        var usages = this._variableUsages.get(node);
        if (!usages) {
          var newUsages = [];
          var typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
            VariableDefinition: function VariableDefinition() {
              return false;
            },
            Variable: function Variable(variable) {
              newUsages.push({
                node: variable,
                type: typeInfo.getInputType(),
                defaultValue: typeInfo.getDefaultValue()
              });
            }
          }));
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      };
      _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
        var usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {
            var frag = _this$getRecursivelyR2[_i6];
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      };
      _proto3.getType = function getType2() {
        return this._typeInfo.getType();
      };
      _proto3.getParentType = function getParentType() {
        return this._typeInfo.getParentType();
      };
      _proto3.getInputType = function getInputType() {
        return this._typeInfo.getInputType();
      };
      _proto3.getParentInputType = function getParentInputType() {
        return this._typeInfo.getParentInputType();
      };
      _proto3.getFieldDef = function getFieldDef() {
        return this._typeInfo.getFieldDef();
      };
      _proto3.getDirective = function getDirective() {
        return this._typeInfo.getDirective();
      };
      _proto3.getArgument = function getArgument() {
        return this._typeInfo.getArgument();
      };
      _proto3.getEnumValue = function getEnumValue() {
        return this._typeInfo.getEnumValue();
      };
      return ValidationContext2;
    }(ASTValidationContext);
    exports.ValidationContext = ValidationContext;
  }
});

// node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "node_modules/graphql/validation/validate.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validate = validate;
    exports.validateSDL = validateSDL;
    exports.assertValidSDL = assertValidSDL;
    exports.assertValidSDLExtension = assertValidSDLExtension;
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(schema, documentAST) {
      var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _specifiedRules.specifiedRules;
      var typeInfo = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new _TypeInfo.TypeInfo(schema);
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        maxErrors: void 0
      };
      documentAST || (0, _devAssert.default)(0, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      var abortObj = Object.freeze({});
      var errors = [];
      var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo, function(error3) {
        if (options2.maxErrors != null && errors.length >= options2.maxErrors) {
          errors.push(new _GraphQLError.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
          throw abortObj;
        }
        errors.push(error3);
      });
      var visitor = (0, _visitor.visitInParallel)(rules.map(function(rule) {
        return rule(context);
      }));
      try {
        (0, _visitor.visit)(documentAST, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor));
      } catch (e) {
        if (e !== abortObj) {
          throw e;
        }
      }
      return errors;
    }
    function validateSDL(documentAST, schemaToExtend) {
      var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _specifiedRules.specifiedSDLRules;
      var errors = [];
      var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend, function(error3) {
        errors.push(error3);
      });
      var visitors = rules.map(function(rule) {
        return rule(context);
      });
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors;
    }
    function assertValidSDL(documentAST) {
      var errors = validateSDL(documentAST);
      if (errors.length !== 0) {
        throw new Error(errors.map(function(error3) {
          return error3.message;
        }).join("\n\n"));
      }
    }
    function assertValidSDLExtension(documentAST, schema) {
      var errors = validateSDL(documentAST, schema);
      if (errors.length !== 0) {
        throw new Error(errors.map(function(error3) {
          return error3.message;
        }).join("\n\n"));
      }
    }
  }
});

// node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "node_modules/graphql/jsutils/memoize3.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = memoize3;
    function memoize3(fn) {
      var cache0;
      return function memoized(a1, a2, a3) {
        if (!cache0) {
          cache0 = new WeakMap();
        }
        var cache1 = cache0.get(a1);
        var cache2;
        if (cache1) {
          cache2 = cache1.get(a2);
          if (cache2) {
            var cachedValue = cache2.get(a3);
            if (cachedValue !== void 0) {
              return cachedValue;
            }
          }
        } else {
          cache1 = new WeakMap();
          cache0.set(a1, cache1);
        }
        if (!cache2) {
          cache2 = new WeakMap();
          cache1.set(a2, cache2);
        }
        var newValue = fn(a1, a2, a3);
        cache2.set(a3, newValue);
        return newValue;
      };
    }
  }
});

// node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "node_modules/graphql/jsutils/promiseReduce.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = promiseReduce;
    var _isPromise = _interopRequireDefault(require_isPromise());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function promiseReduce(values, callback, initialValue) {
      return values.reduce(function(previous, value) {
        return (0, _isPromise.default)(previous) ? previous.then(function(resolved) {
          return callback(resolved, value);
        }) : callback(previous, value);
      }, initialValue);
    }
  }
});

// node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "node_modules/graphql/jsutils/promiseForObject.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = promiseForObject;
    function promiseForObject(object) {
      var keys = Object.keys(object);
      var valuesAndPromises = keys.map(function(name) {
        return object[name];
      });
      return Promise.all(valuesAndPromises).then(function(values) {
        return values.reduce(function(resolvedObject, value, i) {
          resolvedObject[keys[i]] = value;
          return resolvedObject;
        }, Object.create(null));
      });
    }
  }
});

// node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "node_modules/graphql/jsutils/Path.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addPath = addPath;
    exports.pathToArray = pathToArray;
    function addPath(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    function pathToArray(path) {
      var flattened = [];
      var curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
  }
});

// node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "node_modules/graphql/utilities/getOperationRootType.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOperationRootType = getOperationRootType;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType(schema, operation) {
      if (operation.operation === "query") {
        var queryType = schema.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError("Schema does not define the required query root type.", operation);
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        var mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError("Schema is not configured for mutations.", operation);
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        var subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError("Schema is not configured for subscriptions.", operation);
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError("Can only have query, mutation and subscription operations.", operation);
    }
  }
});

// node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "node_modules/graphql/jsutils/printPathArray.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = printPathArray;
    function printPathArray(path) {
      return path.map(function(key) {
        return typeof key === "number" ? "[" + key.toString() + "]" : "." + key;
      }).join("");
    }
  }
});

// node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "node_modules/graphql/utilities/valueFromAST.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.valueFromAST = valueFromAST;
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _kinds = require_kinds();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function valueFromAST(valueNode, type, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        var variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        var variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST(valueNode, type.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        var itemType = type.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          var coercedValues = [];
          for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
            var itemNode = _valueNode$values2[_i2];
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              var itemValue = valueFromAST(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        var coercedValue = valueFromAST(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        var coercedObj = Object.create(null);
        var fieldNodes = (0, _keyMap.default)(valueNode.fields, function(field2) {
          return field2.name.value;
        });
        for (var _i4 = 0, _objectValues2 = (0, _objectValues3.default)(type.getFields()); _i4 < _objectValues2.length; _i4++) {
          var field = _objectValues2[_i4];
          var fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type)) {
        var result;
        try {
          result = type.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
    }
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
  }
});

// node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "node_modules/graphql/utilities/coerceInputValue.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.coerceInputValue = coerceInputValue;
    var _objectValues3 = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _didYouMean = _interopRequireDefault(require_didYouMean());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
    var _suggestionList = _interopRequireDefault(require_suggestionList());
    var _printPathArray = _interopRequireDefault(require_printPathArray());
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function coerceInputValue(inputValue, type) {
      var onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOnError;
      return coerceInputValueImpl(inputValue, type, onError);
    }
    function defaultOnError(path, invalidValue, error3) {
      var errorPrefix = "Invalid value " + (0, _inspect.default)(invalidValue);
      if (path.length > 0) {
        errorPrefix += ' at "value'.concat((0, _printPathArray.default)(path), '"');
      }
      error3.message = errorPrefix + ": " + error3.message;
      throw error3;
    }
    function coerceInputValueImpl(inputValue, type, onError, path) {
      if ((0, _definition.isNonNullType)(type)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type.ofType, onError, path);
        }
        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected non-nullable type "'.concat((0, _inspect.default)(type), '" not to be null.')));
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type)) {
        var itemType = type.ofType;
        var coercedList = (0, _safeArrayFrom.default)(inputValue, function(itemValue, index2) {
          var itemPath = (0, _Path.addPath)(path, index2, void 0);
          return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
        });
        if (coercedList != null) {
          return coercedList;
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type)) {
        if (!(0, _isObjectLike.default)(inputValue)) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '" to be an object.')));
          return;
        }
        var coercedValue = {};
        var fieldDefs = type.getFields();
        for (var _i2 = 0, _objectValues2 = (0, _objectValues3.default)(fieldDefs); _i2 < _objectValues2.length; _i2++) {
          var field = _objectValues2[_i2];
          var fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              var typeStr = (0, _inspect.default)(field.type);
              onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Field "'.concat(field.name, '" of required type "').concat(typeStr, '" was not provided.')));
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));
        }
        for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {
          var fieldName = _Object$keys2[_i4];
          if (!fieldDefs[fieldName]) {
            var suggestions = (0, _suggestionList.default)(fieldName, Object.keys(type.getFields()));
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Field "'.concat(fieldName, '" is not defined by type "').concat(type.name, '".') + (0, _didYouMean.default)(suggestions)));
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type)) {
        var parseResult;
        try {
          parseResult = type.parseValue(inputValue);
        } catch (error3) {
          if (error3 instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error3);
          } else {
            onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '". ') + error3.message, void 0, void 0, void 0, void 0, error3));
          }
          return;
        }
        if (parseResult === void 0) {
          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError('Expected type "'.concat(type.name, '".')));
        }
        return parseResult;
      }
      (0, _invariant.default)(0, "Unexpected input type: " + (0, _inspect.default)(type));
    }
  }
});

// node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "node_modules/graphql/execution/values.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getVariableValues = getVariableValues;
    exports.getArgumentValues = getArgumentValues;
    exports.getDirectiveValues = getDirectiveValues;
    var _find = _interopRequireDefault(require_find());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _printPathArray = _interopRequireDefault(require_printPathArray());
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _coerceInputValue = require_coerceInputValue();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getVariableValues(schema, varDefNodes, inputs, options2) {
      var errors = [];
      var maxErrors = options2 === null || options2 === void 0 ? void 0 : options2.maxErrors;
      try {
        var coerced = coerceVariableValues(schema, varDefNodes, inputs, function(error3) {
          if (maxErrors != null && errors.length >= maxErrors) {
            throw new _GraphQLError.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
          }
          errors.push(error3);
        });
        if (errors.length === 0) {
          return {
            coerced
          };
        }
      } catch (error3) {
        errors.push(error3);
      }
      return {
        errors
      };
    }
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
      var coercedValues = {};
      var _loop = function _loop2(_i22) {
        var varDefNode = varDefNodes[_i22];
        var varName = varDefNode.variable.name.value;
        var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          var varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" expected value of type "').concat(varTypeStr, '" which cannot be used as an input type.'), varDefNode.type));
          return "continue";
        }
        if (!hasOwnProperty(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);
          } else if ((0, _definition.isNonNullType)(varType)) {
            var _varTypeStr = (0, _inspect.default)(varType);
            onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of required type "').concat(_varTypeStr, '" was not provided.'), varDefNode));
          }
          return "continue";
        }
        var value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          var _varTypeStr2 = (0, _inspect.default)(varType);
          onError(new _GraphQLError.GraphQLError('Variable "$'.concat(varName, '" of non-null type "').concat(_varTypeStr2, '" must not be null.'), varDefNode));
          return "continue";
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, function(path, invalidValue, error3) {
          var prefix = 'Variable "$'.concat(varName, '" got invalid value ') + (0, _inspect.default)(invalidValue);
          if (path.length > 0) {
            prefix += ' at "'.concat(varName).concat((0, _printPathArray.default)(path), '"');
          }
          onError(new _GraphQLError.GraphQLError(prefix + "; " + error3.message, varDefNode, void 0, void 0, void 0, error3.originalError));
        });
      };
      for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {
        var _ret = _loop(_i2);
        if (_ret === "continue")
          continue;
      }
      return coercedValues;
    }
    function getArgumentValues(def, node, variableValues) {
      var _node$arguments;
      var coercedValues = {};
      var argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      var argNodeMap = (0, _keyMap.default)(argumentNodes, function(arg) {
        return arg.name.value;
      });
      for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {
        var argDef = _def$args2[_i4];
        var name = argDef.name;
        var argType = argDef.type;
        var argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of required type "').concat((0, _inspect.default)(argType), '" ') + "was not provided.", node);
          }
          continue;
        }
        var valueNode = argumentNode.value;
        var isNull = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          var variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of required type "').concat((0, _inspect.default)(argType), '" ') + 'was provided the variable "$'.concat(variableName, '" which was not provided a runtime value.'), valueNode);
            }
            continue;
          }
          isNull = variableValues[variableName] == null;
        }
        if (isNull && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" of non-null type "').concat((0, _inspect.default)(argType), '" ') + "must not be null.", valueNode);
        }
        var coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError('Argument "'.concat(name, '" has invalid value ').concat((0, _printer.print)(valueNode), "."), valueNode);
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    function getDirectiveValues(directiveDef, node, variableValues) {
      var directiveNode = node.directives && (0, _find.default)(node.directives, function(directive) {
        return directive.name.value === directiveDef.name;
      });
      if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
      }
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }
});

// node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "node_modules/graphql/execution/execute.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.execute = execute;
    exports.executeSync = executeSync;
    exports.assertValidExecutionArguments = assertValidExecutionArguments;
    exports.buildExecutionContext = buildExecutionContext;
    exports.collectFields = collectFields;
    exports.buildResolveInfo = buildResolveInfo;
    exports.getFieldDef = getFieldDef;
    exports.defaultFieldResolver = exports.defaultTypeResolver = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    var _memoize = _interopRequireDefault(require_memoize3());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _isPromise = _interopRequireDefault(require_isPromise());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _safeArrayFrom = _interopRequireDefault(require_safeArrayFrom());
    var _promiseReduce = _interopRequireDefault(require_promiseReduce());
    var _promiseForObject = _interopRequireDefault(require_promiseForObject());
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _kinds = require_kinds();
    var _validate = require_validate();
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    var _getOperationRootType = require_getOperationRootType();
    var _values = require_values();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function execute(argsOrSchema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
      return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({
        schema: argsOrSchema,
        document: document2,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
    function executeSync(args) {
      var result = executeImpl(args);
      if ((0, _isPromise.default)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function executeImpl(args) {
      var schema = args.schema, document2 = args.document, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, typeResolver = args.typeResolver;
      assertValidExecutionArguments(schema, document2, variableValues);
      var exeContext = buildExecutionContext(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver);
      if (Array.isArray(exeContext)) {
        return {
          errors: exeContext
        };
      }
      var data = executeOperation(exeContext, exeContext.operation, rootValue);
      return buildResponse(exeContext, data);
    }
    function buildResponse(exeContext, data) {
      if ((0, _isPromise.default)(data)) {
        return data.then(function(resolved) {
          return buildResponse(exeContext, resolved);
        });
      }
      return exeContext.errors.length === 0 ? {
        data
      } : {
        errors: exeContext.errors,
        data
      };
    }
    function assertValidExecutionArguments(schema, document2, rawVariableValues) {
      document2 || (0, _devAssert.default)(0, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      rawVariableValues == null || (0, _isObjectLike.default)(rawVariableValues) || (0, _devAssert.default)(0, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
    }
    function buildExecutionContext(schema, document2, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {
      var _definition$name, _operation$variableDe;
      var operation;
      var fragments = Object.create(null);
      for (var _i2 = 0, _document$definitions2 = document2.definitions; _i2 < _document$definitions2.length; _i2++) {
        var definition = _document$definitions2[_i2];
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [new _GraphQLError.GraphQLError("Must provide operation name if query contains multiple operations.")];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [new _GraphQLError.GraphQLError('Unknown operation named "'.concat(operationName, '".'))];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      var variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      var coercedVariableValues = (0, _values.getVariableValues)(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
        maxErrors: 50
      });
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        errors: []
      };
    }
    function executeOperation(exeContext, operation, rootValue) {
      var type = (0, _getOperationRootType.getOperationRootType)(exeContext.schema, operation);
      var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
      var path = void 0;
      try {
        var result = operation.operation === "mutation" ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);
        if ((0, _isPromise.default)(result)) {
          return result.then(void 0, function(error3) {
            exeContext.errors.push(error3);
            return Promise.resolve(null);
          });
        }
        return result;
      } catch (error3) {
        exeContext.errors.push(error3);
        return null;
      }
    }
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.default)(Object.keys(fields), function(results, responseName) {
        var fieldNodes = fields[responseName];
        var fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result === void 0) {
          return results;
        }
        if ((0, _isPromise.default)(result)) {
          return result.then(function(resolvedResult) {
            results[responseName] = resolvedResult;
            return results;
          });
        }
        results[responseName] = result;
        return results;
      }, Object.create(null));
    }
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
      var results = Object.create(null);
      var containsPromise = false;
      for (var _i4 = 0, _Object$keys2 = Object.keys(fields); _i4 < _Object$keys2.length; _i4++) {
        var responseName = _Object$keys2[_i4];
        var fieldNodes = fields[responseName];
        var fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
        var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== void 0) {
          results[responseName] = result;
          if ((0, _isPromise.default)(result)) {
            containsPromise = true;
          }
        }
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.default)(results);
    }
    function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {
        var selection = _selectionSet$selecti2[_i6];
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode(exeContext, selection)) {
              continue;
            }
            var name = getFieldEntryKey(selection);
            if (!fields[name]) {
              fields[name] = [];
            }
            fields[name].push(selection);
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
              continue;
            }
            collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            var fragName = selection.name.value;
            if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
              continue;
            }
            visitedFragmentNames[fragName] = true;
            var fragment = exeContext.fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
              continue;
            }
            collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
            break;
          }
        }
      }
      return fields;
    }
    function shouldIncludeNode(exeContext, node) {
      var skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, exeContext.variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      var include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, exeContext.variableValues);
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch(exeContext, fragment, type) {
      var typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return exeContext.schema.isSubType(conditionalType, type);
      }
      return false;
    }
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    function resolveField(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      var fieldNode = fieldNodes[0];
      var fieldName = fieldNode.name.value;
      var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
      if (!fieldDef) {
        return;
      }
      var returnType = fieldDef.type;
      var resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
      try {
        var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues);
        var _contextValue = exeContext.contextValue;
        var result = resolveFn(source, args, _contextValue, info);
        var completed;
        if ((0, _isPromise.default)(result)) {
          completed = result.then(function(resolved) {
            return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
          });
        } else {
          completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if ((0, _isPromise.default)(completed)) {
          return completed.then(void 0, function(rawError) {
            var error4 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
            return handleFieldError(error4, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        var error3 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(path));
        return handleFieldError(error3, returnType, exeContext);
      }
    }
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    function handleFieldError(error3, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error3;
      }
      exeContext.errors.push(error3);
      return null;
    }
    function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
        if (completed === null) {
          throw new Error("Cannot return null for non-nullable field ".concat(info.parentType.name, ".").concat(info.fieldName, "."));
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
      }
      (0, _invariant.default)(0, "Cannot complete value of unexpected output type: " + (0, _inspect.default)(returnType));
    }
    function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
      var itemType = returnType.ofType;
      var containsPromise = false;
      var completedResults = (0, _safeArrayFrom.default)(result, function(item, index2) {
        var itemPath = (0, _Path.addPath)(path, index2, void 0);
        try {
          var completedItem;
          if ((0, _isPromise.default)(item)) {
            completedItem = item.then(function(resolved) {
              return completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved);
            });
          } else {
            completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
          }
          if ((0, _isPromise.default)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, function(rawError) {
              var error4 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
              return handleFieldError(error4, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          var error3 = (0, _locatedError.locatedError)(rawError, fieldNodes, (0, _Path.pathToArray)(itemPath));
          return handleFieldError(error3, itemType, exeContext);
        }
      });
      if (completedResults == null) {
        throw new _GraphQLError.GraphQLError('Expected Iterable, but did not find one for field "'.concat(info.parentType.name, ".").concat(info.fieldName, '".'));
      }
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    function completeLeafValue(returnType, result) {
      var serializedResult = returnType.serialize(result);
      if (serializedResult === void 0) {
        throw new Error('Expected a value of type "'.concat((0, _inspect.default)(returnType), '" but ') + "received: ".concat((0, _inspect.default)(result)));
      }
      return serializedResult;
    }
    function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
      var _returnType$resolveTy;
      var resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      var contextValue = exeContext.contextValue;
      var runtimeType = resolveTypeFn(result, contextValue, info, returnType);
      if ((0, _isPromise.default)(runtimeType)) {
        return runtimeType.then(function(resolvedRuntimeType) {
          return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
        });
      }
      return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
    }
    function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
      if (runtimeTypeOrName == null) {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '". Either the "').concat(returnType.name, '" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.'), fieldNodes);
      }
      var runtimeTypeName = (0, _definition.isNamedType)(runtimeTypeOrName) ? runtimeTypeOrName.name : runtimeTypeOrName;
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '" with ') + "value ".concat((0, _inspect.default)(result), ', received "').concat((0, _inspect.default)(runtimeTypeOrName), '".'));
      }
      var runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a type "').concat(runtimeTypeName, '" that does not exist inside schema.'), fieldNodes);
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a non-object type "').concat(runtimeTypeName, '".'), fieldNodes);
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError('Runtime Object type "'.concat(runtimeType.name, '" is not a possible type for "').concat(returnType.name, '".'), fieldNodes);
      }
      return runtimeType;
    }
    function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
      if (returnType.isTypeOf) {
        var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if ((0, _isPromise.default)(isTypeOf)) {
          return isTypeOf.then(function(resolvedIsTypeOf) {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
      }
      return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
    }
    function invalidReturnTypeError(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError('Expected value of type "'.concat(returnType.name, '" but got: ').concat((0, _inspect.default)(result), "."), fieldNodes);
    }
    function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {
      var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
      return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    var collectSubfields = (0, _memoize.default)(_collectSubfields);
    function _collectSubfields(exeContext, returnType, fieldNodes) {
      var subFieldNodes = Object.create(null);
      var visitedFragmentNames = Object.create(null);
      for (var _i8 = 0; _i8 < fieldNodes.length; _i8++) {
        var node = fieldNodes[_i8];
        if (node.selectionSet) {
          subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
        }
      }
      return subFieldNodes;
    }
    var defaultTypeResolver = function defaultTypeResolver2(value, contextValue, info, abstractType) {
      if ((0, _isObjectLike.default)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      var possibleTypes = info.schema.getPossibleTypes(abstractType);
      var promisedIsTypeOfResults = [];
      for (var i = 0; i < possibleTypes.length; i++) {
        var type = possibleTypes[i];
        if (type.isTypeOf) {
          var isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if ((0, _isPromise.default)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then(function(isTypeOfResults) {
          for (var _i9 = 0; _i9 < isTypeOfResults.length; _i9++) {
            if (isTypeOfResults[_i9]) {
              return possibleTypes[_i9].name;
            }
          }
        });
      }
    };
    exports.defaultTypeResolver = defaultTypeResolver;
    var defaultFieldResolver = function defaultFieldResolver2(source, args, contextValue, info) {
      if ((0, _isObjectLike.default)(source) || typeof source === "function") {
        var property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
    exports.defaultFieldResolver = defaultFieldResolver;
    function getFieldDef(schema, parentType, fieldName) {
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
  }
});

// node_modules/graphql/graphql.js
var require_graphql = __commonJS({
  "node_modules/graphql/graphql.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.graphql = graphql;
    exports.graphqlSync = graphqlSync;
    var _isPromise = _interopRequireDefault(require_isPromise());
    var _parser = require_parser();
    var _validate = require_validate2();
    var _validate2 = require_validate();
    var _execute = require_execute();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
      var _arguments = arguments;
      return new Promise(function(resolve2) {
        return resolve2(_arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
          schema: argsOrSchema,
          source,
          rootValue,
          contextValue,
          variableValues,
          operationName,
          fieldResolver,
          typeResolver
        }));
      });
    }
    function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
      var result = arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
        schema: argsOrSchema,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
      if ((0, _isPromise.default)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    function graphqlImpl(args) {
      var schema = args.schema, source = args.source, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, typeResolver = args.typeResolver;
      var schemaValidationErrors = (0, _validate2.validateSchema)(schema);
      if (schemaValidationErrors.length > 0) {
        return {
          errors: schemaValidationErrors
        };
      }
      var document2;
      try {
        document2 = (0, _parser.parse)(source);
      } catch (syntaxError) {
        return {
          errors: [syntaxError]
        };
      }
      var validationErrors = (0, _validate.validate)(schema, document2);
      if (validationErrors.length > 0) {
        return {
          errors: validationErrors
        };
      }
      return (0, _execute.execute)({
        schema,
        document: document2,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
  }
});

// node_modules/graphql/type/index.js
var require_type = __commonJS({
  "node_modules/graphql/type/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isSchema", {
      enumerable: true,
      get: function get() {
        return _schema.isSchema;
      }
    });
    Object.defineProperty(exports, "assertSchema", {
      enumerable: true,
      get: function get() {
        return _schema.assertSchema;
      }
    });
    Object.defineProperty(exports, "GraphQLSchema", {
      enumerable: true,
      get: function get() {
        return _schema.GraphQLSchema;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function get() {
        return _definition.isType;
      }
    });
    Object.defineProperty(exports, "isScalarType", {
      enumerable: true,
      get: function get() {
        return _definition.isScalarType;
      }
    });
    Object.defineProperty(exports, "isObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.isObjectType;
      }
    });
    Object.defineProperty(exports, "isInterfaceType", {
      enumerable: true,
      get: function get() {
        return _definition.isInterfaceType;
      }
    });
    Object.defineProperty(exports, "isUnionType", {
      enumerable: true,
      get: function get() {
        return _definition.isUnionType;
      }
    });
    Object.defineProperty(exports, "isEnumType", {
      enumerable: true,
      get: function get() {
        return _definition.isEnumType;
      }
    });
    Object.defineProperty(exports, "isInputObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.isInputObjectType;
      }
    });
    Object.defineProperty(exports, "isListType", {
      enumerable: true,
      get: function get() {
        return _definition.isListType;
      }
    });
    Object.defineProperty(exports, "isNonNullType", {
      enumerable: true,
      get: function get() {
        return _definition.isNonNullType;
      }
    });
    Object.defineProperty(exports, "isInputType", {
      enumerable: true,
      get: function get() {
        return _definition.isInputType;
      }
    });
    Object.defineProperty(exports, "isOutputType", {
      enumerable: true,
      get: function get() {
        return _definition.isOutputType;
      }
    });
    Object.defineProperty(exports, "isLeafType", {
      enumerable: true,
      get: function get() {
        return _definition.isLeafType;
      }
    });
    Object.defineProperty(exports, "isCompositeType", {
      enumerable: true,
      get: function get() {
        return _definition.isCompositeType;
      }
    });
    Object.defineProperty(exports, "isAbstractType", {
      enumerable: true,
      get: function get() {
        return _definition.isAbstractType;
      }
    });
    Object.defineProperty(exports, "isWrappingType", {
      enumerable: true,
      get: function get() {
        return _definition.isWrappingType;
      }
    });
    Object.defineProperty(exports, "isNullableType", {
      enumerable: true,
      get: function get() {
        return _definition.isNullableType;
      }
    });
    Object.defineProperty(exports, "isNamedType", {
      enumerable: true,
      get: function get() {
        return _definition.isNamedType;
      }
    });
    Object.defineProperty(exports, "isRequiredArgument", {
      enumerable: true,
      get: function get() {
        return _definition.isRequiredArgument;
      }
    });
    Object.defineProperty(exports, "isRequiredInputField", {
      enumerable: true,
      get: function get() {
        return _definition.isRequiredInputField;
      }
    });
    Object.defineProperty(exports, "assertType", {
      enumerable: true,
      get: function get() {
        return _definition.assertType;
      }
    });
    Object.defineProperty(exports, "assertScalarType", {
      enumerable: true,
      get: function get() {
        return _definition.assertScalarType;
      }
    });
    Object.defineProperty(exports, "assertObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.assertObjectType;
      }
    });
    Object.defineProperty(exports, "assertInterfaceType", {
      enumerable: true,
      get: function get() {
        return _definition.assertInterfaceType;
      }
    });
    Object.defineProperty(exports, "assertUnionType", {
      enumerable: true,
      get: function get() {
        return _definition.assertUnionType;
      }
    });
    Object.defineProperty(exports, "assertEnumType", {
      enumerable: true,
      get: function get() {
        return _definition.assertEnumType;
      }
    });
    Object.defineProperty(exports, "assertInputObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.assertInputObjectType;
      }
    });
    Object.defineProperty(exports, "assertListType", {
      enumerable: true,
      get: function get() {
        return _definition.assertListType;
      }
    });
    Object.defineProperty(exports, "assertNonNullType", {
      enumerable: true,
      get: function get() {
        return _definition.assertNonNullType;
      }
    });
    Object.defineProperty(exports, "assertInputType", {
      enumerable: true,
      get: function get() {
        return _definition.assertInputType;
      }
    });
    Object.defineProperty(exports, "assertOutputType", {
      enumerable: true,
      get: function get() {
        return _definition.assertOutputType;
      }
    });
    Object.defineProperty(exports, "assertLeafType", {
      enumerable: true,
      get: function get() {
        return _definition.assertLeafType;
      }
    });
    Object.defineProperty(exports, "assertCompositeType", {
      enumerable: true,
      get: function get() {
        return _definition.assertCompositeType;
      }
    });
    Object.defineProperty(exports, "assertAbstractType", {
      enumerable: true,
      get: function get() {
        return _definition.assertAbstractType;
      }
    });
    Object.defineProperty(exports, "assertWrappingType", {
      enumerable: true,
      get: function get() {
        return _definition.assertWrappingType;
      }
    });
    Object.defineProperty(exports, "assertNullableType", {
      enumerable: true,
      get: function get() {
        return _definition.assertNullableType;
      }
    });
    Object.defineProperty(exports, "assertNamedType", {
      enumerable: true,
      get: function get() {
        return _definition.assertNamedType;
      }
    });
    Object.defineProperty(exports, "getNullableType", {
      enumerable: true,
      get: function get() {
        return _definition.getNullableType;
      }
    });
    Object.defineProperty(exports, "getNamedType", {
      enumerable: true,
      get: function get() {
        return _definition.getNamedType;
      }
    });
    Object.defineProperty(exports, "GraphQLScalarType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports, "GraphQLObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLInterfaceType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports, "GraphQLUnionType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports, "GraphQLEnumType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports, "GraphQLInputObjectType", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLList", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLList;
      }
    });
    Object.defineProperty(exports, "GraphQLNonNull", {
      enumerable: true,
      get: function get() {
        return _definition.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports, "isDirective", {
      enumerable: true,
      get: function get() {
        return _directives.isDirective;
      }
    });
    Object.defineProperty(exports, "assertDirective", {
      enumerable: true,
      get: function get() {
        return _directives.assertDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLDirective;
      }
    });
    Object.defineProperty(exports, "isSpecifiedDirective", {
      enumerable: true,
      get: function get() {
        return _directives.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports, "specifiedDirectives", {
      enumerable: true,
      get: function get() {
        return _directives.specifiedDirectives;
      }
    });
    Object.defineProperty(exports, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSkipDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function get() {
        return _directives.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function get() {
        return _directives.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports, "isSpecifiedScalarType", {
      enumerable: true,
      get: function get() {
        return _scalars.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports, "specifiedScalarTypes", {
      enumerable: true,
      get: function get() {
        return _scalars.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports, "GraphQLInt", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLInt;
      }
    });
    Object.defineProperty(exports, "GraphQLFloat", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLFloat;
      }
    });
    Object.defineProperty(exports, "GraphQLString", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLString;
      }
    });
    Object.defineProperty(exports, "GraphQLBoolean", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports, "GraphQLID", {
      enumerable: true,
      get: function get() {
        return _scalars.GraphQLID;
      }
    });
    Object.defineProperty(exports, "isIntrospectionType", {
      enumerable: true,
      get: function get() {
        return _introspection.isIntrospectionType;
      }
    });
    Object.defineProperty(exports, "introspectionTypes", {
      enumerable: true,
      get: function get() {
        return _introspection.introspectionTypes;
      }
    });
    Object.defineProperty(exports, "__Schema", {
      enumerable: true,
      get: function get() {
        return _introspection.__Schema;
      }
    });
    Object.defineProperty(exports, "__Directive", {
      enumerable: true,
      get: function get() {
        return _introspection.__Directive;
      }
    });
    Object.defineProperty(exports, "__DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _introspection.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports, "__Type", {
      enumerable: true,
      get: function get() {
        return _introspection.__Type;
      }
    });
    Object.defineProperty(exports, "__Field", {
      enumerable: true,
      get: function get() {
        return _introspection.__Field;
      }
    });
    Object.defineProperty(exports, "__InputValue", {
      enumerable: true,
      get: function get() {
        return _introspection.__InputValue;
      }
    });
    Object.defineProperty(exports, "__EnumValue", {
      enumerable: true,
      get: function get() {
        return _introspection.__EnumValue;
      }
    });
    Object.defineProperty(exports, "__TypeKind", {
      enumerable: true,
      get: function get() {
        return _introspection.__TypeKind;
      }
    });
    Object.defineProperty(exports, "TypeKind", {
      enumerable: true,
      get: function get() {
        return _introspection.TypeKind;
      }
    });
    Object.defineProperty(exports, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _introspection.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _introspection.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _introspection.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "validateSchema", {
      enumerable: true,
      get: function get() {
        return _validate.validateSchema;
      }
    });
    Object.defineProperty(exports, "assertValidSchema", {
      enumerable: true,
      get: function get() {
        return _validate.assertValidSchema;
      }
    });
    var _schema = require_schema();
    var _definition = require_definition();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _validate = require_validate();
  }
});

// node_modules/graphql/language/index.js
var require_language = __commonJS({
  "node_modules/graphql/language/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Source", {
      enumerable: true,
      get: function get() {
        return _source.Source;
      }
    });
    Object.defineProperty(exports, "getLocation", {
      enumerable: true,
      get: function get() {
        return _location.getLocation;
      }
    });
    Object.defineProperty(exports, "printLocation", {
      enumerable: true,
      get: function get() {
        return _printLocation.printLocation;
      }
    });
    Object.defineProperty(exports, "printSourceLocation", {
      enumerable: true,
      get: function get() {
        return _printLocation.printSourceLocation;
      }
    });
    Object.defineProperty(exports, "Kind", {
      enumerable: true,
      get: function get() {
        return _kinds.Kind;
      }
    });
    Object.defineProperty(exports, "TokenKind", {
      enumerable: true,
      get: function get() {
        return _tokenKind.TokenKind;
      }
    });
    Object.defineProperty(exports, "Lexer", {
      enumerable: true,
      get: function get() {
        return _lexer.Lexer;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parser.parse;
      }
    });
    Object.defineProperty(exports, "parseValue", {
      enumerable: true,
      get: function get() {
        return _parser.parseValue;
      }
    });
    Object.defineProperty(exports, "parseType", {
      enumerable: true,
      get: function get() {
        return _parser.parseType;
      }
    });
    Object.defineProperty(exports, "print", {
      enumerable: true,
      get: function get() {
        return _printer.print;
      }
    });
    Object.defineProperty(exports, "visit", {
      enumerable: true,
      get: function get() {
        return _visitor.visit;
      }
    });
    Object.defineProperty(exports, "visitInParallel", {
      enumerable: true,
      get: function get() {
        return _visitor.visitInParallel;
      }
    });
    Object.defineProperty(exports, "getVisitFn", {
      enumerable: true,
      get: function get() {
        return _visitor.getVisitFn;
      }
    });
    Object.defineProperty(exports, "BREAK", {
      enumerable: true,
      get: function get() {
        return _visitor.BREAK;
      }
    });
    Object.defineProperty(exports, "Location", {
      enumerable: true,
      get: function get() {
        return _ast.Location;
      }
    });
    Object.defineProperty(exports, "Token", {
      enumerable: true,
      get: function get() {
        return _ast.Token;
      }
    });
    Object.defineProperty(exports, "isDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isSelectionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isSelectionNode;
      }
    });
    Object.defineProperty(exports, "isValueNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isValueNode;
      }
    });
    Object.defineProperty(exports, "isTypeNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports, "isTypeExtensionNode", {
      enumerable: true,
      get: function get() {
        return _predicates.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports, "DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _directiveLocation.DirectiveLocation;
      }
    });
    var _source = require_source();
    var _location = require_location();
    var _printLocation = require_printLocation();
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _parser = require_parser();
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _ast = require_ast();
    var _predicates = require_predicates();
    var _directiveLocation = require_directiveLocation();
  }
});

// node_modules/graphql/execution/index.js
var require_execution = __commonJS({
  "node_modules/graphql/execution/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "responsePathAsArray", {
      enumerable: true,
      get: function get() {
        return _Path.pathToArray;
      }
    });
    Object.defineProperty(exports, "execute", {
      enumerable: true,
      get: function get() {
        return _execute.execute;
      }
    });
    Object.defineProperty(exports, "executeSync", {
      enumerable: true,
      get: function get() {
        return _execute.executeSync;
      }
    });
    Object.defineProperty(exports, "defaultFieldResolver", {
      enumerable: true,
      get: function get() {
        return _execute.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports, "defaultTypeResolver", {
      enumerable: true,
      get: function get() {
        return _execute.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports, "getDirectiveValues", {
      enumerable: true,
      get: function get() {
        return _values.getDirectiveValues;
      }
    });
    var _Path = require_Path();
    var _execute = require_execute();
    var _values = require_values();
  }
});

// node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/graphql/jsutils/isAsyncIterable.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isAsyncIterable;
    var _symbols = require_symbols();
    function isAsyncIterable(maybeAsyncIterable) {
      return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[_symbols.SYMBOL_ASYNC_ITERATOR]) === "function";
    }
  }
});

// node_modules/graphql/subscription/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/graphql/subscription/mapAsyncIterator.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = mapAsyncIterator;
    var _symbols = require_symbols();
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function mapAsyncIterator(iterable, callback, rejectCallback) {
      var iteratorMethod = iterable[_symbols.SYMBOL_ASYNC_ITERATOR];
      var iterator = iteratorMethod.call(iterable);
      var $return;
      var abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = function abruptClose2(error3) {
          var rethrow = function rethrow2() {
            return Promise.reject(error3);
          };
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      var mapReject;
      if (rejectCallback) {
        var reject = rejectCallback;
        mapReject = function mapReject2(error3) {
          return asyncMapValue(error3, reject).then(iteratorResult, abruptClose);
        };
      }
      return _defineProperty({
        next: function next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return: function _return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
            value: void 0,
            done: true
          });
        },
        throw: function _throw(error3) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error3).then(mapResult, mapReject);
          }
          return Promise.reject(error3).catch(abruptClose);
        }
      }, _symbols.SYMBOL_ASYNC_ITERATOR, function() {
        return this;
      });
    }
    function asyncMapValue(value, callback) {
      return new Promise(function(resolve2) {
        return resolve2(callback(value));
      });
    }
    function iteratorResult(value) {
      return {
        value,
        done: false
      };
    }
  }
});

// node_modules/graphql/subscription/subscribe.js
var require_subscribe = __commonJS({
  "node_modules/graphql/subscription/subscribe.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.subscribe = subscribe2;
    exports.createSourceEventStream = createSourceEventStream;
    var _inspect = _interopRequireDefault(require_inspect());
    var _isAsyncIterable = _interopRequireDefault(require_isAsyncIterable());
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _values = require_values();
    var _execute = require_execute();
    var _getOperationRootType = require_getOperationRootType();
    var _mapAsyncIterator = _interopRequireDefault(require_mapAsyncIterator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function subscribe2(argsOrSchema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
      return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({
        schema: argsOrSchema,
        document: document2,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        subscribeFieldResolver
      });
    }
    function reportGraphQLError(error3) {
      if (error3 instanceof _GraphQLError.GraphQLError) {
        return {
          errors: [error3]
        };
      }
      throw error3;
    }
    function subscribeImpl(args) {
      var schema = args.schema, document2 = args.document, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, subscribeFieldResolver = args.subscribeFieldResolver;
      var sourcePromise = createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
      var mapSourceToResponse = function mapSourceToResponse2(payload) {
        return (0, _execute.execute)({
          schema,
          document: document2,
          rootValue: payload,
          contextValue,
          variableValues,
          operationName,
          fieldResolver
        });
      };
      return sourcePromise.then(function(resultOrStream) {
        return (0, _isAsyncIterable.default)(resultOrStream) ? (0, _mapAsyncIterator.default)(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream;
      });
    }
    function createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver) {
      (0, _execute.assertValidExecutionArguments)(schema, document2, variableValues);
      return new Promise(function(resolve2) {
        var exeContext = (0, _execute.buildExecutionContext)(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver);
        resolve2(Array.isArray(exeContext) ? {
          errors: exeContext
        } : executeSubscription(exeContext));
      }).catch(reportGraphQLError);
    }
    function executeSubscription(exeContext) {
      var schema = exeContext.schema, operation = exeContext.operation, variableValues = exeContext.variableValues, rootValue = exeContext.rootValue;
      var type = (0, _getOperationRootType.getOperationRootType)(schema, operation);
      var fields = (0, _execute.collectFields)(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
      var responseNames = Object.keys(fields);
      var responseName = responseNames[0];
      var fieldNodes = fields[responseName];
      var fieldNode = fieldNodes[0];
      var fieldName = fieldNode.name.value;
      var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldName);
      if (!fieldDef) {
        throw new _GraphQLError.GraphQLError('The subscription field "'.concat(fieldName, '" is not defined.'), fieldNodes);
      }
      var path = (0, _Path.addPath)(void 0, responseName, type.name);
      var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path);
      return new Promise(function(resolveResult) {
        var _fieldDef$subscribe;
        var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], variableValues);
        var contextValue = exeContext.contextValue;
        var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;
        resolveResult(resolveFn(rootValue, args, contextValue, info));
      }).then(function(eventStream) {
        if (eventStream instanceof Error) {
          throw (0, _locatedError.locatedError)(eventStream, fieldNodes, (0, _Path.pathToArray)(path));
        }
        if (!(0, _isAsyncIterable.default)(eventStream)) {
          throw new Error("Subscription field must return Async Iterable. " + "Received: ".concat((0, _inspect.default)(eventStream), "."));
        }
        return eventStream;
      }, function(error3) {
        throw (0, _locatedError.locatedError)(error3, fieldNodes, (0, _Path.pathToArray)(path));
      });
    }
  }
});

// node_modules/graphql/subscription/index.js
var require_subscription = __commonJS({
  "node_modules/graphql/subscription/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "subscribe", {
      enumerable: true,
      get: function get() {
        return _subscribe.subscribe;
      }
    });
    Object.defineProperty(exports, "createSourceEventStream", {
      enumerable: true,
      get: function get() {
        return _subscribe.createSourceEventStream;
      }
    });
    var _subscribe = require_subscribe();
  }
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var _invariant = _interopRequireDefault(require_invariant2());
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function NoDeprecatedCustomRule(context) {
      return {
        Field: function Field(node) {
          var fieldDef = context.getFieldDef();
          var deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
          if (fieldDef && deprecationReason != null) {
            var parentType = context.getParentType();
            parentType != null || (0, _invariant.default)(0);
            context.reportError(new _GraphQLError.GraphQLError("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated. ").concat(deprecationReason), node));
          }
        },
        Argument: function Argument(node) {
          var argDef = context.getArgument();
          var deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
          if (argDef && deprecationReason != null) {
            var directiveDef = context.getDirective();
            if (directiveDef != null) {
              context.reportError(new _GraphQLError.GraphQLError('Directive "@'.concat(directiveDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
            } else {
              var parentType = context.getParentType();
              var fieldDef = context.getFieldDef();
              parentType != null && fieldDef != null || (0, _invariant.default)(0);
              context.reportError(new _GraphQLError.GraphQLError('Field "'.concat(parentType.name, ".").concat(fieldDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
            }
          }
        },
        ObjectField: function ObjectField(node) {
          var inputObjectDef = (0, _definition.getNamedType)(context.getParentInputType());
          if ((0, _definition.isInputObjectType)(inputObjectDef)) {
            var inputFieldDef = inputObjectDef.getFields()[node.name.value];
            var deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
            if (deprecationReason != null) {
              context.reportError(new _GraphQLError.GraphQLError("The input field ".concat(inputObjectDef.name, ".").concat(inputFieldDef.name, " is deprecated. ").concat(deprecationReason), node));
            }
          }
        },
        EnumValue: function EnumValue(node) {
          var enumValueDef = context.getEnumValue();
          var deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
          if (enumValueDef && deprecationReason != null) {
            var enumTypeDef = (0, _definition.getNamedType)(context.getInputType());
            enumTypeDef != null || (0, _invariant.default)(0);
            context.reportError(new _GraphQLError.GraphQLError('The enum value "'.concat(enumTypeDef.name, ".").concat(enumValueDef.name, '" is deprecated. ').concat(deprecationReason), node));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _introspection = require_introspection();
    function NoSchemaIntrospectionCustomRule(context) {
      return {
        Field: function Field(node) {
          var type = (0, _definition.getNamedType)(context.getType());
          if (type && (0, _introspection.isIntrospectionType)(type)) {
            context.reportError(new _GraphQLError.GraphQLError('GraphQL introspection has been disabled, but the requested query contained the field "'.concat(node.name.value, '".'), node));
          }
        }
      };
    }
  }
});

// node_modules/graphql/validation/index.js
var require_validation = __commonJS({
  "node_modules/graphql/validation/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.validate;
      }
    });
    Object.defineProperty(exports, "ValidationContext", {
      enumerable: true,
      get: function get() {
        return _ValidationContext.ValidationContext;
      }
    });
    Object.defineProperty(exports, "specifiedRules", {
      enumerable: true,
      get: function get() {
        return _specifiedRules.specifiedRules;
      }
    });
    Object.defineProperty(exports, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function get() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function get() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownDirectivesRule", {
      enumerable: true,
      get: function get() {
        return _KnownDirectivesRule.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function get() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function get() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function get() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function get() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function get() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function get() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports, "ScalarLeafsRule", {
      enumerable: true,
      get: function get() {
        return _ScalarLeafsRule.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function get() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function get() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function get() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function get() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function get() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function get() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function get() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function get() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function get() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
      }
    });
    var _validate = require_validate2();
    var _ValidationContext = require_ValidationContext();
    var _specifiedRules = require_specifiedRules();
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/graphql/error/formatError.js
var require_formatError = __commonJS({
  "node_modules/graphql/error/formatError.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.formatError = formatError;
    var _devAssert = _interopRequireDefault(require_devAssert());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function formatError(error3) {
      var _error$message;
      error3 || (0, _devAssert.default)(0, "Received null or undefined error.");
      var message = (_error$message = error3.message) !== null && _error$message !== void 0 ? _error$message : "An unknown error occurred.";
      var locations = error3.locations;
      var path = error3.path;
      var extensions = error3.extensions;
      return extensions && Object.keys(extensions).length > 0 ? {
        message,
        locations,
        path,
        extensions
      } : {
        message,
        locations,
        path
      };
    }
  }
});

// node_modules/graphql/error/index.js
var require_error = __commonJS({
  "node_modules/graphql/error/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GraphQLError", {
      enumerable: true,
      get: function get() {
        return _GraphQLError.GraphQLError;
      }
    });
    Object.defineProperty(exports, "printError", {
      enumerable: true,
      get: function get() {
        return _GraphQLError.printError;
      }
    });
    Object.defineProperty(exports, "syntaxError", {
      enumerable: true,
      get: function get() {
        return _syntaxError.syntaxError;
      }
    });
    Object.defineProperty(exports, "locatedError", {
      enumerable: true,
      get: function get() {
        return _locatedError.locatedError;
      }
    });
    Object.defineProperty(exports, "formatError", {
      enumerable: true,
      get: function get() {
        return _formatError.formatError;
      }
    });
    var _GraphQLError = require_GraphQLError();
    var _syntaxError = require_syntaxError();
    var _locatedError = require_locatedError();
    var _formatError = require_formatError();
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "node_modules/graphql/utilities/getIntrospectionQuery.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getIntrospectionQuery = getIntrospectionQuery;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function getIntrospectionQuery(options2) {
      var optionsWithDefault = _objectSpread({
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false
      }, options2);
      var descriptions = optionsWithDefault.descriptions ? "description" : "";
      var specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByUrl" : "";
      var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      return "\n    query IntrospectionQuery {\n      __schema {\n        ".concat(schemaDescription, "\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ").concat(descriptions, "\n          ").concat(directiveIsRepeatable, "\n          locations\n          args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions, "\n      ").concat(specifiedByUrl, "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields").concat(inputDeprecation("(includeDeprecated: true)"), " {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions, "\n      type { ...TypeRef }\n      defaultValue\n      ").concat(inputDeprecation("isDeprecated"), "\n      ").concat(inputDeprecation("deprecationReason"), "\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
    }
  }
});

// node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "node_modules/graphql/utilities/getOperationAST.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOperationAST = getOperationAST;
    var _kinds = require_kinds();
    function getOperationAST(documentAST, operationName) {
      var operation = null;
      for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
        var definition = _documentAST$definiti2[_i2];
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "node_modules/graphql/utilities/introspectionFromSchema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.introspectionFromSchema = introspectionFromSchema;
    var _invariant = _interopRequireDefault(require_invariant2());
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function introspectionFromSchema(schema, options2) {
      var optionsWithDefaults = _objectSpread({
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true
      }, options2);
      var document2 = (0, _parser.parse)((0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults));
      var result = (0, _execute.executeSync)({
        schema,
        document: document2
      });
      !result.errors && result.data || (0, _invariant.default)(0);
      return result.data;
    }
  }
});

// node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "node_modules/graphql/utilities/buildClientSchema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildClientSchema = buildClientSchema;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _isObjectLike = _interopRequireDefault(require_isObjectLike());
    var _parser = require_parser();
    var _schema = require_schema();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _definition = require_definition();
    var _valueFromAST = require_valueFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function buildClientSchema(introspection, options2) {
      (0, _isObjectLike.default)(introspection) && (0, _isObjectLike.default)(introspection.__schema) || (0, _devAssert.default)(0, 'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: '.concat((0, _inspect.default)(introspection), "."));
      var schemaIntrospection = introspection.__schema;
      var typeMap = (0, _keyValMap.default)(schemaIntrospection.types, function(typeIntrospection) {
        return typeIntrospection.name;
      }, function(typeIntrospection) {
        return buildType(typeIntrospection);
      });
      for (var _i2 = 0, _ref2 = [].concat(_scalars.specifiedScalarTypes, _introspection.introspectionTypes); _i2 < _ref2.length; _i2++) {
        var stdType = _ref2[_i2];
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: (0, _objectValues.default)(typeMap),
        directives,
        assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
      });
      function getType2(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          var itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType2(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          var nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          var nullableType = getType2(nullableRef);
          return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));
        }
        return getNamedType(typeRef);
      }
      function getNamedType(typeRef) {
        var typeName = typeRef.name;
        if (!typeName) {
          throw new Error("Unknown type reference: ".concat((0, _inspect.default)(typeRef), "."));
        }
        var type = typeMap[typeName];
        if (!type) {
          throw new Error("Invalid or incomplete schema, unknown type: ".concat(typeName, ". Ensure that a full introspection query is used in order to build a client schema."));
        }
        return type;
      }
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType(typeRef));
      }
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType(typeRef));
      }
      function buildType(type) {
        if (type != null && type.name != null && type.kind != null) {
          switch (type.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type);
          }
        }
        var typeStr = (0, _inspect.default)(type);
        throw new Error("Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ".concat(typeStr, "."));
      }
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByUrl: scalarIntrospection.specifiedByUrl
        });
      }
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          var implementingIntrospectionStr = (0, _inspect.default)(implementingIntrospection);
          throw new Error("Introspection result missing interfaces: ".concat(implementingIntrospectionStr, "."));
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: function interfaces() {
            return buildImplementationsList(objectIntrospection);
          },
          fields: function fields() {
            return buildFieldDefMap(objectIntrospection);
          }
        });
      }
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: function interfaces() {
            return buildImplementationsList(interfaceIntrospection);
          },
          fields: function fields() {
            return buildFieldDefMap(interfaceIntrospection);
          }
        });
      }
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          var unionIntrospectionStr = (0, _inspect.default)(unionIntrospection);
          throw new Error("Introspection result missing possibleTypes: ".concat(unionIntrospectionStr, "."));
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: function types2() {
            return unionIntrospection.possibleTypes.map(getObjectType);
          }
        });
      }
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          var enumIntrospectionStr = (0, _inspect.default)(enumIntrospection);
          throw new Error("Introspection result missing enumValues: ".concat(enumIntrospectionStr, "."));
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.default)(enumIntrospection.enumValues, function(valueIntrospection) {
            return valueIntrospection.name;
          }, function(valueIntrospection) {
            return {
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            };
          })
        });
      }
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          var inputObjectIntrospectionStr = (0, _inspect.default)(inputObjectIntrospection);
          throw new Error("Introspection result missing inputFields: ".concat(inputObjectIntrospectionStr, "."));
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: function fields() {
            return buildInputValueDefMap(inputObjectIntrospection.inputFields);
          }
        });
      }
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error("Introspection result missing fields: ".concat((0, _inspect.default)(typeIntrospection), "."));
        }
        return (0, _keyValMap.default)(typeIntrospection.fields, function(fieldIntrospection) {
          return fieldIntrospection.name;
        }, buildField);
      }
      function buildField(fieldIntrospection) {
        var type = getType2(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type)) {
          var typeStr = (0, _inspect.default)(type);
          throw new Error("Introspection must provide output type for fields, but received: ".concat(typeStr, "."));
        }
        if (!fieldIntrospection.args) {
          var fieldIntrospectionStr = (0, _inspect.default)(fieldIntrospection);
          throw new Error("Introspection result missing field args: ".concat(fieldIntrospectionStr, "."));
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.default)(inputValueIntrospections, function(inputValue) {
          return inputValue.name;
        }, buildInputValue);
      }
      function buildInputValue(inputValueIntrospection) {
        var type = getType2(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type)) {
          var typeStr = (0, _inspect.default)(type);
          throw new Error("Introspection must provide input type for arguments, but received: ".concat(typeStr, "."));
        }
        var defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : void 0;
        return {
          description: inputValueIntrospection.description,
          type,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          var directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);
          throw new Error("Introspection result missing directive args: ".concat(directiveIntrospectionStr, "."));
        }
        if (!directiveIntrospection.locations) {
          var _directiveIntrospectionStr = (0, _inspect.default)(directiveIntrospection);
          throw new Error("Introspection result missing directive locations: ".concat(_directiveIntrospectionStr, "."));
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
    }
  }
});

// node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "node_modules/graphql/utilities/extendSchema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extendSchema = extendSchema;
    exports.extendSchemaImpl = extendSchemaImpl;
    exports.getDescription = getDescription;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _mapValue = _interopRequireDefault(require_mapValue());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _blockString = require_blockString();
    var _predicates = require_predicates();
    var _validate = require_validate2();
    var _values = require_values();
    var _schema = require_schema();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _directives = require_directives();
    var _definition = require_definition();
    var _valueFromAST = require_valueFromAST();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function extendSchema(schema, documentAST, options2) {
      (0, _schema.assertSchema)(schema);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, "Must provide valid Document AST.");
      if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
      }
      var schemaConfig = schema.toConfig();
      var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options2);
      return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
    }
    function extendSchemaImpl(schemaConfig, documentAST, options2) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      var typeDefs = [];
      var typeExtensionsMap = Object.create(null);
      var directiveDefs = [];
      var schemaDef;
      var schemaExtensions = [];
      for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
        var def = _documentAST$definiti2[_i2];
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          var extendedTypeName = def.name.value;
          var existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      var typeMap = Object.create(null);
      for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {
        var existingType = _schemaConfig$types2[_i4];
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {
        var _stdTypeMap$name;
        var typeNode = typeDefs[_i6];
        var name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      var operationTypes = _objectSpread(_objectSpread({
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
      }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
      return _objectSpread(_objectSpread({
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value
      }, operationTypes), {}, {
        types: (0, _objectValues.default)(typeMap),
        directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),
        extensions: void 0,
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      });
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        }
        if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceDirective(directive) {
        var config = directive.toConfig();
        return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {
          args: (0, _mapValue.default)(config.args, extendArg)
        }));
      }
      function extendNamedType(type) {
        if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {
          return type;
        }
        if ((0, _definition.isScalarType)(type)) {
          return extendScalarType(type);
        }
        if ((0, _definition.isObjectType)(type)) {
          return extendObjectType(type);
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return extendInterfaceType(type);
        }
        if ((0, _definition.isUnionType)(type)) {
          return extendUnionType(type);
        }
        if ((0, _definition.isEnumType)(type)) {
          return extendEnumType(type);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return extendInputObjectType(type);
        }
        (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
      }
      function extendInputObjectType(type) {
        var _typeExtensionsMap$co;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {
          fields: function fields() {
            return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, function(field) {
              return _objectSpread(_objectSpread({}, field), {}, {
                type: replaceType(field.type)
              });
            })), buildInputFieldMap(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendEnumType(type) {
        var _typeExtensionsMap$ty;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {
          values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendScalarType(type) {
        var _typeExtensionsMap$co2;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        var specifiedByUrl = config.specifiedByUrl;
        for (var _i8 = 0; _i8 < extensions.length; _i8++) {
          var _getSpecifiedByUrl;
          var extensionNode = extensions[_i8];
          specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;
        }
        return new _definition.GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {
          specifiedByUrl,
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendObjectType(type) {
        var _typeExtensionsMap$co3;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {
          interfaces: function interfaces() {
            return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
          },
          fields: function fields() {
            return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendInterfaceType(type) {
        var _typeExtensionsMap$co4;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {
          interfaces: function interfaces() {
            return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
          },
          fields: function fields() {
            return _objectSpread(_objectSpread({}, (0, _mapValue.default)(config.fields, extendField)), buildFieldMap(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendUnionType(type) {
        var _typeExtensionsMap$co5;
        var config = type.toConfig();
        var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {
          types: function types2() {
            return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));
          },
          extensionASTNodes: config.extensionASTNodes.concat(extensions)
        }));
      }
      function extendField(field) {
        return _objectSpread(_objectSpread({}, field), {}, {
          type: replaceType(field.type),
          args: (0, _mapValue.default)(field.args, extendArg)
        });
      }
      function extendArg(arg) {
        return _objectSpread(_objectSpread({}, arg), {}, {
          type: replaceType(arg.type)
        });
      }
      function getOperationTypes(nodes) {
        var opTypes = {};
        for (var _i10 = 0; _i10 < nodes.length; _i10++) {
          var _node$operationTypes;
          var node = nodes[_i10];
          var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {
            var operationType = operationTypesNodes[_i12];
            opTypes[operationType.operation] = getNamedType(operationType.type);
          }
        }
        return opTypes;
      }
      function getNamedType(node) {
        var _stdTypeMap$name2;
        var name2 = node.name.value;
        var type = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
        if (type === void 0) {
          throw new Error('Unknown type: "'.concat(name2, '".'));
        }
        return type;
      }
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType(node);
      }
      function buildDirective(node) {
        var locations = node.locations.map(function(_ref) {
          var value = _ref.value;
          return value;
        });
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: getDescription(node, options2),
          locations,
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      function buildFieldMap(nodes) {
        var fieldConfigMap = Object.create(null);
        for (var _i14 = 0; _i14 < nodes.length; _i14++) {
          var _node$fields;
          var node = nodes[_i14];
          var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {
            var field = nodeFields[_i16];
            fieldConfigMap[field.name.value] = {
              type: getWrappedType(field.type),
              description: getDescription(field, options2),
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      function buildArgumentMap(args) {
        var argsNodes = args !== null && args !== void 0 ? args : [];
        var argConfigMap = Object.create(null);
        for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {
          var arg = argsNodes[_i18];
          var type = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type,
            description: getDescription(arg, options2),
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      function buildInputFieldMap(nodes) {
        var inputFieldMap = Object.create(null);
        for (var _i20 = 0; _i20 < nodes.length; _i20++) {
          var _node$fields2;
          var node = nodes[_i20];
          var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
          for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {
            var field = fieldsNodes[_i22];
            var type = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type,
              description: getDescription(field, options2),
              defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      function buildEnumValueMap(nodes) {
        var enumValueMap = Object.create(null);
        for (var _i24 = 0; _i24 < nodes.length; _i24++) {
          var _node$values;
          var node = nodes[_i24];
          var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {
            var value = valuesNodes[_i26];
            enumValueMap[value.name.value] = {
              description: getDescription(value, options2),
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      function buildInterfaces(nodes) {
        var interfaces = [];
        for (var _i28 = 0; _i28 < nodes.length; _i28++) {
          var _node$interfaces;
          var node = nodes[_i28];
          var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];
          for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {
            var type = interfacesNodes[_i30];
            interfaces.push(getNamedType(type));
          }
        }
        return interfaces;
      }
      function buildUnionTypes(nodes) {
        var types2 = [];
        for (var _i32 = 0; _i32 < nodes.length; _i32++) {
          var _node$types;
          var node = nodes[_i32];
          var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];
          for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {
            var type = typeNodes[_i34];
            types2.push(getNamedType(type));
          }
        }
        return types2;
      }
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        var name2 = astNode.name.value;
        var description = getDescription(astNode, options2);
        var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var extensionASTNodes = extensionNodes;
            var allNodes = [astNode].concat(extensionASTNodes);
            return new _definition.GraphQLObjectType({
              name: name2,
              description,
              interfaces: function interfaces() {
                return buildInterfaces(allNodes);
              },
              fields: function fields() {
                return buildFieldMap(allNodes);
              },
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _extensionASTNodes = extensionNodes;
            var _allNodes = [astNode].concat(_extensionASTNodes);
            return new _definition.GraphQLInterfaceType({
              name: name2,
              description,
              interfaces: function interfaces() {
                return buildInterfaces(_allNodes);
              },
              fields: function fields() {
                return buildFieldMap(_allNodes);
              },
              astNode,
              extensionASTNodes: _extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _extensionASTNodes2 = extensionNodes;
            var _allNodes2 = [astNode].concat(_extensionASTNodes2);
            return new _definition.GraphQLEnumType({
              name: name2,
              description,
              values: buildEnumValueMap(_allNodes2),
              astNode,
              extensionASTNodes: _extensionASTNodes2
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _extensionASTNodes3 = extensionNodes;
            var _allNodes3 = [astNode].concat(_extensionASTNodes3);
            return new _definition.GraphQLUnionType({
              name: name2,
              description,
              types: function types2() {
                return buildUnionTypes(_allNodes3);
              },
              astNode,
              extensionASTNodes: _extensionASTNodes3
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _extensionASTNodes4 = extensionNodes;
            return new _definition.GraphQLScalarType({
              name: name2,
              description,
              specifiedByUrl: getSpecifiedByUrl(astNode),
              astNode,
              extensionASTNodes: _extensionASTNodes4
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _extensionASTNodes5 = extensionNodes;
            var _allNodes4 = [astNode].concat(_extensionASTNodes5);
            return new _definition.GraphQLInputObjectType({
              name: name2,
              description,
              fields: function fields() {
                return buildInputFieldMap(_allNodes4);
              },
              astNode,
              extensionASTNodes: _extensionASTNodes5
            });
          }
        }
        (0, _invariant.default)(0, "Unexpected type definition node: " + (0, _inspect.default)(astNode));
      }
    }
    var stdTypeMap = (0, _keyMap.default)(_scalars.specifiedScalarTypes.concat(_introspection.introspectionTypes), function(type) {
      return type.name;
    });
    function getDeprecationReason(node) {
      var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    function getSpecifiedByUrl(node) {
      var specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node);
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
    function getDescription(node, options2) {
      if (node.description) {
        return node.description.value;
      }
      if ((options2 === null || options2 === void 0 ? void 0 : options2.commentDescriptions) === true) {
        var rawValue = getLeadingCommentBlock(node);
        if (rawValue !== void 0) {
          return (0, _blockString.dedentBlockStringValue)("\n" + rawValue);
        }
      }
    }
    function getLeadingCommentBlock(node) {
      var loc = node.loc;
      if (!loc) {
        return;
      }
      var comments = [];
      var token = loc.startToken.prev;
      while (token != null && token.kind === _tokenKind.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        var value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
  }
});

// node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "node_modules/graphql/utilities/buildASTSchema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildASTSchema = buildASTSchema;
    exports.buildSchema = buildSchema;
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _kinds = require_kinds();
    var _parser = require_parser();
    var _validate = require_validate2();
    var _schema = require_schema();
    var _directives = require_directives();
    var _extendSchema = require_extendSchema();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function buildASTSchema(documentAST, options2) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.default)(0, "Must provide valid Document AST.");
      if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      var emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: void 0,
        extensionASTNodes: [],
        assumeValid: false
      };
      var config = (0, _extendSchema.extendSchemaImpl)(emptySchemaConfig, documentAST, options2);
      if (config.astNode == null) {
        for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {
          var type = _config$types2[_i2];
          switch (type.name) {
            case "Query":
              config.query = type;
              break;
            case "Mutation":
              config.mutation = type;
              break;
            case "Subscription":
              config.subscription = type;
              break;
          }
        }
      }
      var directives = config.directives;
      var _loop = function _loop2(_i42) {
        var stdDirective = _directives.specifiedDirectives[_i42];
        if (directives.every(function(directive) {
          return directive.name !== stdDirective.name;
        })) {
          directives.push(stdDirective);
        }
      };
      for (var _i4 = 0; _i4 < _directives.specifiedDirectives.length; _i4++) {
        _loop(_i4);
      }
      return new _schema.GraphQLSchema(config);
    }
    function buildSchema(source, options2) {
      var document2 = (0, _parser.parse)(source, {
        noLocation: options2 === null || options2 === void 0 ? void 0 : options2.noLocation,
        allowLegacySDLEmptyFields: options2 === null || options2 === void 0 ? void 0 : options2.allowLegacySDLEmptyFields,
        allowLegacySDLImplementsInterfaces: options2 === null || options2 === void 0 ? void 0 : options2.allowLegacySDLImplementsInterfaces,
        experimentalFragmentVariables: options2 === null || options2 === void 0 ? void 0 : options2.experimentalFragmentVariables
      });
      return buildASTSchema(document2, {
        commentDescriptions: options2 === null || options2 === void 0 ? void 0 : options2.commentDescriptions,
        assumeValidSDL: options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL,
        assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
      });
    }
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "node_modules/graphql/utilities/lexicographicSortSchema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lexicographicSortSchema = lexicographicSortSchema;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _keyValMap = _interopRequireDefault(require_keyValMap());
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    var _schema = require_schema();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _definition = require_definition();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function lexicographicSortSchema(schema) {
      var schemaConfig = schema.toConfig();
      var typeMap = (0, _keyValMap.default)(sortByName(schemaConfig.types), function(type) {
        return type.name;
      }, sortNamedType);
      return new _schema.GraphQLSchema(_objectSpread(_objectSpread({}, schemaConfig), {}, {
        types: (0, _objectValues.default)(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      }));
      function replaceType(type) {
        if ((0, _definition.isListType)(type)) {
          return new _definition.GraphQLList(replaceType(type.ofType));
        } else if ((0, _definition.isNonNullType)(type)) {
          return new _definition.GraphQLNonNull(replaceType(type.ofType));
        }
        return replaceNamedType(type);
      }
      function replaceNamedType(type) {
        return typeMap[type.name];
      }
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      function sortDirective(directive) {
        var config = directive.toConfig();
        return new _directives.GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {
          locations: sortBy(config.locations, function(x) {
            return x;
          }),
          args: sortArgs(config.args)
        }));
      }
      function sortArgs(args) {
        return sortObjMap(args, function(arg) {
          return _objectSpread(_objectSpread({}, arg), {}, {
            type: replaceType(arg.type)
          });
        });
      }
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, function(field) {
          return _objectSpread(_objectSpread({}, field), {}, {
            type: replaceType(field.type),
            args: sortArgs(field.args)
          });
        });
      }
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, function(field) {
          return _objectSpread(_objectSpread({}, field), {}, {
            type: replaceType(field.type)
          });
        });
      }
      function sortTypes(arr) {
        return sortByName(arr).map(replaceNamedType);
      }
      function sortNamedType(type) {
        if ((0, _definition.isScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {
          return type;
        }
        if ((0, _definition.isObjectType)(type)) {
          var config = type.toConfig();
          return new _definition.GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {
            interfaces: function interfaces() {
              return sortTypes(config.interfaces);
            },
            fields: function fields() {
              return sortFields(config.fields);
            }
          }));
        }
        if ((0, _definition.isInterfaceType)(type)) {
          var _config = type.toConfig();
          return new _definition.GraphQLInterfaceType(_objectSpread(_objectSpread({}, _config), {}, {
            interfaces: function interfaces() {
              return sortTypes(_config.interfaces);
            },
            fields: function fields() {
              return sortFields(_config.fields);
            }
          }));
        }
        if ((0, _definition.isUnionType)(type)) {
          var _config2 = type.toConfig();
          return new _definition.GraphQLUnionType(_objectSpread(_objectSpread({}, _config2), {}, {
            types: function types2() {
              return sortTypes(_config2.types);
            }
          }));
        }
        if ((0, _definition.isEnumType)(type)) {
          var _config3 = type.toConfig();
          return new _definition.GraphQLEnumType(_objectSpread(_objectSpread({}, _config3), {}, {
            values: sortObjMap(_config3.values)
          }));
        }
        if ((0, _definition.isInputObjectType)(type)) {
          var _config4 = type.toConfig();
          return new _definition.GraphQLInputObjectType(_objectSpread(_objectSpread({}, _config4), {}, {
            fields: function fields() {
              return sortInputFields(_config4.fields);
            }
          }));
        }
        (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
      }
    }
    function sortObjMap(map, sortValueFn) {
      var sortedMap = Object.create(null);
      var sortedKeys = sortBy(Object.keys(map), function(x) {
        return x;
      });
      for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {
        var key = sortedKeys[_i2];
        var value = map[key];
        sortedMap[key] = sortValueFn ? sortValueFn(value) : value;
      }
      return sortedMap;
    }
    function sortByName(array) {
      return sortBy(array, function(obj) {
        return obj.name;
      });
    }
    function sortBy(array, mapToKey) {
      return array.slice().sort(function(obj1, obj2) {
        var key1 = mapToKey(obj1);
        var key2 = mapToKey(obj2);
        return (0, _naturalCompare.default)(key1, key2);
      });
    }
  }
});

// node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "node_modules/graphql/utilities/printSchema.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.printSchema = printSchema;
    exports.printIntrospectionSchema = printIntrospectionSchema;
    exports.printType = printType;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _printer = require_printer();
    var _blockString = require_blockString();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _directives = require_directives();
    var _definition = require_definition();
    var _astFromValue = require_astFromValue();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function printSchema(schema, options2) {
      return printFilteredSchema(schema, function(n) {
        return !(0, _directives.isSpecifiedDirective)(n);
      }, isDefinedType, options2);
    }
    function printIntrospectionSchema(schema, options2) {
      return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType, options2);
    }
    function isDefinedType(type) {
      return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);
    }
    function printFilteredSchema(schema, directiveFilter, typeFilter, options2) {
      var directives = schema.getDirectives().filter(directiveFilter);
      var types2 = (0, _objectValues.default)(schema.getTypeMap()).filter(typeFilter);
      return [printSchemaDefinition(schema)].concat(directives.map(function(directive) {
        return printDirective(directive, options2);
      }), types2.map(function(type) {
        return printType(type, options2);
      })).filter(Boolean).join("\n\n") + "\n";
    }
    function printSchemaDefinition(schema) {
      if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
      }
      var operationTypes = [];
      var queryType = schema.getQueryType();
      if (queryType) {
        operationTypes.push("  query: ".concat(queryType.name));
      }
      var mutationType = schema.getMutationType();
      if (mutationType) {
        operationTypes.push("  mutation: ".concat(mutationType.name));
      }
      var subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push("  subscription: ".concat(subscriptionType.name));
      }
      return printDescription({}, schema) + "schema {\n".concat(operationTypes.join("\n"), "\n}");
    }
    function isSchemaOfCommonNames(schema) {
      var queryType = schema.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      var mutationType = schema.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      var subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    function printType(type, options2) {
      if ((0, _definition.isScalarType)(type)) {
        return printScalar(type, options2);
      }
      if ((0, _definition.isObjectType)(type)) {
        return printObject(type, options2);
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return printInterface(type, options2);
      }
      if ((0, _definition.isUnionType)(type)) {
        return printUnion(type, options2);
      }
      if ((0, _definition.isEnumType)(type)) {
        return printEnum(type, options2);
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return printInputObject(type, options2);
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function printScalar(type, options2) {
      return printDescription(options2, type) + "scalar ".concat(type.name) + printSpecifiedByUrl(type);
    }
    function printImplementedInterfaces(type) {
      var interfaces = type.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map(function(i) {
        return i.name;
      }).join(" & ") : "";
    }
    function printObject(type, options2) {
      return printDescription(options2, type) + "type ".concat(type.name) + printImplementedInterfaces(type) + printFields(options2, type);
    }
    function printInterface(type, options2) {
      return printDescription(options2, type) + "interface ".concat(type.name) + printImplementedInterfaces(type) + printFields(options2, type);
    }
    function printUnion(type, options2) {
      var types2 = type.getTypes();
      var possibleTypes = types2.length ? " = " + types2.join(" | ") : "";
      return printDescription(options2, type) + "union " + type.name + possibleTypes;
    }
    function printEnum(type, options2) {
      var values = type.getValues().map(function(value, i) {
        return printDescription(options2, value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason);
      });
      return printDescription(options2, type) + "enum ".concat(type.name) + printBlock(values);
    }
    function printInputObject(type, options2) {
      var fields = (0, _objectValues.default)(type.getFields()).map(function(f, i) {
        return printDescription(options2, f, "  ", !i) + "  " + printInputValue(f);
      });
      return printDescription(options2, type) + "input ".concat(type.name) + printBlock(fields);
    }
    function printFields(options2, type) {
      var fields = (0, _objectValues.default)(type.getFields()).map(function(f, i) {
        return printDescription(options2, f, "  ", !i) + "  " + f.name + printArgs(options2, f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason);
      });
      return printBlock(fields);
    }
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    function printArgs(options2, args) {
      var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      if (args.length === 0) {
        return "";
      }
      if (args.every(function(arg) {
        return !arg.description;
      })) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map(function(arg, i) {
        return printDescription(options2, arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg);
      }).join("\n") + "\n" + indentation + ")";
    }
    function printInputValue(arg) {
      var defaultAST = (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type);
      var argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += " = ".concat((0, _printer.print)(defaultAST));
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    function printDirective(directive, options2) {
      return printDescription(options2, directive) + "directive @" + directive.name + printArgs(options2, directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      var reasonAST = (0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString);
      if (reasonAST && reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        return " @deprecated(reason: " + (0, _printer.print)(reasonAST) + ")";
      }
      return " @deprecated";
    }
    function printSpecifiedByUrl(scalar) {
      if (scalar.specifiedByUrl == null) {
        return "";
      }
      var url = scalar.specifiedByUrl;
      var urlAST = (0, _astFromValue.astFromValue)(url, _scalars.GraphQLString);
      urlAST || (0, _invariant.default)(0, "Unexpected null value returned from `astFromValue` for specifiedByUrl");
      return " @specifiedBy(url: " + (0, _printer.print)(urlAST) + ")";
    }
    function printDescription(options2, def) {
      var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      var firstInBlock = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var description = def.description;
      if (description == null) {
        return "";
      }
      if ((options2 === null || options2 === void 0 ? void 0 : options2.commentDescriptions) === true) {
        return printDescriptionWithComments(description, indentation, firstInBlock);
      }
      var preferMultipleLines = description.length > 70;
      var blockString = (0, _blockString.printBlockString)(description, "", preferMultipleLines);
      var prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
    function printDescriptionWithComments(description, indentation, firstInBlock) {
      var prefix = indentation && !firstInBlock ? "\n" : "";
      var comment = description.split("\n").map(function(line) {
        return indentation + (line !== "" ? "# " + line : "#");
      }).join("\n");
      return prefix + comment + "\n";
    }
  }
});

// node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "node_modules/graphql/utilities/concatAST.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concatAST = concatAST;
    function concatAST(documents) {
      var definitions = [];
      for (var _i2 = 0; _i2 < documents.length; _i2++) {
        var doc = documents[_i2];
        definitions = definitions.concat(doc.definitions);
      }
      return {
        kind: "Document",
        definitions
      };
    }
  }
});

// node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "node_modules/graphql/utilities/separateOperations.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.separateOperations = separateOperations;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      var operations = [];
      var depGraph = Object.create(null);
      for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
        var definitionNode = _documentAST$definiti2[_i2];
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
            break;
        }
      }
      var separatedDocumentASTs = Object.create(null);
      var _loop = function _loop2(_i42) {
        var operation = operations[_i42];
        var dependencies = new Set();
        for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {
          var fragmentName = _collectDependencies2[_i6];
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        var operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter(function(node) {
            return node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);
          })
        };
      };
      for (var _i4 = 0; _i4 < operations.length; _i4++) {
        _loop(_i4);
      }
      return separatedDocumentASTs;
    }
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        var immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {
            var toName = immediateDeps[_i8];
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    function collectDependencies(selectionSet) {
      var dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread: function FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.stripIgnoredCharacters = stripIgnoredCharacters;
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _blockString = require_blockString();
    function stripIgnoredCharacters(source) {
      var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      var body = sourceObj.body;
      var lexer = new _lexer.Lexer(sourceObj);
      var strippedBody = "";
      var wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        var currentToken = lexer.token;
        var tokenKind = currentToken.kind;
        var isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(currentToken.kind);
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        var tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += dedentBlockString(tokenBody);
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
    function dedentBlockString(blockStr) {
      var rawStr = blockStr.slice(3, -3);
      var body = (0, _blockString.dedentBlockStringValue)(rawStr);
      if ((0, _blockString.getBlockStringIndentation)(body) > 0) {
        body = "\n" + body;
      }
      var lastChar = body[body.length - 1];
      var hasTrailingQuote = lastChar === '"' && body.slice(-4) !== '\\"""';
      if (hasTrailingQuote || lastChar === "\\") {
        body += "\n";
      }
      return '"""' + body + '"""';
    }
  }
});

// node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "node_modules/graphql/utilities/findBreakingChanges.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findBreakingChanges = findBreakingChanges;
    exports.findDangerousChanges = findDangerousChanges;
    exports.DangerousChangeType = exports.BreakingChangeType = void 0;
    var _objectValues = _interopRequireDefault(require_objectValues());
    var _keyMap = _interopRequireDefault(require_keyMap());
    var _inspect = _interopRequireDefault(require_inspect());
    var _invariant = _interopRequireDefault(require_invariant2());
    var _naturalCompare = _interopRequireDefault(require_naturalCompare());
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _scalars = require_scalars();
    var _definition = require_definition();
    var _astFromValue = require_astFromValue();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var BreakingChangeType = Object.freeze({
      TYPE_REMOVED: "TYPE_REMOVED",
      TYPE_CHANGED_KIND: "TYPE_CHANGED_KIND",
      TYPE_REMOVED_FROM_UNION: "TYPE_REMOVED_FROM_UNION",
      VALUE_REMOVED_FROM_ENUM: "VALUE_REMOVED_FROM_ENUM",
      REQUIRED_INPUT_FIELD_ADDED: "REQUIRED_INPUT_FIELD_ADDED",
      IMPLEMENTED_INTERFACE_REMOVED: "IMPLEMENTED_INTERFACE_REMOVED",
      FIELD_REMOVED: "FIELD_REMOVED",
      FIELD_CHANGED_KIND: "FIELD_CHANGED_KIND",
      REQUIRED_ARG_ADDED: "REQUIRED_ARG_ADDED",
      ARG_REMOVED: "ARG_REMOVED",
      ARG_CHANGED_KIND: "ARG_CHANGED_KIND",
      DIRECTIVE_REMOVED: "DIRECTIVE_REMOVED",
      DIRECTIVE_ARG_REMOVED: "DIRECTIVE_ARG_REMOVED",
      REQUIRED_DIRECTIVE_ARG_ADDED: "REQUIRED_DIRECTIVE_ARG_ADDED",
      DIRECTIVE_REPEATABLE_REMOVED: "DIRECTIVE_REPEATABLE_REMOVED",
      DIRECTIVE_LOCATION_REMOVED: "DIRECTIVE_LOCATION_REMOVED"
    });
    exports.BreakingChangeType = BreakingChangeType;
    var DangerousChangeType = Object.freeze({
      VALUE_ADDED_TO_ENUM: "VALUE_ADDED_TO_ENUM",
      TYPE_ADDED_TO_UNION: "TYPE_ADDED_TO_UNION",
      OPTIONAL_INPUT_FIELD_ADDED: "OPTIONAL_INPUT_FIELD_ADDED",
      OPTIONAL_ARG_ADDED: "OPTIONAL_ARG_ADDED",
      IMPLEMENTED_INTERFACE_ADDED: "IMPLEMENTED_INTERFACE_ADDED",
      ARG_DEFAULT_VALUE_CHANGE: "ARG_DEFAULT_VALUE_CHANGE"
    });
    exports.DangerousChangeType = DangerousChangeType;
    function findBreakingChanges(oldSchema, newSchema) {
      var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
        return change.type in BreakingChangeType;
      });
      return breakingChanges;
    }
    function findDangerousChanges(oldSchema, newSchema) {
      var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
        return change.type in DangerousChangeType;
      });
      return dangerousChanges;
    }
    function findSchemaChanges(oldSchema, newSchema) {
      return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));
    }
    function findDirectiveChanges(oldSchema, newSchema) {
      var schemaChanges = [];
      var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
      for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {
        var oldDirective = _directivesDiff$remov2[_i2];
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: "".concat(oldDirective.name, " was removed.")
        });
      }
      for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {
        var _ref2 = _directivesDiff$persi2[_i4];
        var _oldDirective = _ref2[0];
        var newDirective = _ref2[1];
        var argsDiff = diff(_oldDirective.args, newDirective.args);
        for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {
          var newArg = _argsDiff$added2[_i6];
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: "A required arg ".concat(newArg.name, " on directive ").concat(_oldDirective.name, " was added.")
            });
          }
        }
        for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {
          var oldArg = _argsDiff$removed2[_i8];
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: "".concat(oldArg.name, " was removed from ").concat(_oldDirective.name, ".")
          });
        }
        if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: "Repeatable flag was removed from ".concat(_oldDirective.name, ".")
          });
        }
        for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {
          var location = _oldDirective$locatio2[_i10];
          if (newDirective.locations.indexOf(location) === -1) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: "".concat(location, " was removed from ").concat(_oldDirective.name, ".")
            });
          }
        }
      }
      return schemaChanges;
    }
    function findTypeChanges(oldSchema, newSchema) {
      var schemaChanges = [];
      var typesDiff = diff((0, _objectValues.default)(oldSchema.getTypeMap()), (0, _objectValues.default)(newSchema.getTypeMap()));
      for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {
        var oldType = _typesDiff$removed2[_i12];
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? "Standard scalar ".concat(oldType.name, " was removed because it is not referenced anymore.") : "".concat(oldType.name, " was removed.")
        });
      }
      for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {
        var _ref4 = _typesDiff$persisted2[_i14];
        var _oldType = _ref4[0];
        var newType = _ref4[1];
        if ((0, _definition.isEnumType)(_oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));
        } else if ((0, _definition.isUnionType)(_oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));
        } else if ((0, _definition.isInputObjectType)(_oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));
        } else if ((0, _definition.isObjectType)(_oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
        } else if ((0, _definition.isInterfaceType)(_oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
        } else if (_oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: "".concat(_oldType.name, " changed from ") + "".concat(typeKindName(_oldType), " to ").concat(typeKindName(newType), ".")
          });
        }
      }
      return schemaChanges;
    }
    function findInputObjectTypeChanges(oldType, newType) {
      var schemaChanges = [];
      var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));
      for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {
        var newField = _fieldsDiff$added2[_i16];
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: "A required field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: "An optional field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
          });
        }
      }
      for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {
        var oldField = _fieldsDiff$removed2[_i18];
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
        });
      }
      for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {
        var _ref6 = _fieldsDiff$persisted2[_i20];
        var _oldField = _ref6[0];
        var _newField = _ref6[1];
        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: "".concat(oldType.name, ".").concat(_oldField.name, " changed type from ") + "".concat(String(_oldField.type), " to ").concat(String(_newField.type), ".")
          });
        }
      }
      return schemaChanges;
    }
    function findUnionTypeChanges(oldType, newType) {
      var schemaChanges = [];
      var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {
        var newPossibleType = _possibleTypesDiff$ad2[_i22];
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: "".concat(newPossibleType.name, " was added to union type ").concat(oldType.name, ".")
        });
      }
      for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {
        var oldPossibleType = _possibleTypesDiff$re2[_i24];
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: "".concat(oldPossibleType.name, " was removed from union type ").concat(oldType.name, ".")
        });
      }
      return schemaChanges;
    }
    function findEnumTypeChanges(oldType, newType) {
      var schemaChanges = [];
      var valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {
        var newValue = _valuesDiff$added2[_i26];
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: "".concat(newValue.name, " was added to enum type ").concat(oldType.name, ".")
        });
      }
      for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {
        var oldValue = _valuesDiff$removed2[_i28];
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: "".concat(oldValue.name, " was removed from enum type ").concat(oldType.name, ".")
        });
      }
      return schemaChanges;
    }
    function findImplementedInterfacesChanges(oldType, newType) {
      var schemaChanges = [];
      var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {
        var newInterface = _interfacesDiff$added2[_i30];
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: "".concat(newInterface.name, " added to interfaces implemented by ").concat(oldType.name, ".")
        });
      }
      for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {
        var oldInterface = _interfacesDiff$remov2[_i32];
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: "".concat(oldType.name, " no longer implements interface ").concat(oldInterface.name, ".")
        });
      }
      return schemaChanges;
    }
    function findFieldChanges(oldType, newType) {
      var schemaChanges = [];
      var fieldsDiff = diff((0, _objectValues.default)(oldType.getFields()), (0, _objectValues.default)(newType.getFields()));
      for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {
        var oldField = _fieldsDiff$removed4[_i34];
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
        });
      }
      for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {
        var _ref8 = _fieldsDiff$persisted4[_i36];
        var _oldField2 = _ref8[0];
        var newField = _ref8[1];
        schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));
        var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: "".concat(oldType.name, ".").concat(_oldField2.name, " changed type from ") + "".concat(String(_oldField2.type), " to ").concat(String(newField.type), ".")
          });
        }
      }
      return schemaChanges;
    }
    function findArgChanges(oldType, oldField, newField) {
      var schemaChanges = [];
      var argsDiff = diff(oldField.args, newField.args);
      for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {
        var oldArg = _argsDiff$removed4[_i38];
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(oldArg.name, " was removed.")
        });
      }
      for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {
        var _ref10 = _argsDiff$persisted2[_i40];
        var _oldArg = _ref10[0];
        var newArg = _ref10[1];
        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed type from ") + "".concat(String(_oldArg.type), " to ").concat(String(newArg.type), ".")
          });
        } else if (_oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " defaultValue was removed.")
            });
          } else {
            var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);
            var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed defaultValue from ").concat(oldValueStr, " to ").concat(newValueStr, ".")
              });
            }
          }
        }
      }
      for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {
        var _newArg = _argsDiff$added4[_i42];
        if ((0, _definition.isRequiredArgument)(_newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: "A required arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: "An optional arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
          });
        }
      }
      return schemaChanges;
    }
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name || (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
    }
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    function typeKindName(type) {
      if ((0, _definition.isScalarType)(type)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type)) {
        return "an Input type";
      }
      (0, _invariant.default)(0, "Unexpected type: " + (0, _inspect.default)(type));
    }
    function stringifyValue(value, type) {
      var ast = (0, _astFromValue.astFromValue)(value, type);
      ast != null || (0, _invariant.default)(0);
      var sortedAST = (0, _visitor.visit)(ast, {
        ObjectValue: function ObjectValue(objectNode) {
          var fields = [].concat(objectNode.fields);
          fields.sort(function(fieldA, fieldB) {
            return (0, _naturalCompare.default)(fieldA.name.value, fieldB.name.value);
          });
          return _objectSpread(_objectSpread({}, objectNode), {}, {
            fields
          });
        }
      });
      return (0, _printer.print)(sortedAST);
    }
    function diff(oldArray, newArray) {
      var added = [];
      var removed = [];
      var persisted = [];
      var oldMap = (0, _keyMap.default)(oldArray, function(_ref11) {
        var name = _ref11.name;
        return name;
      });
      var newMap = (0, _keyMap.default)(newArray, function(_ref12) {
        var name = _ref12.name;
        return name;
      });
      for (var _i44 = 0; _i44 < oldArray.length; _i44++) {
        var oldItem = oldArray[_i44];
        var newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (var _i46 = 0; _i46 < newArray.length; _i46++) {
        var _newItem = newArray[_i46];
        if (oldMap[_newItem.name] === void 0) {
          added.push(_newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
  }
});

// node_modules/graphql/utilities/findDeprecatedUsages.js
var require_findDeprecatedUsages = __commonJS({
  "node_modules/graphql/utilities/findDeprecatedUsages.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findDeprecatedUsages = findDeprecatedUsages;
    var _validate = require_validate2();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    function findDeprecatedUsages(schema, ast) {
      return (0, _validate.validate)(schema, ast, [_NoDeprecatedCustomRule.NoDeprecatedCustomRule]);
    }
  }
});

// node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/graphql/utilities/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getIntrospectionQuery", {
      enumerable: true,
      get: function get() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports, "getOperationAST", {
      enumerable: true,
      get: function get() {
        return _getOperationAST.getOperationAST;
      }
    });
    Object.defineProperty(exports, "getOperationRootType", {
      enumerable: true,
      get: function get() {
        return _getOperationRootType.getOperationRootType;
      }
    });
    Object.defineProperty(exports, "introspectionFromSchema", {
      enumerable: true,
      get: function get() {
        return _introspectionFromSchema.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports, "buildClientSchema", {
      enumerable: true,
      get: function get() {
        return _buildClientSchema.buildClientSchema;
      }
    });
    Object.defineProperty(exports, "buildASTSchema", {
      enumerable: true,
      get: function get() {
        return _buildASTSchema.buildASTSchema;
      }
    });
    Object.defineProperty(exports, "buildSchema", {
      enumerable: true,
      get: function get() {
        return _buildASTSchema.buildSchema;
      }
    });
    Object.defineProperty(exports, "extendSchema", {
      enumerable: true,
      get: function get() {
        return _extendSchema.extendSchema;
      }
    });
    Object.defineProperty(exports, "getDescription", {
      enumerable: true,
      get: function get() {
        return _extendSchema.getDescription;
      }
    });
    Object.defineProperty(exports, "lexicographicSortSchema", {
      enumerable: true,
      get: function get() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports, "printSchema", {
      enumerable: true,
      get: function get() {
        return _printSchema.printSchema;
      }
    });
    Object.defineProperty(exports, "printType", {
      enumerable: true,
      get: function get() {
        return _printSchema.printType;
      }
    });
    Object.defineProperty(exports, "printIntrospectionSchema", {
      enumerable: true,
      get: function get() {
        return _printSchema.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports, "typeFromAST", {
      enumerable: true,
      get: function get() {
        return _typeFromAST.typeFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromAST", {
      enumerable: true,
      get: function get() {
        return _valueFromAST.valueFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromASTUntyped", {
      enumerable: true,
      get: function get() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports, "astFromValue", {
      enumerable: true,
      get: function get() {
        return _astFromValue.astFromValue;
      }
    });
    Object.defineProperty(exports, "TypeInfo", {
      enumerable: true,
      get: function get() {
        return _TypeInfo.TypeInfo;
      }
    });
    Object.defineProperty(exports, "visitWithTypeInfo", {
      enumerable: true,
      get: function get() {
        return _TypeInfo.visitWithTypeInfo;
      }
    });
    Object.defineProperty(exports, "coerceInputValue", {
      enumerable: true,
      get: function get() {
        return _coerceInputValue.coerceInputValue;
      }
    });
    Object.defineProperty(exports, "concatAST", {
      enumerable: true,
      get: function get() {
        return _concatAST.concatAST;
      }
    });
    Object.defineProperty(exports, "separateOperations", {
      enumerable: true,
      get: function get() {
        return _separateOperations.separateOperations;
      }
    });
    Object.defineProperty(exports, "stripIgnoredCharacters", {
      enumerable: true,
      get: function get() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports, "isEqualType", {
      enumerable: true,
      get: function get() {
        return _typeComparators.isEqualType;
      }
    });
    Object.defineProperty(exports, "isTypeSubTypeOf", {
      enumerable: true,
      get: function get() {
        return _typeComparators.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports, "doTypesOverlap", {
      enumerable: true,
      get: function get() {
        return _typeComparators.doTypesOverlap;
      }
    });
    Object.defineProperty(exports, "assertValidName", {
      enumerable: true,
      get: function get() {
        return _assertValidName.assertValidName;
      }
    });
    Object.defineProperty(exports, "isValidNameError", {
      enumerable: true,
      get: function get() {
        return _assertValidName.isValidNameError;
      }
    });
    Object.defineProperty(exports, "BreakingChangeType", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.BreakingChangeType;
      }
    });
    Object.defineProperty(exports, "DangerousChangeType", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.DangerousChangeType;
      }
    });
    Object.defineProperty(exports, "findBreakingChanges", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.findBreakingChanges;
      }
    });
    Object.defineProperty(exports, "findDangerousChanges", {
      enumerable: true,
      get: function get() {
        return _findBreakingChanges.findDangerousChanges;
      }
    });
    Object.defineProperty(exports, "findDeprecatedUsages", {
      enumerable: true,
      get: function get() {
        return _findDeprecatedUsages.findDeprecatedUsages;
      }
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
    var _findDeprecatedUsages = require_findDeprecatedUsages();
  }
});

// node_modules/graphql/index.js
var require_graphql2 = __commonJS({
  "node_modules/graphql/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.version;
      }
    });
    Object.defineProperty(exports, "versionInfo", {
      enumerable: true,
      get: function get() {
        return _version.versionInfo;
      }
    });
    Object.defineProperty(exports, "graphql", {
      enumerable: true,
      get: function get() {
        return _graphql.graphql;
      }
    });
    Object.defineProperty(exports, "graphqlSync", {
      enumerable: true,
      get: function get() {
        return _graphql.graphqlSync;
      }
    });
    Object.defineProperty(exports, "GraphQLSchema", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLSchema;
      }
    });
    Object.defineProperty(exports, "GraphQLDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLScalarType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLScalarType;
      }
    });
    Object.defineProperty(exports, "GraphQLObjectType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLInterfaceType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLInterfaceType;
      }
    });
    Object.defineProperty(exports, "GraphQLUnionType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLUnionType;
      }
    });
    Object.defineProperty(exports, "GraphQLEnumType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLEnumType;
      }
    });
    Object.defineProperty(exports, "GraphQLInputObjectType", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLInputObjectType;
      }
    });
    Object.defineProperty(exports, "GraphQLList", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLList;
      }
    });
    Object.defineProperty(exports, "GraphQLNonNull", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLNonNull;
      }
    });
    Object.defineProperty(exports, "specifiedScalarTypes", {
      enumerable: true,
      get: function get() {
        return _index.specifiedScalarTypes;
      }
    });
    Object.defineProperty(exports, "GraphQLInt", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLInt;
      }
    });
    Object.defineProperty(exports, "GraphQLFloat", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLFloat;
      }
    });
    Object.defineProperty(exports, "GraphQLString", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLString;
      }
    });
    Object.defineProperty(exports, "GraphQLBoolean", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLBoolean;
      }
    });
    Object.defineProperty(exports, "GraphQLID", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLID;
      }
    });
    Object.defineProperty(exports, "specifiedDirectives", {
      enumerable: true,
      get: function get() {
        return _index.specifiedDirectives;
      }
    });
    Object.defineProperty(exports, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLIncludeDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSkipDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLSkipDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLDeprecatedDirective;
      }
    });
    Object.defineProperty(exports, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function get() {
        return _index.GraphQLSpecifiedByDirective;
      }
    });
    Object.defineProperty(exports, "TypeKind", {
      enumerable: true,
      get: function get() {
        return _index.TypeKind;
      }
    });
    Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function get() {
        return _index.DEFAULT_DEPRECATION_REASON;
      }
    });
    Object.defineProperty(exports, "introspectionTypes", {
      enumerable: true,
      get: function get() {
        return _index.introspectionTypes;
      }
    });
    Object.defineProperty(exports, "__Schema", {
      enumerable: true,
      get: function get() {
        return _index.__Schema;
      }
    });
    Object.defineProperty(exports, "__Directive", {
      enumerable: true,
      get: function get() {
        return _index.__Directive;
      }
    });
    Object.defineProperty(exports, "__DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _index.__DirectiveLocation;
      }
    });
    Object.defineProperty(exports, "__Type", {
      enumerable: true,
      get: function get() {
        return _index.__Type;
      }
    });
    Object.defineProperty(exports, "__Field", {
      enumerable: true,
      get: function get() {
        return _index.__Field;
      }
    });
    Object.defineProperty(exports, "__InputValue", {
      enumerable: true,
      get: function get() {
        return _index.__InputValue;
      }
    });
    Object.defineProperty(exports, "__EnumValue", {
      enumerable: true,
      get: function get() {
        return _index.__EnumValue;
      }
    });
    Object.defineProperty(exports, "__TypeKind", {
      enumerable: true,
      get: function get() {
        return _index.__TypeKind;
      }
    });
    Object.defineProperty(exports, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _index.SchemaMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _index.TypeMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function get() {
        return _index.TypeNameMetaFieldDef;
      }
    });
    Object.defineProperty(exports, "isSchema", {
      enumerable: true,
      get: function get() {
        return _index.isSchema;
      }
    });
    Object.defineProperty(exports, "isDirective", {
      enumerable: true,
      get: function get() {
        return _index.isDirective;
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function get() {
        return _index.isType;
      }
    });
    Object.defineProperty(exports, "isScalarType", {
      enumerable: true,
      get: function get() {
        return _index.isScalarType;
      }
    });
    Object.defineProperty(exports, "isObjectType", {
      enumerable: true,
      get: function get() {
        return _index.isObjectType;
      }
    });
    Object.defineProperty(exports, "isInterfaceType", {
      enumerable: true,
      get: function get() {
        return _index.isInterfaceType;
      }
    });
    Object.defineProperty(exports, "isUnionType", {
      enumerable: true,
      get: function get() {
        return _index.isUnionType;
      }
    });
    Object.defineProperty(exports, "isEnumType", {
      enumerable: true,
      get: function get() {
        return _index.isEnumType;
      }
    });
    Object.defineProperty(exports, "isInputObjectType", {
      enumerable: true,
      get: function get() {
        return _index.isInputObjectType;
      }
    });
    Object.defineProperty(exports, "isListType", {
      enumerable: true,
      get: function get() {
        return _index.isListType;
      }
    });
    Object.defineProperty(exports, "isNonNullType", {
      enumerable: true,
      get: function get() {
        return _index.isNonNullType;
      }
    });
    Object.defineProperty(exports, "isInputType", {
      enumerable: true,
      get: function get() {
        return _index.isInputType;
      }
    });
    Object.defineProperty(exports, "isOutputType", {
      enumerable: true,
      get: function get() {
        return _index.isOutputType;
      }
    });
    Object.defineProperty(exports, "isLeafType", {
      enumerable: true,
      get: function get() {
        return _index.isLeafType;
      }
    });
    Object.defineProperty(exports, "isCompositeType", {
      enumerable: true,
      get: function get() {
        return _index.isCompositeType;
      }
    });
    Object.defineProperty(exports, "isAbstractType", {
      enumerable: true,
      get: function get() {
        return _index.isAbstractType;
      }
    });
    Object.defineProperty(exports, "isWrappingType", {
      enumerable: true,
      get: function get() {
        return _index.isWrappingType;
      }
    });
    Object.defineProperty(exports, "isNullableType", {
      enumerable: true,
      get: function get() {
        return _index.isNullableType;
      }
    });
    Object.defineProperty(exports, "isNamedType", {
      enumerable: true,
      get: function get() {
        return _index.isNamedType;
      }
    });
    Object.defineProperty(exports, "isRequiredArgument", {
      enumerable: true,
      get: function get() {
        return _index.isRequiredArgument;
      }
    });
    Object.defineProperty(exports, "isRequiredInputField", {
      enumerable: true,
      get: function get() {
        return _index.isRequiredInputField;
      }
    });
    Object.defineProperty(exports, "isSpecifiedScalarType", {
      enumerable: true,
      get: function get() {
        return _index.isSpecifiedScalarType;
      }
    });
    Object.defineProperty(exports, "isIntrospectionType", {
      enumerable: true,
      get: function get() {
        return _index.isIntrospectionType;
      }
    });
    Object.defineProperty(exports, "isSpecifiedDirective", {
      enumerable: true,
      get: function get() {
        return _index.isSpecifiedDirective;
      }
    });
    Object.defineProperty(exports, "assertSchema", {
      enumerable: true,
      get: function get() {
        return _index.assertSchema;
      }
    });
    Object.defineProperty(exports, "assertDirective", {
      enumerable: true,
      get: function get() {
        return _index.assertDirective;
      }
    });
    Object.defineProperty(exports, "assertType", {
      enumerable: true,
      get: function get() {
        return _index.assertType;
      }
    });
    Object.defineProperty(exports, "assertScalarType", {
      enumerable: true,
      get: function get() {
        return _index.assertScalarType;
      }
    });
    Object.defineProperty(exports, "assertObjectType", {
      enumerable: true,
      get: function get() {
        return _index.assertObjectType;
      }
    });
    Object.defineProperty(exports, "assertInterfaceType", {
      enumerable: true,
      get: function get() {
        return _index.assertInterfaceType;
      }
    });
    Object.defineProperty(exports, "assertUnionType", {
      enumerable: true,
      get: function get() {
        return _index.assertUnionType;
      }
    });
    Object.defineProperty(exports, "assertEnumType", {
      enumerable: true,
      get: function get() {
        return _index.assertEnumType;
      }
    });
    Object.defineProperty(exports, "assertInputObjectType", {
      enumerable: true,
      get: function get() {
        return _index.assertInputObjectType;
      }
    });
    Object.defineProperty(exports, "assertListType", {
      enumerable: true,
      get: function get() {
        return _index.assertListType;
      }
    });
    Object.defineProperty(exports, "assertNonNullType", {
      enumerable: true,
      get: function get() {
        return _index.assertNonNullType;
      }
    });
    Object.defineProperty(exports, "assertInputType", {
      enumerable: true,
      get: function get() {
        return _index.assertInputType;
      }
    });
    Object.defineProperty(exports, "assertOutputType", {
      enumerable: true,
      get: function get() {
        return _index.assertOutputType;
      }
    });
    Object.defineProperty(exports, "assertLeafType", {
      enumerable: true,
      get: function get() {
        return _index.assertLeafType;
      }
    });
    Object.defineProperty(exports, "assertCompositeType", {
      enumerable: true,
      get: function get() {
        return _index.assertCompositeType;
      }
    });
    Object.defineProperty(exports, "assertAbstractType", {
      enumerable: true,
      get: function get() {
        return _index.assertAbstractType;
      }
    });
    Object.defineProperty(exports, "assertWrappingType", {
      enumerable: true,
      get: function get() {
        return _index.assertWrappingType;
      }
    });
    Object.defineProperty(exports, "assertNullableType", {
      enumerable: true,
      get: function get() {
        return _index.assertNullableType;
      }
    });
    Object.defineProperty(exports, "assertNamedType", {
      enumerable: true,
      get: function get() {
        return _index.assertNamedType;
      }
    });
    Object.defineProperty(exports, "getNullableType", {
      enumerable: true,
      get: function get() {
        return _index.getNullableType;
      }
    });
    Object.defineProperty(exports, "getNamedType", {
      enumerable: true,
      get: function get() {
        return _index.getNamedType;
      }
    });
    Object.defineProperty(exports, "validateSchema", {
      enumerable: true,
      get: function get() {
        return _index.validateSchema;
      }
    });
    Object.defineProperty(exports, "assertValidSchema", {
      enumerable: true,
      get: function get() {
        return _index.assertValidSchema;
      }
    });
    Object.defineProperty(exports, "Token", {
      enumerable: true,
      get: function get() {
        return _index2.Token;
      }
    });
    Object.defineProperty(exports, "Source", {
      enumerable: true,
      get: function get() {
        return _index2.Source;
      }
    });
    Object.defineProperty(exports, "Location", {
      enumerable: true,
      get: function get() {
        return _index2.Location;
      }
    });
    Object.defineProperty(exports, "getLocation", {
      enumerable: true,
      get: function get() {
        return _index2.getLocation;
      }
    });
    Object.defineProperty(exports, "printLocation", {
      enumerable: true,
      get: function get() {
        return _index2.printLocation;
      }
    });
    Object.defineProperty(exports, "printSourceLocation", {
      enumerable: true,
      get: function get() {
        return _index2.printSourceLocation;
      }
    });
    Object.defineProperty(exports, "Lexer", {
      enumerable: true,
      get: function get() {
        return _index2.Lexer;
      }
    });
    Object.defineProperty(exports, "TokenKind", {
      enumerable: true,
      get: function get() {
        return _index2.TokenKind;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _index2.parse;
      }
    });
    Object.defineProperty(exports, "parseValue", {
      enumerable: true,
      get: function get() {
        return _index2.parseValue;
      }
    });
    Object.defineProperty(exports, "parseType", {
      enumerable: true,
      get: function get() {
        return _index2.parseType;
      }
    });
    Object.defineProperty(exports, "print", {
      enumerable: true,
      get: function get() {
        return _index2.print;
      }
    });
    Object.defineProperty(exports, "visit", {
      enumerable: true,
      get: function get() {
        return _index2.visit;
      }
    });
    Object.defineProperty(exports, "visitInParallel", {
      enumerable: true,
      get: function get() {
        return _index2.visitInParallel;
      }
    });
    Object.defineProperty(exports, "getVisitFn", {
      enumerable: true,
      get: function get() {
        return _index2.getVisitFn;
      }
    });
    Object.defineProperty(exports, "BREAK", {
      enumerable: true,
      get: function get() {
        return _index2.BREAK;
      }
    });
    Object.defineProperty(exports, "Kind", {
      enumerable: true,
      get: function get() {
        return _index2.Kind;
      }
    });
    Object.defineProperty(exports, "DirectiveLocation", {
      enumerable: true,
      get: function get() {
        return _index2.DirectiveLocation;
      }
    });
    Object.defineProperty(exports, "isDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isExecutableDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isSelectionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isSelectionNode;
      }
    });
    Object.defineProperty(exports, "isValueNode", {
      enumerable: true,
      get: function get() {
        return _index2.isValueNode;
      }
    });
    Object.defineProperty(exports, "isTypeNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeSystemDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeDefinitionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeDefinitionNode;
      }
    });
    Object.defineProperty(exports, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeSystemExtensionNode;
      }
    });
    Object.defineProperty(exports, "isTypeExtensionNode", {
      enumerable: true,
      get: function get() {
        return _index2.isTypeExtensionNode;
      }
    });
    Object.defineProperty(exports, "execute", {
      enumerable: true,
      get: function get() {
        return _index3.execute;
      }
    });
    Object.defineProperty(exports, "executeSync", {
      enumerable: true,
      get: function get() {
        return _index3.executeSync;
      }
    });
    Object.defineProperty(exports, "defaultFieldResolver", {
      enumerable: true,
      get: function get() {
        return _index3.defaultFieldResolver;
      }
    });
    Object.defineProperty(exports, "defaultTypeResolver", {
      enumerable: true,
      get: function get() {
        return _index3.defaultTypeResolver;
      }
    });
    Object.defineProperty(exports, "responsePathAsArray", {
      enumerable: true,
      get: function get() {
        return _index3.responsePathAsArray;
      }
    });
    Object.defineProperty(exports, "getDirectiveValues", {
      enumerable: true,
      get: function get() {
        return _index3.getDirectiveValues;
      }
    });
    Object.defineProperty(exports, "subscribe", {
      enumerable: true,
      get: function get() {
        return _index4.subscribe;
      }
    });
    Object.defineProperty(exports, "createSourceEventStream", {
      enumerable: true,
      get: function get() {
        return _index4.createSourceEventStream;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _index5.validate;
      }
    });
    Object.defineProperty(exports, "ValidationContext", {
      enumerable: true,
      get: function get() {
        return _index5.ValidationContext;
      }
    });
    Object.defineProperty(exports, "specifiedRules", {
      enumerable: true,
      get: function get() {
        return _index5.specifiedRules;
      }
    });
    Object.defineProperty(exports, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function get() {
        return _index5.ExecutableDefinitionsRule;
      }
    });
    Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _index5.FieldsOnCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function get() {
        return _index5.FragmentsOnCompositeTypesRule;
      }
    });
    Object.defineProperty(exports, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownDirectivesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownDirectivesRule;
      }
    });
    Object.defineProperty(exports, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "KnownTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.KnownTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function get() {
        return _index5.LoneAnonymousOperationRule;
      }
    });
    Object.defineProperty(exports, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoFragmentCyclesRule;
      }
    });
    Object.defineProperty(exports, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoUndefinedVariablesRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoUnusedFragmentsRule;
      }
    });
    Object.defineProperty(exports, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoUnusedVariablesRule;
      }
    });
    Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function get() {
        return _index5.OverlappingFieldsCanBeMergedRule;
      }
    });
    Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function get() {
        return _index5.PossibleFragmentSpreadsRule;
      }
    });
    Object.defineProperty(exports, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function get() {
        return _index5.ProvidedRequiredArgumentsRule;
      }
    });
    Object.defineProperty(exports, "ScalarLeafsRule", {
      enumerable: true,
      get: function get() {
        return _index5.ScalarLeafsRule;
      }
    });
    Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function get() {
        return _index5.SingleFieldSubscriptionsRule;
      }
    });
    Object.defineProperty(exports, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueArgumentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueDirectivesPerLocationRule;
      }
    });
    Object.defineProperty(exports, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueFragmentNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueInputFieldNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueOperationNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueVariableNamesRule;
      }
    });
    Object.defineProperty(exports, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function get() {
        return _index5.ValuesOfCorrectTypeRule;
      }
    });
    Object.defineProperty(exports, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function get() {
        return _index5.VariablesAreInputTypesRule;
      }
    });
    Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function get() {
        return _index5.VariablesInAllowedPositionRule;
      }
    });
    Object.defineProperty(exports, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function get() {
        return _index5.LoneSchemaDefinitionRule;
      }
    });
    Object.defineProperty(exports, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueOperationTypesRule;
      }
    });
    Object.defineProperty(exports, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueTypeNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueEnumValueNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueFieldDefinitionNamesRule;
      }
    });
    Object.defineProperty(exports, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function get() {
        return _index5.UniqueDirectiveNamesRule;
      }
    });
    Object.defineProperty(exports, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function get() {
        return _index5.PossibleTypeExtensionsRule;
      }
    });
    Object.defineProperty(exports, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoDeprecatedCustomRule;
      }
    });
    Object.defineProperty(exports, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function get() {
        return _index5.NoSchemaIntrospectionCustomRule;
      }
    });
    Object.defineProperty(exports, "GraphQLError", {
      enumerable: true,
      get: function get() {
        return _index6.GraphQLError;
      }
    });
    Object.defineProperty(exports, "syntaxError", {
      enumerable: true,
      get: function get() {
        return _index6.syntaxError;
      }
    });
    Object.defineProperty(exports, "locatedError", {
      enumerable: true,
      get: function get() {
        return _index6.locatedError;
      }
    });
    Object.defineProperty(exports, "printError", {
      enumerable: true,
      get: function get() {
        return _index6.printError;
      }
    });
    Object.defineProperty(exports, "formatError", {
      enumerable: true,
      get: function get() {
        return _index6.formatError;
      }
    });
    Object.defineProperty(exports, "getIntrospectionQuery", {
      enumerable: true,
      get: function get() {
        return _index7.getIntrospectionQuery;
      }
    });
    Object.defineProperty(exports, "getOperationAST", {
      enumerable: true,
      get: function get() {
        return _index7.getOperationAST;
      }
    });
    Object.defineProperty(exports, "getOperationRootType", {
      enumerable: true,
      get: function get() {
        return _index7.getOperationRootType;
      }
    });
    Object.defineProperty(exports, "introspectionFromSchema", {
      enumerable: true,
      get: function get() {
        return _index7.introspectionFromSchema;
      }
    });
    Object.defineProperty(exports, "buildClientSchema", {
      enumerable: true,
      get: function get() {
        return _index7.buildClientSchema;
      }
    });
    Object.defineProperty(exports, "buildASTSchema", {
      enumerable: true,
      get: function get() {
        return _index7.buildASTSchema;
      }
    });
    Object.defineProperty(exports, "buildSchema", {
      enumerable: true,
      get: function get() {
        return _index7.buildSchema;
      }
    });
    Object.defineProperty(exports, "getDescription", {
      enumerable: true,
      get: function get() {
        return _index7.getDescription;
      }
    });
    Object.defineProperty(exports, "extendSchema", {
      enumerable: true,
      get: function get() {
        return _index7.extendSchema;
      }
    });
    Object.defineProperty(exports, "lexicographicSortSchema", {
      enumerable: true,
      get: function get() {
        return _index7.lexicographicSortSchema;
      }
    });
    Object.defineProperty(exports, "printSchema", {
      enumerable: true,
      get: function get() {
        return _index7.printSchema;
      }
    });
    Object.defineProperty(exports, "printType", {
      enumerable: true,
      get: function get() {
        return _index7.printType;
      }
    });
    Object.defineProperty(exports, "printIntrospectionSchema", {
      enumerable: true,
      get: function get() {
        return _index7.printIntrospectionSchema;
      }
    });
    Object.defineProperty(exports, "typeFromAST", {
      enumerable: true,
      get: function get() {
        return _index7.typeFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromAST", {
      enumerable: true,
      get: function get() {
        return _index7.valueFromAST;
      }
    });
    Object.defineProperty(exports, "valueFromASTUntyped", {
      enumerable: true,
      get: function get() {
        return _index7.valueFromASTUntyped;
      }
    });
    Object.defineProperty(exports, "astFromValue", {
      enumerable: true,
      get: function get() {
        return _index7.astFromValue;
      }
    });
    Object.defineProperty(exports, "TypeInfo", {
      enumerable: true,
      get: function get() {
        return _index7.TypeInfo;
      }
    });
    Object.defineProperty(exports, "visitWithTypeInfo", {
      enumerable: true,
      get: function get() {
        return _index7.visitWithTypeInfo;
      }
    });
    Object.defineProperty(exports, "coerceInputValue", {
      enumerable: true,
      get: function get() {
        return _index7.coerceInputValue;
      }
    });
    Object.defineProperty(exports, "concatAST", {
      enumerable: true,
      get: function get() {
        return _index7.concatAST;
      }
    });
    Object.defineProperty(exports, "separateOperations", {
      enumerable: true,
      get: function get() {
        return _index7.separateOperations;
      }
    });
    Object.defineProperty(exports, "stripIgnoredCharacters", {
      enumerable: true,
      get: function get() {
        return _index7.stripIgnoredCharacters;
      }
    });
    Object.defineProperty(exports, "isEqualType", {
      enumerable: true,
      get: function get() {
        return _index7.isEqualType;
      }
    });
    Object.defineProperty(exports, "isTypeSubTypeOf", {
      enumerable: true,
      get: function get() {
        return _index7.isTypeSubTypeOf;
      }
    });
    Object.defineProperty(exports, "doTypesOverlap", {
      enumerable: true,
      get: function get() {
        return _index7.doTypesOverlap;
      }
    });
    Object.defineProperty(exports, "assertValidName", {
      enumerable: true,
      get: function get() {
        return _index7.assertValidName;
      }
    });
    Object.defineProperty(exports, "isValidNameError", {
      enumerable: true,
      get: function get() {
        return _index7.isValidNameError;
      }
    });
    Object.defineProperty(exports, "BreakingChangeType", {
      enumerable: true,
      get: function get() {
        return _index7.BreakingChangeType;
      }
    });
    Object.defineProperty(exports, "DangerousChangeType", {
      enumerable: true,
      get: function get() {
        return _index7.DangerousChangeType;
      }
    });
    Object.defineProperty(exports, "findBreakingChanges", {
      enumerable: true,
      get: function get() {
        return _index7.findBreakingChanges;
      }
    });
    Object.defineProperty(exports, "findDangerousChanges", {
      enumerable: true,
      get: function get() {
        return _index7.findDangerousChanges;
      }
    });
    Object.defineProperty(exports, "findDeprecatedUsages", {
      enumerable: true,
      get: function get() {
        return _index7.findDeprecatedUsages;
      }
    });
    var _version = require_version();
    var _graphql = require_graphql();
    var _index = require_type();
    var _index2 = require_language();
    var _index3 = require_execution();
    var _index4 = require_subscription();
    var _index5 = require_validation();
    var _index6 = require_error();
    var _index7 = require_utilities();
  }
});

// node_modules/zen-observable/lib/Observable.js
var require_Observable = __commonJS({
  "node_modules/zen-observable/lib/Observable.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Observable = void 0;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var hasSymbols = function() {
      return typeof Symbol === "function";
    };
    var hasSymbol = function(name) {
      return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function(name) {
      return hasSymbol(name) ? Symbol[name] : "@@" + name;
    };
    if (hasSymbols() && !hasSymbol("observable")) {
      Symbol.observable = Symbol("observable");
    }
    var SymbolIterator = getSymbol("iterator");
    var SymbolObservable = getSymbol("observable");
    var SymbolSpecies = getSymbol("species");
    function getMethod(obj, key) {
      var value = obj[key];
      if (value == null)
        return void 0;
      if (typeof value !== "function")
        throw new TypeError(value + " is not a function");
      return value;
    }
    function getSpecies(obj) {
      var ctor = obj.constructor;
      if (ctor !== void 0) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) {
          ctor = void 0;
        }
      }
      return ctor !== void 0 ? ctor : Observable;
    }
    function isObservable(x) {
      return x instanceof Observable;
    }
    function hostReportError(e) {
      if (hostReportError.log) {
        hostReportError.log(e);
      } else {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function enqueue(fn) {
      Promise.resolve().then(function() {
        try {
          fn();
        } catch (e) {
          hostReportError(e);
        }
      });
    }
    function cleanupSubscription(subscription) {
      var cleanup = subscription._cleanup;
      if (cleanup === void 0)
        return;
      subscription._cleanup = void 0;
      if (!cleanup) {
        return;
      }
      try {
        if (typeof cleanup === "function") {
          cleanup();
        } else {
          var unsubscribe = getMethod(cleanup, "unsubscribe");
          if (unsubscribe) {
            unsubscribe.call(cleanup);
          }
        }
      } catch (e) {
        hostReportError(e);
      }
    }
    function closeSubscription(subscription) {
      subscription._observer = void 0;
      subscription._queue = void 0;
      subscription._state = "closed";
    }
    function flushSubscription(subscription) {
      var queue = subscription._queue;
      if (!queue) {
        return;
      }
      subscription._queue = void 0;
      subscription._state = "ready";
      for (var i = 0; i < queue.length; ++i) {
        notifySubscription(subscription, queue[i].type, queue[i].value);
        if (subscription._state === "closed")
          break;
      }
    }
    function notifySubscription(subscription, type, value) {
      subscription._state = "running";
      var observer = subscription._observer;
      try {
        var m = getMethod(observer, type);
        switch (type) {
          case "next":
            if (m)
              m.call(observer, value);
            break;
          case "error":
            closeSubscription(subscription);
            if (m)
              m.call(observer, value);
            else
              throw value;
            break;
          case "complete":
            closeSubscription(subscription);
            if (m)
              m.call(observer);
            break;
        }
      } catch (e) {
        hostReportError(e);
      }
      if (subscription._state === "closed")
        cleanupSubscription(subscription);
      else if (subscription._state === "running")
        subscription._state = "ready";
    }
    function onNotify(subscription, type, value) {
      if (subscription._state === "closed")
        return;
      if (subscription._state === "buffering") {
        subscription._queue.push({
          type,
          value
        });
        return;
      }
      if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [{
          type,
          value
        }];
        enqueue(function() {
          return flushSubscription(subscription);
        });
        return;
      }
      notifySubscription(subscription, type, value);
    }
    var Subscription = /* @__PURE__ */ function() {
      function Subscription2(observer, subscriber) {
        _classCallCheck(this, Subscription2);
        this._cleanup = void 0;
        this._observer = observer;
        this._queue = void 0;
        this._state = "initializing";
        var subscriptionObserver = new SubscriptionObserver(this);
        try {
          this._cleanup = subscriber.call(void 0, subscriptionObserver);
        } catch (e) {
          subscriptionObserver.error(e);
        }
        if (this._state === "initializing")
          this._state = "ready";
      }
      _createClass(Subscription2, [{
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
          }
        }
      }, {
        key: "closed",
        get: function() {
          return this._state === "closed";
        }
      }]);
      return Subscription2;
    }();
    var SubscriptionObserver = /* @__PURE__ */ function() {
      function SubscriptionObserver2(subscription) {
        _classCallCheck(this, SubscriptionObserver2);
        this._subscription = subscription;
      }
      _createClass(SubscriptionObserver2, [{
        key: "next",
        value: function next(value) {
          onNotify(this._subscription, "next", value);
        }
      }, {
        key: "error",
        value: function error3(value) {
          onNotify(this._subscription, "error", value);
        }
      }, {
        key: "complete",
        value: function complete() {
          onNotify(this._subscription, "complete");
        }
      }, {
        key: "closed",
        get: function() {
          return this._subscription._state === "closed";
        }
      }]);
      return SubscriptionObserver2;
    }();
    var Observable = /* @__PURE__ */ function() {
      function Observable2(subscriber) {
        _classCallCheck(this, Observable2);
        if (!(this instanceof Observable2))
          throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber !== "function")
          throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber;
      }
      _createClass(Observable2, [{
        key: "subscribe",
        value: function subscribe2(observer) {
          if (typeof observer !== "object" || observer === null) {
            observer = {
              next: observer,
              error: arguments[1],
              complete: arguments[2]
            };
          }
          return new Subscription(observer, this._subscriber);
        }
      }, {
        key: "forEach",
        value: function forEach(fn) {
          var _this = this;
          return new Promise(function(resolve2, reject) {
            if (typeof fn !== "function") {
              reject(new TypeError(fn + " is not a function"));
              return;
            }
            function done() {
              subscription.unsubscribe();
              resolve2();
            }
            var subscription = _this.subscribe({
              next: function(value) {
                try {
                  fn(value, done);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve2
            });
          });
        }
      }, {
        key: "map",
        value: function map(fn) {
          var _this2 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            return _this2.subscribe({
              next: function(value) {
                try {
                  value = fn(value);
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "filter",
        value: function filter(fn) {
          var _this3 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            return _this3.subscribe({
              next: function(value) {
                try {
                  if (!fn(value))
                    return;
                } catch (e) {
                  return observer.error(e);
                }
                observer.next(value);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "reduce",
        value: function reduce(fn) {
          var _this4 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          var hasSeed = arguments.length > 1;
          var hasValue = false;
          var seed = arguments[1];
          var acc = seed;
          return new C(function(observer) {
            return _this4.subscribe({
              next: function(value) {
                var first = !hasValue;
                hasValue = true;
                if (!first || hasSeed) {
                  try {
                    acc = fn(acc, value);
                  } catch (e) {
                    return observer.error(e);
                  }
                } else {
                  acc = value;
                }
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                if (!hasValue && !hasSeed)
                  return observer.error(new TypeError("Cannot reduce an empty sequence"));
                observer.next(acc);
                observer.complete();
              }
            });
          });
        }
      }, {
        key: "concat",
        value: function concat() {
          var _this5 = this;
          for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
            sources[_key] = arguments[_key];
          }
          var C = getSpecies(this);
          return new C(function(observer) {
            var subscription;
            var index2 = 0;
            function startNext(next) {
              subscription = next.subscribe({
                next: function(v) {
                  observer.next(v);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  if (index2 === sources.length) {
                    subscription = void 0;
                    observer.complete();
                  } else {
                    startNext(C.from(sources[index2++]));
                  }
                }
              });
            }
            startNext(_this5);
            return function() {
              if (subscription) {
                subscription.unsubscribe();
                subscription = void 0;
              }
            };
          });
        }
      }, {
        key: "flatMap",
        value: function flatMap(fn) {
          var _this6 = this;
          if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");
          var C = getSpecies(this);
          return new C(function(observer) {
            var subscriptions = [];
            var outer = _this6.subscribe({
              next: function(value) {
                if (fn) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                }
                var inner = C.from(value).subscribe({
                  next: function(value2) {
                    observer.next(value2);
                  },
                  error: function(e) {
                    observer.error(e);
                  },
                  complete: function() {
                    var i = subscriptions.indexOf(inner);
                    if (i >= 0)
                      subscriptions.splice(i, 1);
                    completeIfDone();
                  }
                });
                subscriptions.push(inner);
              },
              error: function(e) {
                observer.error(e);
              },
              complete: function() {
                completeIfDone();
              }
            });
            function completeIfDone() {
              if (outer.closed && subscriptions.length === 0)
                observer.complete();
            }
            return function() {
              subscriptions.forEach(function(s2) {
                return s2.unsubscribe();
              });
              outer.unsubscribe();
            };
          });
        }
      }, {
        key: SymbolObservable,
        value: function() {
          return this;
        }
      }], [{
        key: "from",
        value: function from(x) {
          var C = typeof this === "function" ? this : Observable2;
          if (x == null)
            throw new TypeError(x + " is not an object");
          var method = getMethod(x, SymbolObservable);
          if (method) {
            var observable = method.call(x);
            if (Object(observable) !== observable)
              throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C)
              return observable;
            return new C(function(observer) {
              return observable.subscribe(observer);
            });
          }
          if (hasSymbol("iterator")) {
            method = getMethod(x, SymbolIterator);
            if (method) {
              return new C(function(observer) {
                enqueue(function() {
                  if (observer.closed)
                    return;
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var _item = _step.value;
                      observer.next(_item);
                      if (observer.closed)
                        return;
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return != null) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                  observer.complete();
                });
              });
            }
          }
          if (Array.isArray(x)) {
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed)
                  return;
                for (var i = 0; i < x.length; ++i) {
                  observer.next(x[i]);
                  if (observer.closed)
                    return;
                }
                observer.complete();
              });
            });
          }
          throw new TypeError(x + " is not observable");
        }
      }, {
        key: "of",
        value: function of() {
          for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            items[_key2] = arguments[_key2];
          }
          var C = typeof this === "function" ? this : Observable2;
          return new C(function(observer) {
            enqueue(function() {
              if (observer.closed)
                return;
              for (var i = 0; i < items.length; ++i) {
                observer.next(items[i]);
                if (observer.closed)
                  return;
              }
              observer.complete();
            });
          });
        }
      }, {
        key: SymbolSpecies,
        get: function() {
          return this;
        }
      }]);
      return Observable2;
    }();
    exports.Observable = Observable;
    if (hasSymbols()) {
      Object.defineProperty(Observable, Symbol("extensions"), {
        value: {
          symbol: SymbolObservable,
          hostReportError
        },
        configurable: true
      });
    }
  }
});

// node_modules/zen-observable/index.js
var require_zen_observable = __commonJS({
  "node_modules/zen-observable/index.js"(exports, module2) {
    init_shims();
    module2.exports = require_Observable().Observable;
  }
});

// node_modules/zen-observable-ts/index.js
var require_zen_observable_ts = __commonJS({
  "node_modules/zen-observable-ts/index.js"(exports) {
    init_shims();
    exports.Observable = require_zen_observable();
  }
});

// node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          if (typeof _Symbol["for"] === "function") {
            result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          } else {
            result = _Symbol("https://github.com/benlesh/symbol-observable");
          }
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/symbol-observable/lib/index.js
var require_lib = __commonJS({
  "node_modules/symbol-observable/lib/index.js"(exports, module2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _ponyfill = require_ponyfill();
    var _ponyfill2 = _interopRequireDefault(_ponyfill);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var root;
    if (typeof self !== "undefined") {
      root = self;
    } else if (typeof window !== "undefined") {
      root = window;
    } else if (typeof global !== "undefined") {
      root = global;
    } else if (typeof module2 !== "undefined") {
      root = module2;
    } else {
      root = Function("return this")();
    }
    var result = (0, _ponyfill2["default"])(root);
    exports["default"] = result;
  }
});

// node_modules/@apollo/client/utilities/utilities.cjs.js
var require_utilities_cjs = __commonJS({
  "node_modules/@apollo/client/utilities/utilities.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tsInvariant = require_invariant();
    var process$1 = require_main();
    var graphql = require_graphql2();
    var tslib = require_tslib();
    var zenObservableTs = require_zen_observable_ts();
    require_lib();
    function maybe(thunk) {
      try {
        return thunk();
      } catch (_a) {
      }
    }
    var global$1 = maybe(function() {
      return globalThis;
    }) || maybe(function() {
      return window;
    }) || maybe(function() {
      return self;
    }) || maybe(function() {
      return global;
    }) || maybe(function() {
      return Function("return this")();
    });
    var __ = "__";
    var GLOBAL_KEY = [__, __].join("DEV");
    function getDEV() {
      try {
        return Boolean(__DEV__);
      } catch (_a) {
        Object.defineProperty(global$1, GLOBAL_KEY, {
          value: maybe(function() {
            return process.env.NODE_ENV;
          }) !== "production",
          enumerable: false,
          configurable: true,
          writable: true
        });
        return global$1[GLOBAL_KEY];
      }
    }
    var DEV = getDEV();
    function removeTemporaryGlobals() {
      graphql.isType(null);
      return process$1.remove();
    }
    removeTemporaryGlobals();
    function shouldInclude(_a, variables) {
      var directives = _a.directives;
      if (!directives || !directives.length) {
        return true;
      }
      return getInclusionDirectives(directives).every(function(_a2) {
        var directive = _a2.directive, ifArgument = _a2.ifArgument;
        var evaledValue = false;
        if (ifArgument.value.kind === "Variable") {
          evaledValue = variables && variables[ifArgument.value.name.value];
          __DEV__ ? tsInvariant.invariant(evaledValue !== void 0, "Invalid variable referenced in @" + directive.name.value + " directive.") : tsInvariant.invariant(evaledValue !== void 0, 43);
        } else {
          evaledValue = ifArgument.value.value;
        }
        return directive.name.value === "skip" ? !evaledValue : evaledValue;
      });
    }
    function getDirectiveNames(root) {
      var names = [];
      graphql.visit(root, {
        Directive: function(node) {
          names.push(node.name.value);
        }
      });
      return names;
    }
    function hasDirectives(names, root) {
      return getDirectiveNames(root).some(function(name) {
        return names.indexOf(name) > -1;
      });
    }
    function hasClientExports(document2) {
      return document2 && hasDirectives(["client"], document2) && hasDirectives(["export"], document2);
    }
    function isInclusionDirective(_a) {
      var value = _a.name.value;
      return value === "skip" || value === "include";
    }
    function getInclusionDirectives(directives) {
      var result = [];
      if (directives && directives.length) {
        directives.forEach(function(directive) {
          if (!isInclusionDirective(directive))
            return;
          var directiveArguments = directive.arguments;
          var directiveName = directive.name.value;
          __DEV__ ? tsInvariant.invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @" + directiveName + " directive.") : tsInvariant.invariant(directiveArguments && directiveArguments.length === 1, 44);
          var ifArgument = directiveArguments[0];
          __DEV__ ? tsInvariant.invariant(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @" + directiveName + " directive.") : tsInvariant.invariant(ifArgument.name && ifArgument.name.value === "if", 45);
          var ifValue = ifArgument.value;
          __DEV__ ? tsInvariant.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @" + directiveName + " directive must be a variable or a boolean value.") : tsInvariant.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 46);
          result.push({ directive, ifArgument });
        });
      }
      return result;
    }
    function getFragmentQueryDocument(document2, fragmentName) {
      var actualFragmentName = fragmentName;
      var fragments = [];
      document2.definitions.forEach(function(definition) {
        if (definition.kind === "OperationDefinition") {
          throw __DEV__ ? new tsInvariant.InvariantError("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : "") + ". No operations are allowed when using a fragment as a query. Only fragments are allowed.") : new tsInvariant.InvariantError(47);
        }
        if (definition.kind === "FragmentDefinition") {
          fragments.push(definition);
        }
      });
      if (typeof actualFragmentName === "undefined") {
        __DEV__ ? tsInvariant.invariant(fragments.length === 1, "Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.") : tsInvariant.invariant(fragments.length === 1, 48);
        actualFragmentName = fragments[0].name.value;
      }
      var query = tslib.__assign(tslib.__assign({}, document2), { definitions: tslib.__spreadArray([
        {
          kind: "OperationDefinition",
          operation: "query",
          selectionSet: {
            kind: "SelectionSet",
            selections: [
              {
                kind: "FragmentSpread",
                name: {
                  kind: "Name",
                  value: actualFragmentName
                }
              }
            ]
          }
        }
      ], document2.definitions) });
      return query;
    }
    function createFragmentMap(fragments) {
      if (fragments === void 0) {
        fragments = [];
      }
      var symTable = {};
      fragments.forEach(function(fragment) {
        symTable[fragment.name.value] = fragment;
      });
      return symTable;
    }
    function getFragmentFromSelection(selection, fragmentMap) {
      switch (selection.kind) {
        case "InlineFragment":
          return selection;
        case "FragmentSpread": {
          var fragment = fragmentMap && fragmentMap[selection.name.value];
          __DEV__ ? tsInvariant.invariant(fragment, "No fragment named " + selection.name.value + ".") : tsInvariant.invariant(fragment, 49);
          return fragment;
        }
        default:
          return null;
      }
    }
    function isNonNullObject(obj) {
      return obj !== null && typeof obj === "object";
    }
    function makeReference(id) {
      return { __ref: String(id) };
    }
    function isReference(obj) {
      return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
    }
    function isDocumentNode(value) {
      return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
    }
    function isStringValue(value) {
      return value.kind === "StringValue";
    }
    function isBooleanValue(value) {
      return value.kind === "BooleanValue";
    }
    function isIntValue(value) {
      return value.kind === "IntValue";
    }
    function isFloatValue(value) {
      return value.kind === "FloatValue";
    }
    function isVariable(value) {
      return value.kind === "Variable";
    }
    function isObjectValue(value) {
      return value.kind === "ObjectValue";
    }
    function isListValue(value) {
      return value.kind === "ListValue";
    }
    function isEnumValue(value) {
      return value.kind === "EnumValue";
    }
    function isNullValue(value) {
      return value.kind === "NullValue";
    }
    function valueToObjectRepresentation(argObj, name, value, variables) {
      if (isIntValue(value) || isFloatValue(value)) {
        argObj[name.value] = Number(value.value);
      } else if (isBooleanValue(value) || isStringValue(value)) {
        argObj[name.value] = value.value;
      } else if (isObjectValue(value)) {
        var nestedArgObj_1 = {};
        value.fields.map(function(obj) {
          return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
        });
        argObj[name.value] = nestedArgObj_1;
      } else if (isVariable(value)) {
        var variableValue = (variables || {})[value.name.value];
        argObj[name.value] = variableValue;
      } else if (isListValue(value)) {
        argObj[name.value] = value.values.map(function(listValue) {
          var nestedArgArrayObj = {};
          valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
          return nestedArgArrayObj[name.value];
        });
      } else if (isEnumValue(value)) {
        argObj[name.value] = value.value;
      } else if (isNullValue(value)) {
        argObj[name.value] = null;
      } else {
        throw __DEV__ ? new tsInvariant.InvariantError('The inline argument "' + name.value + '" of kind "' + value.kind + '"is not supported. Use variables instead of inline arguments to overcome this limitation.') : new tsInvariant.InvariantError(58);
      }
    }
    function storeKeyNameFromField(field, variables) {
      var directivesObj = null;
      if (field.directives) {
        directivesObj = {};
        field.directives.forEach(function(directive) {
          directivesObj[directive.name.value] = {};
          if (directive.arguments) {
            directive.arguments.forEach(function(_a) {
              var name = _a.name, value = _a.value;
              return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
            });
          }
        });
      }
      var argObj = null;
      if (field.arguments && field.arguments.length) {
        argObj = {};
        field.arguments.forEach(function(_a) {
          var name = _a.name, value = _a.value;
          return valueToObjectRepresentation(argObj, name, value, variables);
        });
      }
      return getStoreKeyName(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES = [
      "connection",
      "include",
      "skip",
      "client",
      "rest",
      "export"
    ];
    var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
      if (args && directives && directives["connection"] && directives["connection"]["key"]) {
        if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
          var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
          filterKeys.sort();
          var filteredArgs_1 = {};
          filterKeys.forEach(function(key) {
            filteredArgs_1[key] = args[key];
          });
          return directives["connection"]["key"] + "(" + stringify(filteredArgs_1) + ")";
        } else {
          return directives["connection"]["key"];
        }
      }
      var completeFieldName = fieldName;
      if (args) {
        var stringifiedArgs = stringify(args);
        completeFieldName += "(" + stringifiedArgs + ")";
      }
      if (directives) {
        Object.keys(directives).forEach(function(key) {
          if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
            return;
          if (directives[key] && Object.keys(directives[key]).length) {
            completeFieldName += "@" + key + "(" + stringify(directives[key]) + ")";
          } else {
            completeFieldName += "@" + key;
          }
        });
      }
      return completeFieldName;
    }, {
      setStringify: function(s2) {
        var previous = stringify;
        stringify = s2;
        return previous;
      }
    });
    var stringify = function defaultStringify(value) {
      return JSON.stringify(value, stringifyReplacer);
    };
    function stringifyReplacer(_key, value) {
      if (isNonNullObject(value) && !Array.isArray(value)) {
        value = Object.keys(value).sort().reduce(function(copy, key) {
          copy[key] = value[key];
          return copy;
        }, {});
      }
      return value;
    }
    function argumentsObjectFromField(field, variables) {
      if (field.arguments && field.arguments.length) {
        var argObj_1 = {};
        field.arguments.forEach(function(_a) {
          var name = _a.name, value = _a.value;
          return valueToObjectRepresentation(argObj_1, name, value, variables);
        });
        return argObj_1;
      }
      return null;
    }
    function resultKeyNameFromField(field) {
      return field.alias ? field.alias.value : field.name.value;
    }
    function getTypenameFromResult(result, selectionSet, fragmentMap) {
      if (typeof result.__typename === "string") {
        return result.__typename;
      }
      for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
        var selection = _a[_i];
        if (isField(selection)) {
          if (selection.name.value === "__typename") {
            return result[resultKeyNameFromField(selection)];
          }
        } else {
          var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
          if (typeof typename === "string") {
            return typename;
          }
        }
      }
    }
    function isField(selection) {
      return selection.kind === "Field";
    }
    function isInlineFragment(selection) {
      return selection.kind === "InlineFragment";
    }
    function checkDocument(doc) {
      __DEV__ ? tsInvariant.invariant(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : tsInvariant.invariant(doc && doc.kind === "Document", 50);
      var operations = doc.definitions.filter(function(d2) {
        return d2.kind !== "FragmentDefinition";
      }).map(function(definition) {
        if (definition.kind !== "OperationDefinition") {
          throw __DEV__ ? new tsInvariant.InvariantError('Schema type definitions not allowed in queries. Found: "' + definition.kind + '"') : new tsInvariant.InvariantError(51);
        }
        return definition;
      });
      __DEV__ ? tsInvariant.invariant(operations.length <= 1, "Ambiguous GraphQL document: contains " + operations.length + " operations") : tsInvariant.invariant(operations.length <= 1, 52);
      return doc;
    }
    function getOperationDefinition(doc) {
      checkDocument(doc);
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition";
      })[0];
    }
    function getOperationName(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "OperationDefinition" && definition.name;
      }).map(function(x) {
        return x.name.value;
      })[0] || null;
    }
    function getFragmentDefinitions(doc) {
      return doc.definitions.filter(function(definition) {
        return definition.kind === "FragmentDefinition";
      });
    }
    function getQueryDefinition(doc) {
      var queryDef = getOperationDefinition(doc);
      __DEV__ ? tsInvariant.invariant(queryDef && queryDef.operation === "query", "Must contain a query definition.") : tsInvariant.invariant(queryDef && queryDef.operation === "query", 53);
      return queryDef;
    }
    function getFragmentDefinition(doc) {
      __DEV__ ? tsInvariant.invariant(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : tsInvariant.invariant(doc.kind === "Document", 54);
      __DEV__ ? tsInvariant.invariant(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : tsInvariant.invariant(doc.definitions.length <= 1, 55);
      var fragmentDef = doc.definitions[0];
      __DEV__ ? tsInvariant.invariant(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : tsInvariant.invariant(fragmentDef.kind === "FragmentDefinition", 56);
      return fragmentDef;
    }
    function getMainDefinition2(queryDoc) {
      checkDocument(queryDoc);
      var fragmentDefinition;
      for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
        var definition = _a[_i];
        if (definition.kind === "OperationDefinition") {
          var operation = definition.operation;
          if (operation === "query" || operation === "mutation" || operation === "subscription") {
            return definition;
          }
        }
        if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
          fragmentDefinition = definition;
        }
      }
      if (fragmentDefinition) {
        return fragmentDefinition;
      }
      throw __DEV__ ? new tsInvariant.InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new tsInvariant.InvariantError(57);
    }
    function getDefaultValues(definition) {
      var defaultValues = Object.create(null);
      var defs = definition && definition.variableDefinitions;
      if (defs && defs.length) {
        defs.forEach(function(def) {
          if (def.defaultValue) {
            valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
          }
        });
      }
      return defaultValues;
    }
    function filterInPlace(array, test, context) {
      var target = 0;
      array.forEach(function(elem, i) {
        if (test.call(this, elem, i, array)) {
          array[target++] = elem;
        }
      }, context);
      array.length = target;
      return array;
    }
    var TYPENAME_FIELD = {
      kind: "Field",
      name: {
        kind: "Name",
        value: "__typename"
      }
    };
    function isEmpty(op, fragments) {
      return op.selectionSet.selections.every(function(selection) {
        return selection.kind === "FragmentSpread" && isEmpty(fragments[selection.name.value], fragments);
      });
    }
    function nullIfDocIsEmpty(doc) {
      return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
    }
    function getDirectiveMatcher(directives) {
      return function directiveMatcher(directive) {
        return directives.some(function(dir) {
          return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
        });
      };
    }
    function removeDirectivesFromDocument(directives, doc) {
      var variablesInUse = Object.create(null);
      var variablesToRemove = [];
      var fragmentSpreadsInUse = Object.create(null);
      var fragmentSpreadsToRemove = [];
      var modifiedDoc = nullIfDocIsEmpty(graphql.visit(doc, {
        Variable: {
          enter: function(node, _key, parent) {
            if (parent.kind !== "VariableDefinition") {
              variablesInUse[node.name.value] = true;
            }
          }
        },
        Field: {
          enter: function(node) {
            if (directives && node.directives) {
              var shouldRemoveField = directives.some(function(directive) {
                return directive.remove;
              });
              if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
                if (node.arguments) {
                  node.arguments.forEach(function(arg) {
                    if (arg.value.kind === "Variable") {
                      variablesToRemove.push({
                        name: arg.value.name.value
                      });
                    }
                  });
                }
                if (node.selectionSet) {
                  getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function(frag) {
                    fragmentSpreadsToRemove.push({
                      name: frag.name.value
                    });
                  });
                }
                return null;
              }
            }
          }
        },
        FragmentSpread: {
          enter: function(node) {
            fragmentSpreadsInUse[node.name.value] = true;
          }
        },
        Directive: {
          enter: function(node) {
            if (getDirectiveMatcher(directives)(node)) {
              return null;
            }
          }
        }
      }));
      if (modifiedDoc && filterInPlace(variablesToRemove, function(v) {
        return !!v.name && !variablesInUse[v.name];
      }).length) {
        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
      }
      if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function(fs) {
        return !!fs.name && !fragmentSpreadsInUse[fs.name];
      }).length) {
        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
      }
      return modifiedDoc;
    }
    var addTypenameToDocument = Object.assign(function(doc) {
      return graphql.visit(checkDocument(doc), {
        SelectionSet: {
          enter: function(node, _key, parent) {
            if (parent && parent.kind === "OperationDefinition") {
              return;
            }
            var selections = node.selections;
            if (!selections) {
              return;
            }
            var skip = selections.some(function(selection) {
              return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
            });
            if (skip) {
              return;
            }
            var field = parent;
            if (isField(field) && field.directives && field.directives.some(function(d2) {
              return d2.name.value === "export";
            })) {
              return;
            }
            return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections), [TYPENAME_FIELD]) });
          }
        }
      });
    }, {
      added: function(field) {
        return field === TYPENAME_FIELD;
      }
    });
    var connectionRemoveConfig = {
      test: function(directive) {
        var willRemove = directive.name.value === "connection";
        if (willRemove) {
          if (!directive.arguments || !directive.arguments.some(function(arg) {
            return arg.name.value === "key";
          })) {
            __DEV__ && tsInvariant.invariant.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
          }
        }
        return willRemove;
      }
    };
    function removeConnectionDirectiveFromDocument(doc) {
      return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
    }
    function getArgumentMatcher(config) {
      return function argumentMatcher(argument) {
        return config.some(function(aConfig) {
          return argument.value && argument.value.kind === "Variable" && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
        });
      };
    }
    function removeArgumentsFromDocument(config, doc) {
      var argMatcher = getArgumentMatcher(config);
      return nullIfDocIsEmpty(graphql.visit(doc, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
              return !config.some(function(arg) {
                return arg.name === varDef.variable.name.value;
              });
            }) : [] });
          }
        },
        Field: {
          enter: function(node) {
            var shouldRemoveField = config.some(function(argConfig) {
              return argConfig.remove;
            });
            if (shouldRemoveField) {
              var argMatchCount_1 = 0;
              if (node.arguments) {
                node.arguments.forEach(function(arg) {
                  if (argMatcher(arg)) {
                    argMatchCount_1 += 1;
                  }
                });
              }
              if (argMatchCount_1 === 1) {
                return null;
              }
            }
          }
        },
        Argument: {
          enter: function(node) {
            if (argMatcher(node)) {
              return null;
            }
          }
        }
      }));
    }
    function removeFragmentSpreadFromDocument(config, doc) {
      function enter(node) {
        if (config.some(function(def) {
          return def.name === node.name.value;
        })) {
          return null;
        }
      }
      return nullIfDocIsEmpty(graphql.visit(doc, {
        FragmentSpread: { enter },
        FragmentDefinition: { enter }
      }));
    }
    function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
      var allFragments = [];
      selectionSet.selections.forEach(function(selection) {
        if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
          getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function(frag) {
            return allFragments.push(frag);
          });
        } else if (selection.kind === "FragmentSpread") {
          allFragments.push(selection);
        }
      });
      return allFragments;
    }
    function buildQueryFromSelectionSet(document2) {
      var definition = getMainDefinition2(document2);
      var definitionOperation = definition.operation;
      if (definitionOperation === "query") {
        return document2;
      }
      var modifiedDoc = graphql.visit(document2, {
        OperationDefinition: {
          enter: function(node) {
            return tslib.__assign(tslib.__assign({}, node), { operation: "query" });
          }
        }
      });
      return modifiedDoc;
    }
    function removeClientSetsFromDocument(document2) {
      checkDocument(document2);
      var modifiedDoc = removeDirectivesFromDocument([
        {
          test: function(directive) {
            return directive.name.value === "client";
          },
          remove: true
        }
      ], document2);
      if (modifiedDoc) {
        modifiedDoc = graphql.visit(modifiedDoc, {
          FragmentDefinition: {
            enter: function(node) {
              if (node.selectionSet) {
                var isTypenameOnly = node.selectionSet.selections.every(function(selection) {
                  return isField(selection) && selection.name.value === "__typename";
                });
                if (isTypenameOnly) {
                  return null;
                }
              }
            }
          }
        });
      }
      return modifiedDoc;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function mergeDeep() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return mergeDeepArray(sources);
    }
    function mergeDeepArray(sources) {
      var target = sources[0] || {};
      var count = sources.length;
      if (count > 1) {
        var merger = new DeepMerger();
        for (var i = 1; i < count; ++i) {
          target = merger.merge(target, sources[i]);
        }
      }
      return target;
    }
    var defaultReconciler = function(target, source, property) {
      return this.merge(target[property], source[property]);
    };
    var DeepMerger = function() {
      function DeepMerger2(reconciler) {
        if (reconciler === void 0) {
          reconciler = defaultReconciler;
        }
        this.reconciler = reconciler;
        this.isObject = isNonNullObject;
        this.pastCopies = new Set();
      }
      DeepMerger2.prototype.merge = function(target, source) {
        var _this = this;
        var context = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          context[_i - 2] = arguments[_i];
        }
        if (isNonNullObject(source) && isNonNullObject(target)) {
          Object.keys(source).forEach(function(sourceKey) {
            if (hasOwnProperty.call(target, sourceKey)) {
              var targetValue = target[sourceKey];
              if (source[sourceKey] !== targetValue) {
                var result = _this.reconciler.apply(_this, tslib.__spreadArray([target, source, sourceKey], context));
                if (result !== targetValue) {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = result;
                }
              }
            } else {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = source[sourceKey];
            }
          });
          return target;
        }
        return source;
      };
      DeepMerger2.prototype.shallowCopyForMerge = function(value) {
        if (isNonNullObject(value) && !this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
        return value;
      };
      return DeepMerger2;
    }();
    function concatPagination(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming) {
          return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing), incoming) : incoming;
        }
      };
    }
    function offsetLimitPagination(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        merge: function(existing, incoming, _a) {
          var args = _a.args;
          var merged = existing ? existing.slice(0) : [];
          if (args) {
            var _b = args.offset, offset = _b === void 0 ? 0 : _b;
            for (var i = 0; i < incoming.length; ++i) {
              merged[offset + i] = incoming[i];
            }
          } else {
            merged.push.apply(merged, incoming);
          }
          return merged;
        }
      };
    }
    function relayStylePagination(keyArgs) {
      if (keyArgs === void 0) {
        keyArgs = false;
      }
      return {
        keyArgs,
        read: function(existing, _a) {
          var canRead = _a.canRead, readField = _a.readField;
          if (!existing)
            return;
          var edges = [];
          var firstEdgeCursor = "";
          var lastEdgeCursor = "";
          existing.edges.forEach(function(edge) {
            if (canRead(readField("node", edge))) {
              edges.push(edge);
              if (edge.cursor) {
                firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                lastEdgeCursor = edge.cursor || lastEdgeCursor;
              }
            }
          });
          var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
          return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), { startCursor: startCursor || firstEdgeCursor, endCursor: endCursor || lastEdgeCursor }) });
        },
        merge: function(existing, incoming, _a) {
          if (existing === void 0) {
            existing = makeEmptyData();
          }
          var args = _a.args, isReference2 = _a.isReference, readField = _a.readField;
          var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
            if (isReference2(edge = tslib.__assign({}, edge))) {
              edge.cursor = readField("cursor", edge);
            }
            return edge;
          }) : [];
          if (incoming.pageInfo) {
            var pageInfo_1 = incoming.pageInfo;
            var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
            var firstEdge = incomingEdges[0];
            var lastEdge = incomingEdges[incomingEdges.length - 1];
            if (firstEdge && startCursor) {
              firstEdge.cursor = startCursor;
            }
            if (lastEdge && endCursor) {
              lastEdge.cursor = endCursor;
            }
            var firstCursor = firstEdge && firstEdge.cursor;
            if (firstCursor && !startCursor) {
              incoming = mergeDeep(incoming, {
                pageInfo: {
                  startCursor: firstCursor
                }
              });
            }
            var lastCursor = lastEdge && lastEdge.cursor;
            if (lastCursor && !endCursor) {
              incoming = mergeDeep(incoming, {
                pageInfo: {
                  endCursor: lastCursor
                }
              });
            }
          }
          var prefix = existing.edges;
          var suffix = [];
          if (args && args.after) {
            var index2 = prefix.findIndex(function(edge) {
              return edge.cursor === args.after;
            });
            if (index2 >= 0) {
              prefix = prefix.slice(0, index2 + 1);
            }
          } else if (args && args.before) {
            var index2 = prefix.findIndex(function(edge) {
              return edge.cursor === args.before;
            });
            suffix = index2 < 0 ? prefix : prefix.slice(index2);
            prefix = [];
          } else if (incoming.edges) {
            prefix = [];
          }
          var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix), incomingEdges), suffix);
          var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
          if (incoming.pageInfo) {
            var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
            Object.assign(pageInfo, extras);
            if (!prefix.length) {
              if (hasPreviousPage !== void 0)
                pageInfo.hasPreviousPage = hasPreviousPage;
              if (startCursor !== void 0)
                pageInfo.startCursor = startCursor;
            }
            if (!suffix.length) {
              if (hasNextPage !== void 0)
                pageInfo.hasNextPage = hasNextPage;
              if (endCursor !== void 0)
                pageInfo.endCursor = endCursor;
            }
          }
          return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges, pageInfo });
        }
      };
    }
    var getExtras = function(obj) {
      return tslib.__rest(obj, notExtras);
    };
    var notExtras = ["edges", "pageInfo"];
    function makeEmptyData() {
      return {
        edges: [],
        pageInfo: {
          hasPreviousPage: false,
          hasNextPage: true,
          startCursor: "",
          endCursor: ""
        }
      };
    }
    var toString = Object.prototype.toString;
    function cloneDeep(value) {
      return cloneDeepHelper(value);
    }
    function cloneDeepHelper(val, seen) {
      switch (toString.call(val)) {
        case "[object Array]": {
          seen = seen || new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_1 = val.slice(0);
          seen.set(val, copy_1);
          copy_1.forEach(function(child, i) {
            copy_1[i] = cloneDeepHelper(child, seen);
          });
          return copy_1;
        }
        case "[object Object]": {
          seen = seen || new Map();
          if (seen.has(val))
            return seen.get(val);
          var copy_2 = Object.create(Object.getPrototypeOf(val));
          seen.set(val, copy_2);
          Object.keys(val).forEach(function(key) {
            copy_2[key] = cloneDeepHelper(val[key], seen);
          });
          return copy_2;
        }
        default:
          return val;
      }
    }
    function deepFreeze(value) {
      var workSet = new Set([value]);
      workSet.forEach(function(obj) {
        if (isNonNullObject(obj)) {
          if (!Object.isFrozen(obj))
            Object.freeze(obj);
          Object.getOwnPropertyNames(obj).forEach(function(name) {
            if (isNonNullObject(obj[name]))
              workSet.add(obj[name]);
          });
        }
      });
      return value;
    }
    function maybeDeepFreeze(obj) {
      if (__DEV__) {
        deepFreeze(obj);
      }
      return obj;
    }
    function iterateObserversSafely(observers, method, argument) {
      var observersWithMethod = [];
      observers.forEach(function(obs) {
        return obs[method] && observersWithMethod.push(obs);
      });
      observersWithMethod.forEach(function(obs) {
        return obs[method](argument);
      });
    }
    function asyncMap(observable, mapFn, catchFn) {
      return new zenObservableTs.Observable(function(observer) {
        var next = observer.next, error3 = observer.error, complete = observer.complete;
        var activeCallbackCount = 0;
        var completed = false;
        var promiseQueue = {
          then: function(callback) {
            return new Promise(function(resolve2) {
              return resolve2(callback());
            });
          }
        };
        function makeCallback(examiner, delegate) {
          if (examiner) {
            return function(arg) {
              ++activeCallbackCount;
              var both = function() {
                return examiner(arg);
              };
              promiseQueue = promiseQueue.then(both, both).then(function(result) {
                --activeCallbackCount;
                next && next.call(observer, result);
                if (completed) {
                  handler.complete();
                }
              }, function(error4) {
                --activeCallbackCount;
                throw error4;
              }).catch(function(caught) {
                error3 && error3.call(observer, caught);
              });
            };
          } else {
            return function(arg) {
              return delegate && delegate.call(observer, arg);
            };
          }
        }
        var handler = {
          next: makeCallback(mapFn, next),
          error: makeCallback(catchFn, error3),
          complete: function() {
            completed = true;
            if (!activeCallbackCount) {
              complete && complete.call(observer);
            }
          }
        };
        var sub = observable.subscribe(handler);
        return function() {
          return sub.unsubscribe();
        };
      });
    }
    function fixObservableSubclass(subclass) {
      function set(key) {
        Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
      }
      if (typeof Symbol === "function" && Symbol.species) {
        set(Symbol.species);
      }
      set("@@species");
      return subclass;
    }
    function isPromiseLike(value) {
      return value && typeof value.then === "function";
    }
    var Concast = function(_super) {
      tslib.__extends(Concast2, _super);
      function Concast2(sources) {
        var _this = _super.call(this, function(observer) {
          _this.addObserver(observer);
          return function() {
            return _this.removeObserver(observer);
          };
        }) || this;
        _this.observers = new Set();
        _this.addCount = 0;
        _this.promise = new Promise(function(resolve2, reject) {
          _this.resolve = resolve2;
          _this.reject = reject;
        });
        _this.handlers = {
          next: function(result) {
            if (_this.sub !== null) {
              _this.latest = ["next", result];
              iterateObserversSafely(_this.observers, "next", result);
            }
          },
          error: function(error3) {
            var sub = _this.sub;
            if (sub !== null) {
              if (sub)
                Promise.resolve().then(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              _this.latest = ["error", error3];
              _this.reject(error3);
              iterateObserversSafely(_this.observers, "error", error3);
            }
          },
          complete: function() {
            if (_this.sub !== null) {
              var value = _this.sources.shift();
              if (!value) {
                _this.sub = null;
                if (_this.latest && _this.latest[0] === "next") {
                  _this.resolve(_this.latest[1]);
                } else {
                  _this.resolve();
                }
                iterateObserversSafely(_this.observers, "complete");
              } else if (isPromiseLike(value)) {
                value.then(function(obs) {
                  return _this.sub = obs.subscribe(_this.handlers);
                });
              } else {
                _this.sub = value.subscribe(_this.handlers);
              }
            }
          }
        };
        _this.cancel = function(reason) {
          _this.reject(reason);
          _this.sources = [];
          _this.handlers.complete();
        };
        _this.promise.catch(function(_) {
        });
        if (typeof sources === "function") {
          sources = [new zenObservableTs.Observable(sources)];
        }
        if (isPromiseLike(sources)) {
          sources.then(function(iterable) {
            return _this.start(iterable);
          }, _this.handlers.error);
        } else {
          _this.start(sources);
        }
        return _this;
      }
      Concast2.prototype.start = function(sources) {
        if (this.sub !== void 0)
          return;
        this.sources = Array.from(sources);
        this.handlers.complete();
      };
      Concast2.prototype.deliverLastMessage = function(observer) {
        if (this.latest) {
          var nextOrError = this.latest[0];
          var method = observer[nextOrError];
          if (method) {
            method.call(observer, this.latest[1]);
          }
          if (this.sub === null && nextOrError === "next" && observer.complete) {
            observer.complete();
          }
        }
      };
      Concast2.prototype.addObserver = function(observer) {
        if (!this.observers.has(observer)) {
          this.deliverLastMessage(observer);
          this.observers.add(observer);
          ++this.addCount;
        }
      };
      Concast2.prototype.removeObserver = function(observer, quietly) {
        if (this.observers.delete(observer) && --this.addCount < 1 && !quietly) {
          this.handlers.error(new Error("Observable cancelled prematurely"));
        }
      };
      Concast2.prototype.cleanup = function(callback) {
        var _this = this;
        var called = false;
        var once = function() {
          if (!called) {
            called = true;
            _this.observers.delete(observer);
            callback();
          }
        };
        var observer = {
          next: once,
          error: once,
          complete: once
        };
        var count = this.addCount;
        this.addObserver(observer);
        this.addCount = count;
      };
      return Concast2;
    }(zenObservableTs.Observable);
    fixObservableSubclass(Concast);
    function isNonEmptyArray(value) {
      return Array.isArray(value) && value.length > 0;
    }
    function graphQLResultHasError(result) {
      return result.errors && result.errors.length > 0 || false;
    }
    var canUseWeakMap = typeof WeakMap === "function" && !(typeof navigator === "object" && navigator.product === "ReactNative");
    var canUseWeakSet = typeof WeakSet === "function";
    function compact() {
      var objects = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
      }
      var result = Object.create(null);
      objects.forEach(function(obj) {
        if (!obj)
          return;
        Object.keys(obj).forEach(function(key) {
          var value = obj[key];
          if (value !== void 0) {
            result[key] = value;
          }
        });
      });
      return result;
    }
    var prefixCounts = new Map();
    function makeUniqueId(prefix) {
      var count = prefixCounts.get(prefix) || 1;
      prefixCounts.set(prefix, count + 1);
      return prefix + ":" + count + ":" + Math.random().toString(36).slice(2);
    }
    function stringifyForDisplay(value) {
      var undefId = makeUniqueId("stringifyForDisplay");
      return JSON.stringify(value, function(key, value2) {
        return value2 === void 0 ? undefId : value2;
      }).split(JSON.stringify(undefId)).join("<undefined>");
    }
    __DEV__ ? tsInvariant.invariant(typeof DEV === "boolean", DEV) : tsInvariant.invariant(typeof DEV === "boolean", 59);
    exports.Observable = zenObservableTs.Observable;
    exports.Concast = Concast;
    exports.DEV = DEV;
    exports.DeepMerger = DeepMerger;
    exports.addTypenameToDocument = addTypenameToDocument;
    exports.argumentsObjectFromField = argumentsObjectFromField;
    exports.asyncMap = asyncMap;
    exports.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
    exports.canUseWeakMap = canUseWeakMap;
    exports.canUseWeakSet = canUseWeakSet;
    exports.checkDocument = checkDocument;
    exports.cloneDeep = cloneDeep;
    exports.compact = compact;
    exports.concatPagination = concatPagination;
    exports.createFragmentMap = createFragmentMap;
    exports.fixObservableSubclass = fixObservableSubclass;
    exports.getDefaultValues = getDefaultValues;
    exports.getDirectiveNames = getDirectiveNames;
    exports.getFragmentDefinition = getFragmentDefinition;
    exports.getFragmentDefinitions = getFragmentDefinitions;
    exports.getFragmentFromSelection = getFragmentFromSelection;
    exports.getFragmentQueryDocument = getFragmentQueryDocument;
    exports.getInclusionDirectives = getInclusionDirectives;
    exports.getMainDefinition = getMainDefinition2;
    exports.getOperationDefinition = getOperationDefinition;
    exports.getOperationName = getOperationName;
    exports.getQueryDefinition = getQueryDefinition;
    exports.getStoreKeyName = getStoreKeyName;
    exports.getTypenameFromResult = getTypenameFromResult;
    exports.graphQLResultHasError = graphQLResultHasError;
    exports.hasClientExports = hasClientExports;
    exports.hasDirectives = hasDirectives;
    exports.isDocumentNode = isDocumentNode;
    exports.isField = isField;
    exports.isInlineFragment = isInlineFragment;
    exports.isNonEmptyArray = isNonEmptyArray;
    exports.isNonNullObject = isNonNullObject;
    exports.isReference = isReference;
    exports.iterateObserversSafely = iterateObserversSafely;
    exports.makeReference = makeReference;
    exports.makeUniqueId = makeUniqueId;
    exports.maybe = maybe;
    exports.maybeDeepFreeze = maybeDeepFreeze;
    exports.mergeDeep = mergeDeep;
    exports.mergeDeepArray = mergeDeepArray;
    exports.offsetLimitPagination = offsetLimitPagination;
    exports.relayStylePagination = relayStylePagination;
    exports.removeArgumentsFromDocument = removeArgumentsFromDocument;
    exports.removeClientSetsFromDocument = removeClientSetsFromDocument;
    exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
    exports.removeDirectivesFromDocument = removeDirectivesFromDocument;
    exports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
    exports.resultKeyNameFromField = resultKeyNameFromField;
    exports.shouldInclude = shouldInclude;
    exports.storeKeyNameFromField = storeKeyNameFromField;
    exports.stringifyForDisplay = stringifyForDisplay;
    exports.valueToObjectRepresentation = valueToObjectRepresentation;
  }
});

// node_modules/@apollo/client/link/utils/utils.cjs.js
var require_utils_cjs = __commonJS({
  "node_modules/@apollo/client/link/utils/utils.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utilities = require_utilities_cjs();
    var tsInvariant = require_invariant();
    var tslib = require_tslib();
    function fromError(errorValue) {
      return new utilities.Observable(function(observer) {
        observer.error(errorValue);
      });
    }
    function toPromise(observable) {
      var completed = false;
      return new Promise(function(resolve2, reject) {
        observable.subscribe({
          next: function(data) {
            if (completed) {
              __DEV__ && tsInvariant.invariant.warn("Promise Wrapper does not support multiple results from Observable");
            } else {
              completed = true;
              resolve2(data);
            }
          },
          error: reject
        });
      });
    }
    function fromPromise(promise) {
      return new utilities.Observable(function(observer) {
        promise.then(function(value) {
          observer.next(value);
          observer.complete();
        }).catch(observer.error.bind(observer));
      });
    }
    var throwServerError = function(response, result, message) {
      var error3 = new Error(message);
      error3.name = "ServerError";
      error3.response = response;
      error3.statusCode = response.status;
      error3.result = result;
      throw error3;
    };
    function validateOperation(operation) {
      var OPERATION_FIELDS = [
        "query",
        "operationName",
        "variables",
        "extensions",
        "context"
      ];
      for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
        var key = _a[_i];
        if (OPERATION_FIELDS.indexOf(key) < 0) {
          throw __DEV__ ? new tsInvariant.InvariantError("illegal argument: " + key) : new tsInvariant.InvariantError(29);
        }
      }
      return operation;
    }
    function createOperation(starting, operation) {
      var context = tslib.__assign({}, starting);
      var setContext2 = function(next) {
        if (typeof next === "function") {
          context = tslib.__assign(tslib.__assign({}, context), next(context));
        } else {
          context = tslib.__assign(tslib.__assign({}, context), next);
        }
      };
      var getContext2 = function() {
        return tslib.__assign({}, context);
      };
      Object.defineProperty(operation, "setContext", {
        enumerable: false,
        value: setContext2
      });
      Object.defineProperty(operation, "getContext", {
        enumerable: false,
        value: getContext2
      });
      return operation;
    }
    function transformOperation(operation) {
      var transformedOperation = {
        variables: operation.variables || {},
        extensions: operation.extensions || {},
        operationName: operation.operationName,
        query: operation.query
      };
      if (!transformedOperation.operationName) {
        transformedOperation.operationName = typeof transformedOperation.query !== "string" ? utilities.getOperationName(transformedOperation.query) || void 0 : "";
      }
      return transformedOperation;
    }
    exports.createOperation = createOperation;
    exports.fromError = fromError;
    exports.fromPromise = fromPromise;
    exports.throwServerError = throwServerError;
    exports.toPromise = toPromise;
    exports.transformOperation = transformOperation;
    exports.validateOperation = validateOperation;
  }
});

// node_modules/@apollo/client/link/core/core.cjs.js
var require_core_cjs = __commonJS({
  "node_modules/@apollo/client/link/core/core.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tsInvariant = require_invariant();
    var utilities = require_utilities_cjs();
    var tslib = require_tslib();
    var utils = require_utils_cjs();
    function passthrough(op, forward) {
      return forward ? forward(op) : utilities.Observable.of();
    }
    function toLink(handler) {
      return typeof handler === "function" ? new ApolloLink(handler) : handler;
    }
    function isTerminating(link) {
      return link.request.length <= 1;
    }
    var LinkError = function(_super) {
      tslib.__extends(LinkError2, _super);
      function LinkError2(message, link) {
        var _this = _super.call(this, message) || this;
        _this.link = link;
        return _this;
      }
      return LinkError2;
    }(Error);
    var ApolloLink = function() {
      function ApolloLink2(request) {
        if (request)
          this.request = request;
      }
      ApolloLink2.empty = function() {
        return new ApolloLink2(function() {
          return utilities.Observable.of();
        });
      };
      ApolloLink2.from = function(links) {
        if (links.length === 0)
          return ApolloLink2.empty();
        return links.map(toLink).reduce(function(x, y) {
          return x.concat(y);
        });
      };
      ApolloLink2.split = function(test, left, right) {
        var leftLink = toLink(left);
        var rightLink = toLink(right || new ApolloLink2(passthrough));
        if (isTerminating(leftLink) && isTerminating(rightLink)) {
          return new ApolloLink2(function(operation) {
            return test(operation) ? leftLink.request(operation) || utilities.Observable.of() : rightLink.request(operation) || utilities.Observable.of();
          });
        } else {
          return new ApolloLink2(function(operation, forward) {
            return test(operation) ? leftLink.request(operation, forward) || utilities.Observable.of() : rightLink.request(operation, forward) || utilities.Observable.of();
          });
        }
      };
      ApolloLink2.execute = function(link, operation) {
        return link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of();
      };
      ApolloLink2.concat = function(first, second) {
        var firstLink = toLink(first);
        if (isTerminating(firstLink)) {
          __DEV__ && tsInvariant.invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
          return firstLink;
        }
        var nextLink = toLink(second);
        if (isTerminating(nextLink)) {
          return new ApolloLink2(function(operation) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        } else {
          return new ApolloLink2(function(operation, forward) {
            return firstLink.request(operation, function(op) {
              return nextLink.request(op, forward) || utilities.Observable.of();
            }) || utilities.Observable.of();
          });
        }
      };
      ApolloLink2.prototype.split = function(test, left, right) {
        return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
      };
      ApolloLink2.prototype.concat = function(next) {
        return ApolloLink2.concat(this, next);
      };
      ApolloLink2.prototype.request = function(operation, forward) {
        throw __DEV__ ? new tsInvariant.InvariantError("request is not implemented") : new tsInvariant.InvariantError(23);
      };
      ApolloLink2.prototype.onError = function(error3, observer) {
        if (observer && observer.error) {
          observer.error(error3);
          return false;
        }
        throw error3;
      };
      ApolloLink2.prototype.setOnError = function(fn) {
        this.onError = fn;
        return this;
      };
      return ApolloLink2;
    }();
    var empty2 = ApolloLink.empty;
    var from = ApolloLink.from;
    var split2 = ApolloLink.split;
    var concat = ApolloLink.concat;
    var execute = ApolloLink.execute;
    __DEV__ ? tsInvariant.invariant(typeof utilities.DEV === "boolean", utilities.DEV) : tsInvariant.invariant(typeof utilities.DEV === "boolean", 24);
    exports.ApolloLink = ApolloLink;
    exports.concat = concat;
    exports.empty = empty2;
    exports.execute = execute;
    exports.from = from;
    exports.split = split2;
  }
});

// node_modules/@apollo/client/link/http/http.cjs.js
var require_http_cjs = __commonJS({
  "node_modules/@apollo/client/link/http/http.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils_cjs();
    var tsInvariant = require_invariant();
    var tslib = require_tslib();
    var graphql = require_graphql2();
    var core = require_core_cjs();
    var utilities = require_utilities_cjs();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function parseAndCheckHttpResponse(operations) {
      return function(response) {
        return response.text().then(function(bodyText) {
          try {
            return JSON.parse(bodyText);
          } catch (err) {
            var parseError = err;
            parseError.name = "ServerParseError";
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            throw parseError;
          }
        }).then(function(result) {
          if (response.status >= 300) {
            utils.throwServerError(response, result, "Response not successful: Received status code " + response.status);
          }
          if (!Array.isArray(result) && !hasOwnProperty.call(result, "data") && !hasOwnProperty.call(result, "errors")) {
            utils.throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations) ? operations.map(function(op) {
              return op.operationName;
            }) : operations.operationName) + "'.");
          }
          return result;
        });
      };
    }
    var serializeFetchParameter = function(p, label) {
      var serialized;
      try {
        serialized = JSON.stringify(p);
      } catch (e) {
        var parseError = __DEV__ ? new tsInvariant.InvariantError("Network request failed. " + label + " is not serializable: " + e.message) : new tsInvariant.InvariantError(26);
        parseError.parseError = e;
        throw parseError;
      }
      return serialized;
    };
    var defaultHttpOptions = {
      includeQuery: true,
      includeExtensions: false
    };
    var defaultHeaders = {
      accept: "*/*",
      "content-type": "application/json"
    };
    var defaultOptions = {
      method: "POST"
    };
    var fallbackHttpConfig = {
      http: defaultHttpOptions,
      headers: defaultHeaders,
      options: defaultOptions
    };
    var selectHttpOptionsAndBody = function(operation, fallbackConfig) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      var options2 = tslib.__assign(tslib.__assign({}, fallbackConfig.options), { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
      var http2 = fallbackConfig.http || {};
      configs.forEach(function(config) {
        options2 = tslib.__assign(tslib.__assign(tslib.__assign({}, options2), config.options), { headers: tslib.__assign(tslib.__assign({}, options2.headers), headersToLowerCase(config.headers)) });
        if (config.credentials)
          options2.credentials = config.credentials;
        http2 = tslib.__assign(tslib.__assign({}, http2), config.http);
      });
      var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
      var body = { operationName, variables };
      if (http2.includeExtensions)
        body.extensions = extensions;
      if (http2.includeQuery)
        body.query = graphql.print(query);
      return {
        options: options2,
        body
      };
    };
    function headersToLowerCase(headers) {
      if (headers) {
        var normalized_1 = Object.create(null);
        Object.keys(Object(headers)).forEach(function(name) {
          normalized_1[name.toLowerCase()] = headers[name];
        });
        return normalized_1;
      }
      return headers;
    }
    var checkFetcher = function(fetcher) {
      if (!fetcher && typeof void 0 === "undefined") {
        throw __DEV__ ? new tsInvariant.InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new tsInvariant.InvariantError(25);
      }
    };
    var createSignalIfSupported = function() {
      if (typeof AbortController === "undefined")
        return { controller: false, signal: false };
      var controller = new AbortController();
      var signal = controller.signal;
      return { controller, signal };
    };
    var selectURI = function(operation, fallbackURI) {
      var context = operation.getContext();
      var contextURI = context.uri;
      if (contextURI) {
        return contextURI;
      } else if (typeof fallbackURI === "function") {
        return fallbackURI(operation);
      } else {
        return fallbackURI || "/graphql";
      }
    };
    function rewriteURIForGET(chosenURI, body) {
      var queryParams = [];
      var addQueryParam = function(key, value) {
        queryParams.push(key + "=" + encodeURIComponent(value));
      };
      if ("query" in body) {
        addQueryParam("query", body.query);
      }
      if (body.operationName) {
        addQueryParam("operationName", body.operationName);
      }
      if (body.variables) {
        var serializedVariables = void 0;
        try {
          serializedVariables = serializeFetchParameter(body.variables, "Variables map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("variables", serializedVariables);
      }
      if (body.extensions) {
        var serializedExtensions = void 0;
        try {
          serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
        } catch (parseError) {
          return { parseError };
        }
        addQueryParam("extensions", serializedExtensions);
      }
      var fragment = "", preFragment = chosenURI;
      var fragmentStart = chosenURI.indexOf("#");
      if (fragmentStart !== -1) {
        fragment = chosenURI.substr(fragmentStart);
        preFragment = chosenURI.substr(0, fragmentStart);
      }
      var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
      var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
      return { newURI };
    }
    var backupFetch = utilities.maybe(function() {
      return void 0;
    });
    var createHttpLink = function(linkOptions) {
      if (linkOptions === void 0) {
        linkOptions = {};
      }
      var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, preferredFetch = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, _b = linkOptions.includeUnusedVariables, includeUnusedVariables = _b === void 0 ? false : _b, requestOptions = tslib.__rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries", "includeUnusedVariables"]);
      if (__DEV__) {
        checkFetcher(preferredFetch || backupFetch);
      }
      var linkConfig = {
        http: { includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers
      };
      return new core.ApolloLink(function(operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
          var _a2 = context.clientAwareness, name_1 = _a2.name, version = _a2.version;
          if (name_1) {
            clientAwarenessHeaders["apollographql-client-name"] = name_1;
          }
          if (version) {
            clientAwarenessHeaders["apollographql-client-version"] = version;
          }
        }
        var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);
        var contextConfig = {
          http: context.http,
          options: context.fetchOptions,
          credentials: context.credentials,
          headers: contextHeaders
        };
        var _b2 = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options2 = _b2.options, body = _b2.body;
        if (body.variables && !includeUnusedVariables) {
          var unusedNames_1 = new Set(Object.keys(body.variables));
          graphql.visit(operation.query, {
            Variable: function(node, _key, parent) {
              if (parent && parent.kind !== "VariableDefinition") {
                unusedNames_1.delete(node.name.value);
              }
            }
          });
          if (unusedNames_1.size) {
            body.variables = tslib.__assign({}, body.variables);
            unusedNames_1.forEach(function(name) {
              delete body.variables[name];
            });
          }
        }
        var controller;
        if (!options2.signal) {
          var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
          controller = _controller;
          if (controller)
            options2.signal = signal;
        }
        var definitionIsMutation = function(d2) {
          return d2.kind === "OperationDefinition" && d2.operation === "mutation";
        };
        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
          options2.method = "GET";
        }
        if (options2.method === "GET") {
          var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
          if (parseError) {
            return utils.fromError(parseError);
          }
          chosenURI = newURI;
        } else {
          try {
            options2.body = serializeFetchParameter(body, "Payload");
          } catch (parseError2) {
            return utils.fromError(parseError2);
          }
        }
        return new utilities.Observable(function(observer) {
          var currentFetch = preferredFetch || utilities.maybe(function() {
            return void 0;
          }) || backupFetch;
          currentFetch(chosenURI, options2).then(function(response) {
            operation.setContext({ response });
            return response;
          }).then(parseAndCheckHttpResponse(operation)).then(function(result) {
            observer.next(result);
            observer.complete();
            return result;
          }).catch(function(err) {
            if (err.name === "AbortError")
              return;
            if (err.result && err.result.errors && err.result.data) {
              observer.next(err.result);
            }
            observer.error(err);
          });
          return function() {
            if (controller)
              controller.abort();
          };
        });
      });
    };
    var HttpLink2 = function(_super) {
      tslib.__extends(HttpLink3, _super);
      function HttpLink3(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var _this = _super.call(this, createHttpLink(options2).request) || this;
        _this.options = options2;
        return _this;
      }
      return HttpLink3;
    }(core.ApolloLink);
    exports.HttpLink = HttpLink2;
    exports.checkFetcher = checkFetcher;
    exports.createHttpLink = createHttpLink;
    exports.createSignalIfSupported = createSignalIfSupported;
    exports.fallbackHttpConfig = fallbackHttpConfig;
    exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse;
    exports.rewriteURIForGET = rewriteURIForGET;
    exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody;
    exports.selectURI = selectURI;
    exports.serializeFetchParameter = serializeFetchParameter;
  }
});

// node_modules/@wry/equality/lib/equality.js
var require_equality = __commonJS({
  "node_modules/@wry/equality/lib/equality.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a = Object.prototype;
    var toString = _a.toString;
    var hasOwnProperty = _a.hasOwnProperty;
    var fnToStr = Function.prototype.toString;
    var previousComparisons = new Map();
    function equal(a, b) {
      try {
        return check(a, b);
      } finally {
        previousComparisons.clear();
      }
    }
    function check(a, b) {
      if (a === b) {
        return true;
      }
      var aTag = toString.call(a);
      var bTag = toString.call(b);
      if (aTag !== bTag) {
        return false;
      }
      switch (aTag) {
        case "[object Array]":
          if (a.length !== b.length)
            return false;
        case "[object Object]": {
          if (previouslyCompared(a, b))
            return true;
          var aKeys = definedKeys(a);
          var bKeys = definedKeys(b);
          var keyCount = aKeys.length;
          if (keyCount !== bKeys.length)
            return false;
          for (var k = 0; k < keyCount; ++k) {
            if (!hasOwnProperty.call(b, aKeys[k])) {
              return false;
            }
          }
          for (var k = 0; k < keyCount; ++k) {
            var key = aKeys[k];
            if (!check(a[key], b[key])) {
              return false;
            }
          }
          return true;
        }
        case "[object Error]":
          return a.name === b.name && a.message === b.message;
        case "[object Number]":
          if (a !== a)
            return b !== b;
        case "[object Boolean]":
        case "[object Date]":
          return +a === +b;
        case "[object RegExp]":
        case "[object String]":
          return a == "" + b;
        case "[object Map]":
        case "[object Set]": {
          if (a.size !== b.size)
            return false;
          if (previouslyCompared(a, b))
            return true;
          var aIterator = a.entries();
          var isMap = aTag === "[object Map]";
          while (true) {
            var info = aIterator.next();
            if (info.done)
              break;
            var _a2 = info.value, aKey = _a2[0], aValue = _a2[1];
            if (!b.has(aKey)) {
              return false;
            }
            if (isMap && !check(aValue, b.get(aKey))) {
              return false;
            }
          }
          return true;
        }
        case "[object Uint16Array]":
        case "[object Uint8Array]":
        case "[object Uint32Array]":
        case "[object Int32Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object ArrayBuffer]":
          a = new Uint8Array(a);
          b = new Uint8Array(b);
        case "[object DataView]": {
          var len = a.byteLength;
          if (len === b.byteLength) {
            while (len-- && a[len] === b[len]) {
            }
          }
          return len === -1;
        }
        case "[object AsyncFunction]":
        case "[object GeneratorFunction]":
        case "[object AsyncGeneratorFunction]":
        case "[object Function]": {
          var aCode = fnToStr.call(a);
          if (aCode !== fnToStr.call(b)) {
            return false;
          }
          return !endsWith(aCode, nativeCodeSuffix);
        }
      }
      return false;
    }
    function definedKeys(obj) {
      return Object.keys(obj).filter(isDefinedKey, obj);
    }
    function isDefinedKey(key) {
      return this[key] !== void 0;
    }
    var nativeCodeSuffix = "{ [native code] }";
    function endsWith(full, suffix) {
      var fromIndex = full.length - suffix.length;
      return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
    }
    function previouslyCompared(a, b) {
      var bSet = previousComparisons.get(a);
      if (bSet) {
        if (bSet.has(b))
          return true;
      } else {
        previousComparisons.set(a, bSet = new Set());
      }
      bSet.add(b);
      return false;
    }
    exports["default"] = equal;
    exports.equal = equal;
  }
});

// node_modules/@wry/trie/lib/trie.js
var require_trie = __commonJS({
  "node_modules/@wry/trie/lib/trie.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultMakeData = function() {
      return Object.create(null);
    };
    var _a = Array.prototype;
    var forEach = _a.forEach;
    var slice = _a.slice;
    var Trie = function() {
      function Trie2(weakness, makeData) {
        if (weakness === void 0) {
          weakness = true;
        }
        if (makeData === void 0) {
          makeData = defaultMakeData;
        }
        this.weakness = weakness;
        this.makeData = makeData;
      }
      Trie2.prototype.lookup = function() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          array[_i] = arguments[_i];
        }
        return this.lookupArray(array);
      };
      Trie2.prototype.lookupArray = function(array) {
        var node = this;
        forEach.call(array, function(key) {
          return node = node.getChildTrie(key);
        });
        return node.data || (node.data = this.makeData(slice.call(array)));
      };
      Trie2.prototype.getChildTrie = function(key) {
        var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());
        var child = map.get(key);
        if (!child)
          map.set(key, child = new Trie2(this.weakness, this.makeData));
        return child;
      };
      return Trie2;
    }();
    function isObjRef(value) {
      switch (typeof value) {
        case "object":
          if (value === null)
            break;
        case "function":
          return true;
      }
      return false;
    }
    exports.Trie = Trie;
  }
});

// node_modules/@wry/context/lib/context.js
var require_context = __commonJS({
  "node_modules/@wry/context/lib/context.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var currentContext = null;
    var MISSING_VALUE = {};
    var idCounter = 1;
    var makeSlotClass = function() {
      return function() {
        function Slot2() {
          this.id = [
            "slot",
            idCounter++,
            Date.now(),
            Math.random().toString(36).slice(2)
          ].join(":");
        }
        Slot2.prototype.hasValue = function() {
          for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
            if (this.id in context_1.slots) {
              var value = context_1.slots[this.id];
              if (value === MISSING_VALUE)
                break;
              if (context_1 !== currentContext) {
                currentContext.slots[this.id] = value;
              }
              return true;
            }
          }
          if (currentContext) {
            currentContext.slots[this.id] = MISSING_VALUE;
          }
          return false;
        };
        Slot2.prototype.getValue = function() {
          if (this.hasValue()) {
            return currentContext.slots[this.id];
          }
        };
        Slot2.prototype.withValue = function(value, callback, args, thisArg) {
          var _a;
          var slots = (_a = {
            __proto__: null
          }, _a[this.id] = value, _a);
          var parent = currentContext;
          currentContext = { parent, slots };
          try {
            return callback.apply(thisArg, args);
          } finally {
            currentContext = parent;
          }
        };
        Slot2.bind = function(callback) {
          var context = currentContext;
          return function() {
            var saved = currentContext;
            try {
              currentContext = context;
              return callback.apply(this, arguments);
            } finally {
              currentContext = saved;
            }
          };
        };
        Slot2.noContext = function(callback, args, thisArg) {
          if (currentContext) {
            var saved = currentContext;
            try {
              currentContext = null;
              return callback.apply(thisArg, args);
            } finally {
              currentContext = saved;
            }
          } else {
            return callback.apply(thisArg, args);
          }
        };
        return Slot2;
      }();
    };
    var globalKey = "@wry/context:Slot";
    var host = Array;
    var Slot = host[globalKey] || function() {
      var Slot2 = makeSlotClass();
      try {
        Object.defineProperty(host, globalKey, {
          value: host[globalKey] = Slot2,
          enumerable: false,
          writable: false,
          configurable: false
        });
      } finally {
        return Slot2;
      }
    }();
    var bind = Slot.bind;
    var noContext = Slot.noContext;
    function setTimeoutWithContext(callback, delay) {
      return setTimeout(bind(callback), delay);
    }
    function asyncFromGen(genFn) {
      return function() {
        var gen = genFn.apply(this, arguments);
        var boundNext = bind(gen.next);
        var boundThrow = bind(gen.throw);
        return new Promise(function(resolve2, reject) {
          function invoke(method, argument) {
            try {
              var result = method.call(gen, argument);
            } catch (error3) {
              return reject(error3);
            }
            var next = result.done ? resolve2 : invokeNext;
            if (isPromiseLike(result.value)) {
              result.value.then(next, result.done ? reject : invokeThrow);
            } else {
              next(result.value);
            }
          }
          var invokeNext = function(value) {
            return invoke(boundNext, value);
          };
          var invokeThrow = function(error3) {
            return invoke(boundThrow, error3);
          };
          invokeNext();
        });
      };
    }
    function isPromiseLike(value) {
      return value && typeof value.then === "function";
    }
    var wrappedFibers = [];
    function wrapYieldingFiberMethods(Fiber) {
      if (wrappedFibers.indexOf(Fiber) < 0) {
        var wrap = function(obj, method) {
          var fn = obj[method];
          obj[method] = function() {
            return noContext(fn, arguments, this);
          };
        };
        wrap(Fiber, "yield");
        wrap(Fiber.prototype, "run");
        wrap(Fiber.prototype, "throwInto");
        wrappedFibers.push(Fiber);
      }
      return Fiber;
    }
    exports.Slot = Slot;
    exports.asyncFromGen = asyncFromGen;
    exports.bind = bind;
    exports.noContext = noContext;
    exports.setTimeout = setTimeoutWithContext;
    exports.wrapYieldingFiberMethods = wrapYieldingFiberMethods;
  }
});

// node_modules/optimism/lib/bundle.cjs.js
var require_bundle_cjs = __commonJS({
  "node_modules/optimism/lib/bundle.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var trie = require_trie();
    var context = require_context();
    function defaultDispose() {
    }
    var Cache = function() {
      function Cache2(max, dispose) {
        if (max === void 0) {
          max = Infinity;
        }
        if (dispose === void 0) {
          dispose = defaultDispose;
        }
        this.max = max;
        this.dispose = dispose;
        this.map = new Map();
        this.newest = null;
        this.oldest = null;
      }
      Cache2.prototype.has = function(key) {
        return this.map.has(key);
      };
      Cache2.prototype.get = function(key) {
        var node = this.getNode(key);
        return node && node.value;
      };
      Cache2.prototype.getNode = function(key) {
        var node = this.map.get(key);
        if (node && node !== this.newest) {
          var older = node.older, newer = node.newer;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          node.older = this.newest;
          node.older.newer = node;
          node.newer = null;
          this.newest = node;
          if (node === this.oldest) {
            this.oldest = newer;
          }
        }
        return node;
      };
      Cache2.prototype.set = function(key, value) {
        var node = this.getNode(key);
        if (node) {
          return node.value = value;
        }
        node = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = node;
        }
        this.newest = node;
        this.oldest = this.oldest || node;
        this.map.set(key, node);
        return node.value;
      };
      Cache2.prototype.clean = function() {
        while (this.oldest && this.map.size > this.max) {
          this.delete(this.oldest.key);
        }
      };
      Cache2.prototype.delete = function(key) {
        var node = this.map.get(key);
        if (node) {
          if (node === this.newest) {
            this.newest = node.older;
          }
          if (node === this.oldest) {
            this.oldest = node.newer;
          }
          if (node.newer) {
            node.newer.older = node.older;
          }
          if (node.older) {
            node.older.newer = node.newer;
          }
          this.map.delete(key);
          this.dispose(node.value, key);
          return true;
        }
        return false;
      };
      return Cache2;
    }();
    var parentEntrySlot = new context.Slot();
    var _a;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var toArray = (_a = Array.from, _a === void 0 ? function(collection) {
      var array = [];
      collection.forEach(function(item) {
        return array.push(item);
      });
      return array;
    } : _a);
    function maybeUnsubscribe(entryOrDep) {
      var unsubscribe = entryOrDep.unsubscribe;
      if (typeof unsubscribe === "function") {
        entryOrDep.unsubscribe = void 0;
        unsubscribe();
      }
    }
    var emptySetPool = [];
    var POOL_TARGET_SIZE = 100;
    function assert(condition, optionalMessage) {
      if (!condition) {
        throw new Error(optionalMessage || "assertion failure");
      }
    }
    function valueIs(a, b) {
      var len = a.length;
      return len > 0 && len === b.length && a[len - 1] === b[len - 1];
    }
    function valueGet(value) {
      switch (value.length) {
        case 0:
          throw new Error("unknown value");
        case 1:
          return value[0];
        case 2:
          throw value[1];
      }
    }
    function valueCopy(value) {
      return value.slice(0);
    }
    var Entry = function() {
      function Entry2(fn) {
        this.fn = fn;
        this.parents = new Set();
        this.childValues = new Map();
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        this.deps = null;
        ++Entry2.count;
      }
      Entry2.prototype.peek = function() {
        if (this.value.length === 1 && !mightBeDirty(this)) {
          rememberParent(this);
          return this.value[0];
        }
      };
      Entry2.prototype.recompute = function(args) {
        assert(!this.recomputing, "already recomputing");
        rememberParent(this);
        return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
      };
      Entry2.prototype.setDirty = function() {
        if (this.dirty)
          return;
        this.dirty = true;
        this.value.length = 0;
        reportDirty(this);
        maybeUnsubscribe(this);
      };
      Entry2.prototype.dispose = function() {
        var _this = this;
        this.setDirty();
        forgetChildren(this);
        eachParent(this, function(parent, child) {
          parent.setDirty();
          forgetChild(parent, _this);
        });
      };
      Entry2.prototype.forget = function() {
        this.dispose();
      };
      Entry2.prototype.dependOn = function(dep2) {
        dep2.add(this);
        if (!this.deps) {
          this.deps = emptySetPool.pop() || new Set();
        }
        this.deps.add(dep2);
      };
      Entry2.prototype.forgetDeps = function() {
        var _this = this;
        if (this.deps) {
          toArray(this.deps).forEach(function(dep2) {
            return dep2.delete(_this);
          });
          this.deps.clear();
          emptySetPool.push(this.deps);
          this.deps = null;
        }
      };
      Entry2.count = 0;
      return Entry2;
    }();
    function rememberParent(child) {
      var parent = parentEntrySlot.getValue();
      if (parent) {
        child.parents.add(parent);
        if (!parent.childValues.has(child)) {
          parent.childValues.set(child, []);
        }
        if (mightBeDirty(child)) {
          reportDirtyChild(parent, child);
        } else {
          reportCleanChild(parent, child);
        }
        return parent;
      }
    }
    function reallyRecompute(entry, args) {
      forgetChildren(entry);
      parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
      if (maybeSubscribe(entry, args)) {
        setClean(entry);
      }
      return valueGet(entry.value);
    }
    function recomputeNewValue(entry, args) {
      entry.recomputing = true;
      entry.value.length = 0;
      try {
        entry.value[0] = entry.fn.apply(null, args);
      } catch (e) {
        entry.value[1] = e;
      }
      entry.recomputing = false;
    }
    function mightBeDirty(entry) {
      return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
    }
    function setClean(entry) {
      entry.dirty = false;
      if (mightBeDirty(entry)) {
        return;
      }
      reportClean(entry);
    }
    function reportDirty(child) {
      eachParent(child, reportDirtyChild);
    }
    function reportClean(child) {
      eachParent(child, reportCleanChild);
    }
    function eachParent(child, callback) {
      var parentCount = child.parents.size;
      if (parentCount) {
        var parents = toArray(child.parents);
        for (var i = 0; i < parentCount; ++i) {
          callback(parents[i], child);
        }
      }
    }
    function reportDirtyChild(parent, child) {
      assert(parent.childValues.has(child));
      assert(mightBeDirty(child));
      var parentWasClean = !mightBeDirty(parent);
      if (!parent.dirtyChildren) {
        parent.dirtyChildren = emptySetPool.pop() || new Set();
      } else if (parent.dirtyChildren.has(child)) {
        return;
      }
      parent.dirtyChildren.add(child);
      if (parentWasClean) {
        reportDirty(parent);
      }
    }
    function reportCleanChild(parent, child) {
      assert(parent.childValues.has(child));
      assert(!mightBeDirty(child));
      var childValue = parent.childValues.get(child);
      if (childValue.length === 0) {
        parent.childValues.set(child, valueCopy(child.value));
      } else if (!valueIs(childValue, child.value)) {
        parent.setDirty();
      }
      removeDirtyChild(parent, child);
      if (mightBeDirty(parent)) {
        return;
      }
      reportClean(parent);
    }
    function removeDirtyChild(parent, child) {
      var dc = parent.dirtyChildren;
      if (dc) {
        dc.delete(child);
        if (dc.size === 0) {
          if (emptySetPool.length < POOL_TARGET_SIZE) {
            emptySetPool.push(dc);
          }
          parent.dirtyChildren = null;
        }
      }
    }
    function forgetChildren(parent) {
      if (parent.childValues.size > 0) {
        parent.childValues.forEach(function(_value, child) {
          forgetChild(parent, child);
        });
      }
      parent.forgetDeps();
      assert(parent.dirtyChildren === null);
    }
    function forgetChild(parent, child) {
      child.parents.delete(parent);
      parent.childValues.delete(child);
      removeDirtyChild(parent, child);
    }
    function maybeSubscribe(entry, args) {
      if (typeof entry.subscribe === "function") {
        try {
          maybeUnsubscribe(entry);
          entry.unsubscribe = entry.subscribe.apply(null, args);
        } catch (e) {
          entry.setDirty();
          return false;
        }
      }
      return true;
    }
    var EntryMethods = {
      setDirty: true,
      dispose: true,
      forget: true
    };
    function dep(options2) {
      var depsByKey = new Map();
      var subscribe2 = options2 && options2.subscribe;
      function depend(key) {
        var parent = parentEntrySlot.getValue();
        if (parent) {
          var dep_1 = depsByKey.get(key);
          if (!dep_1) {
            depsByKey.set(key, dep_1 = new Set());
          }
          parent.dependOn(dep_1);
          if (typeof subscribe2 === "function") {
            maybeUnsubscribe(dep_1);
            dep_1.unsubscribe = subscribe2(key);
          }
        }
      }
      depend.dirty = function dirty(key, entryMethodName) {
        var dep2 = depsByKey.get(key);
        if (dep2) {
          var m_1 = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
          toArray(dep2).forEach(function(entry) {
            return entry[m_1]();
          });
          depsByKey.delete(key);
          maybeUnsubscribe(dep2);
        }
      };
      return depend;
    }
    function makeDefaultMakeCacheKeyFunction() {
      var keyTrie = new trie.Trie(typeof WeakMap === "function");
      return function() {
        return keyTrie.lookupArray(arguments);
      };
    }
    var defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();
    var caches = new Set();
    function wrap(originalFunction, options2) {
      if (options2 === void 0) {
        options2 = Object.create(null);
      }
      var cache = new Cache(options2.max || Math.pow(2, 16), function(entry) {
        return entry.dispose();
      });
      var keyArgs = options2.keyArgs;
      var makeCacheKey = options2.makeCacheKey || makeDefaultMakeCacheKeyFunction();
      var optimistic = function() {
        var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
        if (key === void 0) {
          return originalFunction.apply(null, arguments);
        }
        var entry = cache.get(key);
        if (!entry) {
          cache.set(key, entry = new Entry(originalFunction));
          entry.subscribe = options2.subscribe;
          entry.forget = function() {
            return cache.delete(key);
          };
        }
        var value = entry.recompute(Array.prototype.slice.call(arguments));
        cache.set(key, entry);
        caches.add(cache);
        if (!parentEntrySlot.hasValue()) {
          caches.forEach(function(cache2) {
            return cache2.clean();
          });
          caches.clear();
        }
        return value;
      };
      Object.defineProperty(optimistic, "size", {
        get: function() {
          return cache["map"].size;
        },
        configurable: false,
        enumerable: false
      });
      function dirtyKey(key) {
        var entry = cache.get(key);
        if (entry) {
          entry.setDirty();
        }
      }
      optimistic.dirtyKey = dirtyKey;
      optimistic.dirty = function dirty() {
        dirtyKey(makeCacheKey.apply(null, arguments));
      };
      function peekKey(key) {
        var entry = cache.get(key);
        if (entry) {
          return entry.peek();
        }
      }
      optimistic.peekKey = peekKey;
      optimistic.peek = function peek() {
        return peekKey(makeCacheKey.apply(null, arguments));
      };
      function forgetKey(key) {
        return cache.delete(key);
      }
      optimistic.forgetKey = forgetKey;
      optimistic.forget = function forget() {
        return forgetKey(makeCacheKey.apply(null, arguments));
      };
      optimistic.makeCacheKey = makeCacheKey;
      optimistic.getKey = keyArgs ? function getKey() {
        return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
      } : makeCacheKey;
      return Object.freeze(optimistic);
    }
    Object.defineProperty(exports, "KeyTrie", {
      enumerable: true,
      get: function() {
        return trie.Trie;
      }
    });
    Object.defineProperty(exports, "asyncFromGen", {
      enumerable: true,
      get: function() {
        return context.asyncFromGen;
      }
    });
    Object.defineProperty(exports, "bindContext", {
      enumerable: true,
      get: function() {
        return context.bind;
      }
    });
    Object.defineProperty(exports, "noContext", {
      enumerable: true,
      get: function() {
        return context.noContext;
      }
    });
    Object.defineProperty(exports, "setTimeout", {
      enumerable: true,
      get: function() {
        return context.setTimeout;
      }
    });
    exports.defaultMakeCacheKey = defaultMakeCacheKey;
    exports.dep = dep;
    exports.wrap = wrap;
  }
});

// node_modules/@apollo/client/cache/cache.cjs.js
var require_cache_cjs = __commonJS({
  "node_modules/@apollo/client/cache/cache.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tsInvariant = require_invariant();
    var utilities = require_utilities_cjs();
    var tslib = require_tslib();
    var optimism = require_bundle_cjs();
    var equality = require_equality();
    var trie = require_trie();
    var context = require_context();
    var ApolloCache = function() {
      function ApolloCache2() {
        this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument);
      }
      ApolloCache2.prototype.batch = function(options2) {
        var optimisticId = typeof options2.optimistic === "string" ? options2.optimistic : options2.optimistic === false ? null : void 0;
        this.performTransaction(options2.update, optimisticId);
      };
      ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
        this.performTransaction(transaction, optimisticId);
      };
      ApolloCache2.prototype.transformDocument = function(document2) {
        return document2;
      };
      ApolloCache2.prototype.identify = function(object) {
        return;
      };
      ApolloCache2.prototype.gc = function() {
        return [];
      };
      ApolloCache2.prototype.modify = function(options2) {
        return false;
      };
      ApolloCache2.prototype.transformForLink = function(document2) {
        return document2;
      };
      ApolloCache2.prototype.readQuery = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options2.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options2), { rootId: options2.id || "ROOT_QUERY", optimistic }));
      };
      ApolloCache2.prototype.readFragment = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = !!options2.optimistic;
        }
        return this.read(tslib.__assign(tslib.__assign({}, options2), { query: this.getFragmentDoc(options2.fragment, options2.fragmentName), rootId: options2.id, optimistic }));
      };
      ApolloCache2.prototype.writeQuery = function(_a) {
        var id = _a.id, data = _a.data, options2 = tslib.__rest(_a, ["id", "data"]);
        return this.write(Object.assign(options2, {
          dataId: id || "ROOT_QUERY",
          result: data
        }));
      };
      ApolloCache2.prototype.writeFragment = function(_a) {
        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options2 = tslib.__rest(_a, ["id", "data", "fragment", "fragmentName"]);
        return this.write(Object.assign(options2, {
          query: this.getFragmentDoc(fragment, fragmentName),
          dataId: id,
          result: data
        }));
      };
      return ApolloCache2;
    }();
    exports.Cache = void 0;
    (function(Cache) {
    })(exports.Cache || (exports.Cache = {}));
    var MissingFieldError = function(_super) {
      tslib.__extends(MissingFieldError2, _super);
      function MissingFieldError2(message, path, query, variables) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.path = path;
        _this.query = query;
        _this.variables = variables;
        _this.__proto__ = MissingFieldError2.prototype;
        return _this;
      }
      return MissingFieldError2;
    }(Error);
    var hasOwn = Object.prototype.hasOwnProperty;
    function getTypenameFromStoreObject(store, objectOrReference) {
      return utilities.isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
    }
    var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
    function fieldNameFromStoreName(storeFieldName) {
      var match = storeFieldName.match(TypeOrFieldNameRegExp);
      return match ? match[0] : storeFieldName;
    }
    function selectionSetMatchesResult(selectionSet, result, variables) {
      if (utilities.isNonNullObject(result)) {
        return Array.isArray(result) ? result.every(function(item) {
          return selectionSetMatchesResult(selectionSet, item, variables);
        }) : selectionSet.selections.every(function(field) {
          if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {
            var key = utilities.resultKeyNameFromField(field);
            return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
          }
          return true;
        });
      }
      return false;
    }
    function storeValueIsStoreObject(value) {
      return utilities.isNonNullObject(value) && !utilities.isReference(value) && !Array.isArray(value);
    }
    function makeProcessedFieldsMerger() {
      return new utilities.DeepMerger();
    }
    var DELETE = Object.create(null);
    var delModifier = function() {
      return DELETE;
    };
    var INVALIDATE = Object.create(null);
    exports.EntityStore = function() {
      function EntityStore(policies, group) {
        var _this = this;
        this.policies = policies;
        this.group = group;
        this.data = Object.create(null);
        this.rootIds = Object.create(null);
        this.refs = Object.create(null);
        this.getFieldValue = function(objectOrReference, storeFieldName) {
          return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
        };
        this.canRead = function(objOrRef) {
          return utilities.isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
        };
        this.toReference = function(objOrIdOrRef, mergeIntoStore) {
          if (typeof objOrIdOrRef === "string") {
            return utilities.makeReference(objOrIdOrRef);
          }
          if (utilities.isReference(objOrIdOrRef)) {
            return objOrIdOrRef;
          }
          var id = _this.policies.identify(objOrIdOrRef)[0];
          if (id) {
            var ref = utilities.makeReference(id);
            if (mergeIntoStore) {
              _this.merge(id, objOrIdOrRef);
            }
            return ref;
          }
        };
      }
      EntityStore.prototype.toObject = function() {
        return tslib.__assign({}, this.data);
      };
      EntityStore.prototype.has = function(dataId) {
        return this.lookup(dataId, true) !== void 0;
      };
      EntityStore.prototype.get = function(dataId, fieldName) {
        this.group.depend(dataId, fieldName);
        if (hasOwn.call(this.data, dataId)) {
          var storeObject = this.data[dataId];
          if (storeObject && hasOwn.call(storeObject, fieldName)) {
            return storeObject[fieldName];
          }
        }
        if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
          return this.policies.rootTypenamesById[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.get(dataId, fieldName);
        }
      };
      EntityStore.prototype.lookup = function(dataId, dependOnExistence) {
        if (dependOnExistence)
          this.group.depend(dataId, "__exists");
        if (hasOwn.call(this.data, dataId)) {
          return this.data[dataId];
        }
        if (this instanceof Layer) {
          return this.parent.lookup(dataId, dependOnExistence);
        }
        if (this.policies.rootTypenamesById[dataId]) {
          return Object.create(null);
        }
      };
      EntityStore.prototype.merge = function(older, newer) {
        var _this = this;
        var dataId;
        if (utilities.isReference(older))
          older = older.__ref;
        if (utilities.isReference(newer))
          newer = newer.__ref;
        var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
        var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
        if (!incoming)
          return;
        __DEV__ ? tsInvariant.invariant(typeof dataId === "string", "store.merge expects a string ID") : tsInvariant.invariant(typeof dataId === "string", 2);
        var merged = new utilities.DeepMerger(storeObjectReconciler).merge(existing, incoming);
        this.data[dataId] = merged;
        if (merged !== existing) {
          delete this.refs[dataId];
          if (this.group.caching) {
            var fieldsToDirty_1 = Object.create(null);
            if (!existing)
              fieldsToDirty_1.__exists = 1;
            Object.keys(incoming).forEach(function(storeFieldName) {
              if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                fieldsToDirty_1[storeFieldName] = 1;
                var fieldName = fieldNameFromStoreName(storeFieldName);
                if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                  fieldsToDirty_1[fieldName] = 1;
                }
                if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                  delete merged[storeFieldName];
                }
              }
            });
            if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
              delete fieldsToDirty_1.__typename;
            }
            Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
              return _this.group.dirty(dataId, fieldName);
            });
          }
        }
      };
      EntityStore.prototype.modify = function(dataId, fields) {
        var _this = this;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var changedFields_1 = Object.create(null);
          var needToMerge_1 = false;
          var allDeleted_1 = true;
          var sharedDetails_1 = {
            DELETE,
            INVALIDATE,
            isReference: utilities.isReference,
            toReference: this.toReference,
            canRead: this.canRead,
            readField: function(fieldNameOrOptions, from) {
              return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                fieldName: fieldNameOrOptions,
                from: from || utilities.makeReference(dataId)
              } : fieldNameOrOptions, { store: _this });
            }
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            var fieldName = fieldNameFromStoreName(storeFieldName);
            var fieldValue = storeObject[storeFieldName];
            if (fieldValue === void 0)
              return;
            var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
            if (modify) {
              var newValue = modify === delModifier ? DELETE : modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
              if (newValue === INVALIDATE) {
                _this.group.dirty(dataId, storeFieldName);
              } else {
                if (newValue === DELETE)
                  newValue = void 0;
                if (newValue !== fieldValue) {
                  changedFields_1[storeFieldName] = newValue;
                  needToMerge_1 = true;
                  fieldValue = newValue;
                }
              }
            }
            if (fieldValue !== void 0) {
              allDeleted_1 = false;
            }
          });
          if (needToMerge_1) {
            this.merge(dataId, changedFields_1);
            if (allDeleted_1) {
              if (this instanceof Layer) {
                this.data[dataId] = void 0;
              } else {
                delete this.data[dataId];
              }
              this.group.dirty(dataId, "__exists");
            }
            return true;
          }
        }
        return false;
      };
      EntityStore.prototype.delete = function(dataId, fieldName, args) {
        var _a;
        var storeObject = this.lookup(dataId);
        if (storeObject) {
          var typename = this.getFieldValue(storeObject, "__typename");
          var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
          return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);
        }
        return false;
      };
      EntityStore.prototype.evict = function(options2) {
        var evicted = false;
        if (options2.id) {
          if (hasOwn.call(this.data, options2.id)) {
            evicted = this.delete(options2.id, options2.fieldName, options2.args);
          }
          if (this instanceof Layer) {
            evicted = this.parent.evict(options2) || evicted;
          }
          if (options2.fieldName || evicted) {
            this.group.dirty(options2.id, options2.fieldName || "__exists");
          }
        }
        return evicted;
      };
      EntityStore.prototype.clear = function() {
        this.replace(null);
      };
      EntityStore.prototype.extract = function() {
        var _this = this;
        var obj = this.toObject();
        var extraRootIds = [];
        this.getRootIdSet().forEach(function(id) {
          if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
            extraRootIds.push(id);
          }
        });
        if (extraRootIds.length) {
          obj.__META = { extraRootIds: extraRootIds.sort() };
        }
        return obj;
      };
      EntityStore.prototype.replace = function(newData) {
        var _this = this;
        Object.keys(this.data).forEach(function(dataId) {
          if (!(newData && hasOwn.call(newData, dataId))) {
            _this.delete(dataId);
          }
        });
        if (newData) {
          var __META = newData.__META, rest_1 = tslib.__rest(newData, ["__META"]);
          Object.keys(rest_1).forEach(function(dataId) {
            _this.merge(dataId, rest_1[dataId]);
          });
          if (__META) {
            __META.extraRootIds.forEach(this.retain, this);
          }
        }
      };
      EntityStore.prototype.retain = function(rootId) {
        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
      };
      EntityStore.prototype.release = function(rootId) {
        if (this.rootIds[rootId] > 0) {
          var count = --this.rootIds[rootId];
          if (!count)
            delete this.rootIds[rootId];
          return count;
        }
        return 0;
      };
      EntityStore.prototype.getRootIdSet = function(ids) {
        if (ids === void 0) {
          ids = new Set();
        }
        Object.keys(this.rootIds).forEach(ids.add, ids);
        if (this instanceof Layer) {
          this.parent.getRootIdSet(ids);
        } else {
          Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
        }
        return ids;
      };
      EntityStore.prototype.gc = function() {
        var _this = this;
        var ids = this.getRootIdSet();
        var snapshot = this.toObject();
        ids.forEach(function(id) {
          if (hasOwn.call(snapshot, id)) {
            Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
            delete snapshot[id];
          }
        });
        var idsToRemove = Object.keys(snapshot);
        if (idsToRemove.length) {
          var root_1 = this;
          while (root_1 instanceof Layer)
            root_1 = root_1.parent;
          idsToRemove.forEach(function(id) {
            return root_1.delete(id);
          });
        }
        return idsToRemove;
      };
      EntityStore.prototype.findChildRefIds = function(dataId) {
        if (!hasOwn.call(this.refs, dataId)) {
          var found_1 = this.refs[dataId] = Object.create(null);
          var root = this.data[dataId];
          if (!root)
            return found_1;
          var workSet_1 = new Set([root]);
          workSet_1.forEach(function(obj) {
            if (utilities.isReference(obj)) {
              found_1[obj.__ref] = true;
            }
            if (utilities.isNonNullObject(obj)) {
              Object.keys(obj).forEach(function(key) {
                var child = obj[key];
                if (utilities.isNonNullObject(child)) {
                  workSet_1.add(child);
                }
              });
            }
          });
        }
        return this.refs[dataId];
      };
      EntityStore.prototype.makeCacheKey = function() {
        return this.group.keyMaker.lookupArray(arguments);
      };
      return EntityStore;
    }();
    var CacheGroup = function() {
      function CacheGroup2(caching, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.caching = caching;
        this.parent = parent;
        this.d = null;
        this.resetCaching();
      }
      CacheGroup2.prototype.resetCaching = function() {
        this.d = this.caching ? optimism.dep() : null;
        this.keyMaker = new trie.Trie(utilities.canUseWeakMap);
      };
      CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
        if (this.d) {
          this.d(makeDepKey(dataId, storeFieldName));
          var fieldName = fieldNameFromStoreName(storeFieldName);
          if (fieldName !== storeFieldName) {
            this.d(makeDepKey(dataId, fieldName));
          }
          if (this.parent) {
            this.parent.depend(dataId, storeFieldName);
          }
        }
      };
      CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
        if (this.d) {
          this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
        }
      };
      return CacheGroup2;
    }();
    function makeDepKey(dataId, storeFieldName) {
      return storeFieldName + "#" + dataId;
    }
    function maybeDependOnExistenceOfEntity(store, entityId) {
      if (supportsResultCaching(store)) {
        store.group.depend(entityId, "__exists");
      }
    }
    (function(EntityStore) {
      var Root2 = function(_super) {
        tslib.__extends(Root3, _super);
        function Root3(_a) {
          var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
          var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
          _this.stump = new Stump(_this);
          _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);
          if (seed)
            _this.replace(seed);
          return _this;
        }
        Root3.prototype.addLayer = function(layerId, replay) {
          return this.stump.addLayer(layerId, replay);
        };
        Root3.prototype.removeLayer = function() {
          return this;
        };
        Root3.prototype.getStorage = function() {
          return this.storageTrie.lookupArray(arguments);
        };
        return Root3;
      }(EntityStore);
      EntityStore.Root = Root2;
    })(exports.EntityStore || (exports.EntityStore = {}));
    var Layer = function(_super) {
      tslib.__extends(Layer2, _super);
      function Layer2(id, parent, replay, group) {
        var _this = _super.call(this, parent.policies, group) || this;
        _this.id = id;
        _this.parent = parent;
        _this.replay = replay;
        _this.group = group;
        replay(_this);
        return _this;
      }
      Layer2.prototype.addLayer = function(layerId, replay) {
        return new Layer2(layerId, this, replay, this.group);
      };
      Layer2.prototype.removeLayer = function(layerId) {
        var _this = this;
        var parent = this.parent.removeLayer(layerId);
        if (layerId === this.id) {
          if (this.group.caching) {
            Object.keys(this.data).forEach(function(dataId) {
              var ownStoreObject = _this.data[dataId];
              var parentStoreObject = parent["lookup"](dataId);
              if (!parentStoreObject) {
                _this.delete(dataId);
              } else if (!ownStoreObject) {
                _this.group.dirty(dataId, "__exists");
                Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                  _this.group.dirty(dataId, storeFieldName);
                });
              } else if (ownStoreObject !== parentStoreObject) {
                Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                  if (!equality.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                    _this.group.dirty(dataId, storeFieldName);
                  }
                });
              }
            });
          }
          return parent;
        }
        if (parent === this.parent)
          return this;
        return parent.addLayer(this.id, this.replay);
      };
      Layer2.prototype.toObject = function() {
        return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);
      };
      Layer2.prototype.findChildRefIds = function(dataId) {
        var fromParent = this.parent.findChildRefIds(dataId);
        return hasOwn.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
      };
      Layer2.prototype.getStorage = function() {
        var p = this.parent;
        while (p.parent)
          p = p.parent;
        return p.getStorage.apply(p, arguments);
      };
      return Layer2;
    }(exports.EntityStore);
    var Stump = function(_super) {
      tslib.__extends(Stump2, _super);
      function Stump2(root) {
        return _super.call(this, "EntityStore.Stump", root, function() {
        }, new CacheGroup(root.group.caching, root.group)) || this;
      }
      Stump2.prototype.removeLayer = function() {
        return this;
      };
      Stump2.prototype.merge = function() {
        return this.parent.merge.apply(this.parent, arguments);
      };
      return Stump2;
    }(Layer);
    function storeObjectReconciler(existingObject, incomingObject, property) {
      var existingValue = existingObject[property];
      var incomingValue = incomingObject[property];
      return equality.equal(existingValue, incomingValue) ? existingValue : incomingValue;
    }
    function supportsResultCaching(store) {
      return !!(store instanceof exports.EntityStore && store.group.caching);
    }
    function shallowCopy(value) {
      if (utilities.isNonNullObject(value)) {
        return Array.isArray(value) ? value.slice(0) : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
      }
      return value;
    }
    var ObjectCanon = function() {
      function ObjectCanon2() {
        this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();
        this.pool = new trie.Trie(utilities.canUseWeakMap);
        this.passes = new WeakMap();
        this.keysByJSON = new Map();
        this.empty = this.admit({});
      }
      ObjectCanon2.prototype.isKnown = function(value) {
        return utilities.isNonNullObject(value) && this.known.has(value);
      };
      ObjectCanon2.prototype.pass = function(value) {
        if (utilities.isNonNullObject(value)) {
          var copy = shallowCopy(value);
          this.passes.set(copy, value);
          return copy;
        }
        return value;
      };
      ObjectCanon2.prototype.admit = function(value) {
        var _this = this;
        if (utilities.isNonNullObject(value)) {
          var original = this.passes.get(value);
          if (original)
            return original;
          var proto = Object.getPrototypeOf(value);
          switch (proto) {
            case Array.prototype: {
              if (this.known.has(value))
                return value;
              var array = value.map(this.admit, this);
              var node = this.pool.lookupArray(array);
              if (!node.array) {
                this.known.add(node.array = array);
                if (__DEV__) {
                  Object.freeze(array);
                }
              }
              return node.array;
            }
            case null:
            case Object.prototype: {
              if (this.known.has(value))
                return value;
              var proto_1 = Object.getPrototypeOf(value);
              var array_1 = [proto_1];
              var keys = this.sortedKeys(value);
              array_1.push(keys.json);
              var firstValueIndex_1 = array_1.length;
              keys.sorted.forEach(function(key) {
                array_1.push(_this.admit(value[key]));
              });
              var node = this.pool.lookupArray(array_1);
              if (!node.object) {
                var obj_1 = node.object = Object.create(proto_1);
                this.known.add(obj_1);
                keys.sorted.forEach(function(key, i) {
                  obj_1[key] = array_1[firstValueIndex_1 + i];
                });
                if (__DEV__) {
                  Object.freeze(obj_1);
                }
              }
              return node.object;
            }
          }
        }
        return value;
      };
      ObjectCanon2.prototype.sortedKeys = function(obj) {
        var keys = Object.keys(obj);
        var node = this.pool.lookupArray(keys);
        if (!node.keys) {
          keys.sort();
          var json = JSON.stringify(keys);
          if (!(node.keys = this.keysByJSON.get(json))) {
            this.keysByJSON.set(json, node.keys = { sorted: keys, json });
          }
        }
        return node.keys;
      };
      return ObjectCanon2;
    }();
    var canonicalStringify = Object.assign(function(value) {
      if (utilities.isNonNullObject(value)) {
        if (stringifyCanon === void 0) {
          resetCanonicalStringify();
        }
        var canonical = stringifyCanon.admit(value);
        var json = stringifyCache.get(canonical);
        if (json === void 0) {
          stringifyCache.set(canonical, json = JSON.stringify(canonical));
        }
        return json;
      }
      return JSON.stringify(value);
    }, {
      reset: resetCanonicalStringify
    });
    var stringifyCanon;
    var stringifyCache;
    function resetCanonicalStringify() {
      stringifyCanon = new ObjectCanon();
      stringifyCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
    }
    function missingFromInvariant(err, context2) {
      return new MissingFieldError(err.message, context2.path.slice(), context2.query, context2.variables);
    }
    function execSelectionSetKeyArgs(options2) {
      return [
        options2.selectionSet,
        options2.objectOrReference,
        options2.context,
        options2.context.canonizeResults
      ];
    }
    var StoreReader = function() {
      function StoreReader2(config) {
        var _this = this;
        this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.config = tslib.__assign(tslib.__assign({}, config), { addTypename: config.addTypename !== false });
        this.canon = config.canon || new ObjectCanon();
        this.executeSelectionSet = optimism.wrap(function(options2) {
          var _a;
          var canonizeResults = options2.context.canonizeResults;
          var peekArgs = execSelectionSetKeyArgs(options2);
          peekArgs[3] = !canonizeResults;
          var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
          if (other) {
            if (canonizeResults) {
              return tslib.__assign(tslib.__assign({}, other), { result: _this.canon.admit(other.result) });
            }
            return other;
          }
          maybeDependOnExistenceOfEntity(options2.context.store, options2.enclosingRef.__ref);
          return _this.execSelectionSetImpl(options2);
        }, {
          max: this.config.resultCacheMaxSize,
          keyArgs: execSelectionSetKeyArgs,
          makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
            if (supportsResultCaching(context2.store)) {
              return context2.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
            }
          }
        });
        this.executeSubSelectedArray = optimism.wrap(function(options2) {
          maybeDependOnExistenceOfEntity(options2.context.store, options2.enclosingRef.__ref);
          return _this.execSubSelectedArrayImpl(options2);
        }, {
          max: this.config.resultCacheMaxSize,
          makeCacheKey: function(_a) {
            var field = _a.field, array = _a.array, context2 = _a.context;
            if (supportsResultCaching(context2.store)) {
              return context2.store.makeCacheKey(field, array, context2.varString);
            }
          }
        });
      }
      StoreReader2.prototype.resetCanon = function() {
        this.canon = new ObjectCanon();
      };
      StoreReader2.prototype.diffQueryAgainstStore = function(_a) {
        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? true : _d;
        var policies = this.config.cache.policies;
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);
        var rootRef = utilities.makeReference(rootId);
        var execResult = this.executeSelectionSet({
          selectionSet: utilities.getMainDefinition(query).selectionSet,
          objectOrReference: rootRef,
          enclosingRef: rootRef,
          context: {
            store,
            query,
            policies,
            variables,
            varString: canonicalStringify(variables),
            canonizeResults,
            fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
            path: []
          }
        });
        var hasMissingFields = execResult.missing && execResult.missing.length > 0;
        if (hasMissingFields && !returnPartialData) {
          throw execResult.missing[0];
        }
        return {
          result: execResult.result,
          missing: execResult.missing,
          complete: !hasMissingFields
        };
      };
      StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context2) {
        if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
          var latest = this.executeSelectionSet.peek(selectionSet, parent, context2, this.canon.isKnown(result));
          if (latest && result === latest.result) {
            return true;
          }
        }
        return false;
      };
      StoreReader2.prototype.execSelectionSetImpl = function(_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context2 = _a.context;
        if (utilities.isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
          return {
            result: this.canon.empty,
            missing: [missingFromInvariant(__DEV__ ? new tsInvariant.InvariantError("Dangling reference to missing " + objectOrReference.__ref + " object") : new tsInvariant.InvariantError(6), context2)]
          };
        }
        var variables = context2.variables, policies = context2.policies, store = context2.store;
        var objectsToMerge = [];
        var finalResult = { result: null };
        var typename = store.getFieldValue(objectOrReference, "__typename");
        if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
          objectsToMerge.push({ __typename: typename });
        }
        function getMissing() {
          return finalResult.missing || (finalResult.missing = []);
        }
        function handleMissing(result) {
          var _a2;
          if (result.missing)
            (_a2 = getMissing()).push.apply(_a2, result.missing);
          return result.result;
        }
        var workSet = new Set(selectionSet.selections);
        workSet.forEach(function(selection) {
          var _a2;
          if (!utilities.shouldInclude(selection, variables))
            return;
          if (utilities.isField(selection)) {
            var fieldValue = policies.readField({
              fieldName: selection.name.value,
              field: selection,
              variables: context2.variables,
              from: objectOrReference
            }, context2);
            var resultName = utilities.resultKeyNameFromField(selection);
            context2.path.push(resultName);
            if (fieldValue === void 0) {
              if (!utilities.addTypenameToDocument.added(selection)) {
                getMissing().push(missingFromInvariant(__DEV__ ? new tsInvariant.InvariantError("Can't find field '" + selection.name.value + "' on " + (utilities.isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2))) : new tsInvariant.InvariantError(7), context2));
              }
            } else if (Array.isArray(fieldValue)) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context: context2
              }));
            } else if (!selection.selectionSet) {
              if (context2.canonizeResults) {
                fieldValue = _this.canon.pass(fieldValue);
              }
            } else if (fieldValue != null) {
              fieldValue = handleMissing(_this.executeSelectionSet({
                selectionSet: selection.selectionSet,
                objectOrReference: fieldValue,
                enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,
                context: context2
              }));
            }
            if (fieldValue !== void 0) {
              objectsToMerge.push((_a2 = {}, _a2[resultName] = fieldValue, _a2));
            }
            tsInvariant.invariant(context2.path.pop() === resultName);
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context2.fragmentMap);
            if (fragment && policies.fragmentMatches(fragment, typename)) {
              fragment.selectionSet.selections.forEach(workSet.add, workSet);
            }
          }
        });
        var merged = utilities.mergeDeepArray(objectsToMerge);
        finalResult.result = context2.canonizeResults ? this.canon.admit(merged) : utilities.maybeDeepFreeze(merged);
        this.knownResults.set(finalResult.result, selectionSet);
        return finalResult;
      };
      StoreReader2.prototype.execSubSelectedArrayImpl = function(_a) {
        var _this = this;
        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context2 = _a.context;
        var missing;
        function handleMissing(childResult, i) {
          if (childResult.missing) {
            missing = missing || [];
            missing.push.apply(missing, childResult.missing);
          }
          tsInvariant.invariant(context2.path.pop() === i);
          return childResult.result;
        }
        if (field.selectionSet) {
          array = array.filter(context2.store.canRead);
        }
        array = array.map(function(item, i) {
          if (item === null) {
            return null;
          }
          context2.path.push(i);
          if (Array.isArray(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              enclosingRef,
              context: context2
            }), i);
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              objectOrReference: item,
              enclosingRef: utilities.isReference(item) ? item : enclosingRef,
              context: context2
            }), i);
          }
          if (__DEV__) {
            assertSelectionSetForIdValue(context2.store, field, item);
          }
          tsInvariant.invariant(context2.path.pop() === i);
          return item;
        });
        return {
          result: context2.canonizeResults ? this.canon.admit(array) : array,
          missing
        };
      };
      return StoreReader2;
    }();
    function assertSelectionSetForIdValue(store, field, fieldValue) {
      if (!field.selectionSet) {
        var workSet_1 = new Set([fieldValue]);
        workSet_1.forEach(function(value) {
          if (utilities.isNonNullObject(value)) {
            __DEV__ ? tsInvariant.invariant(!utilities.isReference(value), "Missing selection set for object of type " + getTypenameFromStoreObject(store, value) + " returned for query field " + field.name.value) : tsInvariant.invariant(!utilities.isReference(value), 8);
            Object.values(value).forEach(workSet_1.add, workSet_1);
          }
        });
      }
    }
    var StoreWriter = function() {
      function StoreWriter2(cache, reader) {
        this.cache = cache;
        this.reader = reader;
      }
      StoreWriter2.prototype.writeToStore = function(store, _a) {
        var _this = this;
        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
        var operationDefinition = utilities.getOperationDefinition(query);
        var merger = makeProcessedFieldsMerger();
        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);
        var context2 = {
          store,
          written: Object.create(null),
          merge: function(existing, incoming) {
            return merger.merge(existing, incoming);
          },
          variables,
          varString: canonicalStringify(variables),
          fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
          overwrite: !!overwrite,
          incomingById: new Map(),
          clientOnly: false
        };
        var ref = this.processSelectionSet({
          result: result || Object.create(null),
          dataId,
          selectionSet: operationDefinition.selectionSet,
          mergeTree: { map: new Map() },
          context: context2
        });
        if (!utilities.isReference(ref)) {
          throw __DEV__ ? new tsInvariant.InvariantError("Could not identify object " + JSON.stringify(result)) : new tsInvariant.InvariantError(9);
        }
        context2.incomingById.forEach(function(_a2, dataId2) {
          var fields = _a2.fields, mergeTree = _a2.mergeTree, selections = _a2.selections;
          var entityRef = utilities.makeReference(dataId2);
          if (mergeTree && mergeTree.map.size) {
            var applied = _this.applyMerges(mergeTree, entityRef, fields, context2);
            if (utilities.isReference(applied)) {
              return;
            }
            fields = applied;
          }
          if (__DEV__ && !context2.overwrite) {
            var hasSelectionSet_1 = function(storeFieldName) {
              return fieldsWithSelectionSets_1.has(fieldNameFromStoreName(storeFieldName));
            };
            var fieldsWithSelectionSets_1 = new Set();
            selections.forEach(function(selection) {
              if (utilities.isField(selection) && selection.selectionSet) {
                fieldsWithSelectionSets_1.add(selection.name.value);
              }
            });
            var hasMergeFunction_1 = function(storeFieldName) {
              var childTree = mergeTree && mergeTree.map.get(storeFieldName);
              return Boolean(childTree && childTree.info && childTree.info.merge);
            };
            Object.keys(fields).forEach(function(storeFieldName) {
              if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                warnAboutDataLoss(entityRef, fields, storeFieldName, context2.store);
              }
            });
          }
          store.merge(dataId2, fields);
        });
        store.retain(ref.__ref);
        return ref;
      };
      StoreWriter2.prototype.processSelectionSet = function(_a) {
        var _this = this;
        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context2 = _a.context, mergeTree = _a.mergeTree;
        var policies = this.cache.policies;
        var _b = policies.identify(result, selectionSet, context2.fragmentMap), id = _b[0], keyObject = _b[1];
        dataId = dataId || id;
        if (typeof dataId === "string") {
          var sets = context2.written[dataId] || (context2.written[dataId] = []);
          var ref = utilities.makeReference(dataId);
          if (sets.indexOf(selectionSet) >= 0)
            return ref;
          sets.push(selectionSet);
          if (this.reader && this.reader.isFresh(result, ref, selectionSet, context2)) {
            return ref;
          }
        }
        var incomingFields = Object.create(null);
        if (keyObject) {
          incomingFields = context2.merge(incomingFields, keyObject);
        }
        var typename = dataId && policies.rootTypenamesById[dataId] || utilities.getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
        if (typeof typename === "string") {
          incomingFields.__typename = typename;
        }
        var selections = new Set(selectionSet.selections);
        selections.forEach(function(selection) {
          var _a2;
          if (!utilities.shouldInclude(selection, context2.variables))
            return;
          if (utilities.isField(selection)) {
            var resultFieldKey = utilities.resultKeyNameFromField(selection);
            var value = result[resultFieldKey];
            var wasClientOnly = context2.clientOnly;
            context2.clientOnly = wasClientOnly || !!(selection.directives && selection.directives.some(function(d2) {
              return d2.name.value === "client";
            }));
            if (value !== void 0) {
              var storeFieldName = policies.getStoreFieldName({
                typename,
                fieldName: selection.name.value,
                field: selection,
                variables: context2.variables
              });
              var childTree = getChildMergeTree(mergeTree, storeFieldName);
              var incomingValue = _this.processFieldValue(value, selection, context2, childTree);
              var childTypename = void 0;
              if (selection.selectionSet) {
                childTypename = context2.store.getFieldValue(incomingValue, "__typename");
                if (!childTypename && utilities.isReference(incomingValue)) {
                  var info = context2.incomingById.get(incomingValue.__ref);
                  childTypename = info && info.fields.__typename;
                }
              }
              var merge = policies.getMergeFunction(typename, selection.name.value, childTypename);
              if (merge) {
                childTree.info = {
                  field: selection,
                  typename,
                  merge
                };
              } else {
                maybeRecycleChildMergeTree(mergeTree, storeFieldName);
              }
              incomingFields = context2.merge(incomingFields, (_a2 = {}, _a2[storeFieldName] = incomingValue, _a2));
            } else if (!context2.clientOnly && !utilities.addTypenameToDocument.added(selection)) {
              __DEV__ && tsInvariant.invariant.error(("Missing field '" + utilities.resultKeyNameFromField(selection) + "' while writing result " + JSON.stringify(result, null, 2)).substring(0, 1e3));
            }
            context2.clientOnly = wasClientOnly;
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, context2.fragmentMap);
            if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
              fragment.selectionSet.selections.forEach(selections.add, selections);
            }
          }
        });
        if (typeof dataId === "string") {
          var previous = context2.incomingById.get(dataId);
          if (previous) {
            previous.fields = context2.merge(previous.fields, incomingFields);
            previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);
            previous.selections.forEach(selections.add, selections);
            previous.selections = selections;
          } else {
            context2.incomingById.set(dataId, {
              fields: incomingFields,
              mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
              selections
            });
          }
          return utilities.makeReference(dataId);
        }
        return incomingFields;
      };
      StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
        var _this = this;
        if (!field.selectionSet || value === null) {
          return __DEV__ ? utilities.cloneDeep(value) : value;
        }
        if (Array.isArray(value)) {
          return value.map(function(item, i) {
            var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i));
            maybeRecycleChildMergeTree(mergeTree, i);
            return value2;
          });
        }
        return this.processSelectionSet({
          result: value,
          selectionSet: field.selectionSet,
          context: context2,
          mergeTree
        });
      };
      StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
        var _a;
        var _this = this;
        if (mergeTree.map.size && !utilities.isReference(incoming)) {
          var e_1 = !Array.isArray(incoming) && (utilities.isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
          var i_1 = incoming;
          if (e_1 && !getStorageArgs) {
            getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];
          }
          var changedFields_1;
          var getValue_1 = function(from, name) {
            return Array.isArray(from) ? typeof name === "number" ? from[name] : void 0 : context2.store.getFieldValue(from, String(name));
          };
          mergeTree.map.forEach(function(childTree, storeFieldName) {
            var eVal = getValue_1(e_1, storeFieldName);
            var iVal = getValue_1(i_1, storeFieldName);
            if (iVal === void 0)
              return;
            if (getStorageArgs) {
              getStorageArgs.push(storeFieldName);
            }
            var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
            if (aVal !== iVal) {
              changedFields_1 = changedFields_1 || new Map();
              changedFields_1.set(storeFieldName, aVal);
            }
            if (getStorageArgs) {
              tsInvariant.invariant(getStorageArgs.pop() === storeFieldName);
            }
          });
          if (changedFields_1) {
            incoming = Array.isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1);
            changedFields_1.forEach(function(value, name) {
              incoming[name] = value;
            });
          }
        }
        if (mergeTree.info) {
          return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a = context2.store).getStorage.apply(_a, getStorageArgs));
        }
        return incoming;
      };
      return StoreWriter2;
    }();
    var emptyMergeTreePool = [];
    function getChildMergeTree(_a, name) {
      var map = _a.map;
      if (!map.has(name)) {
        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });
      }
      return map.get(name);
    }
    function mergeMergeTrees(left, right) {
      if (left === right || !right || mergeTreeIsEmpty(right))
        return left;
      if (!left || mergeTreeIsEmpty(left))
        return right;
      var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;
      var needToMergeMaps = left.map.size && right.map.size;
      var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;
      var merged = { info, map };
      if (needToMergeMaps) {
        var remainingRightKeys_1 = new Set(right.map.keys());
        left.map.forEach(function(leftTree, key) {
          merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
          remainingRightKeys_1.delete(key);
        });
        remainingRightKeys_1.forEach(function(key) {
          merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
        });
      }
      return merged;
    }
    function mergeTreeIsEmpty(tree) {
      return !tree || !(tree.info || tree.map.size);
    }
    function maybeRecycleChildMergeTree(_a, name) {
      var map = _a.map;
      var childTree = map.get(name);
      if (childTree && mergeTreeIsEmpty(childTree)) {
        emptyMergeTreePool.push(childTree);
        map.delete(name);
      }
    }
    var warnings = new Set();
    function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
      var getChild = function(objOrRef) {
        var child = store.getFieldValue(objOrRef, storeFieldName);
        return typeof child === "object" && child;
      };
      var existing = getChild(existingRef);
      if (!existing)
        return;
      var incoming = getChild(incomingObj);
      if (!incoming)
        return;
      if (utilities.isReference(existing))
        return;
      if (equality.equal(existing, incoming))
        return;
      if (Object.keys(existing).every(function(key) {
        return store.getFieldValue(incoming, key) !== void 0;
      })) {
        return;
      }
      var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var typeDotName = parentType + "." + fieldName;
      if (warnings.has(typeDotName))
        return;
      warnings.add(typeDotName);
      var childTypenames = [];
      if (!Array.isArray(existing) && !Array.isArray(incoming)) {
        [existing, incoming].forEach(function(child) {
          var typename = store.getFieldValue(child, "__typename");
          if (typeof typename === "string" && !childTypenames.includes(typename)) {
            childTypenames.push(typename);
          }
        });
      }
      __DEV__ && tsInvariant.invariant.warn("Cache data may be lost when replacing the " + fieldName + " field of a " + parentType + " object.\n\nTo address this problem (which is not a bug in Apollo Client), " + (childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "") + "define a custom merge function for the " + typeDotName + " field, so InMemoryCache can safely merge these objects:\n\n  existing: " + JSON.stringify(existing).slice(0, 1e3) + "\n  incoming: " + JSON.stringify(incoming).slice(0, 1e3) + "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n");
    }
    var cacheSlot = new context.Slot();
    var cacheInfoMap = new WeakMap();
    function getCacheInfo(cache) {
      var info = cacheInfoMap.get(cache);
      if (!info) {
        cacheInfoMap.set(cache, info = {
          vars: new Set(),
          dep: optimism.dep()
        });
      }
      return info;
    }
    function forgetCache(cache) {
      getCacheInfo(cache).vars.forEach(function(rv) {
        return rv.forgetCache(cache);
      });
    }
    function recallCache(cache) {
      getCacheInfo(cache).vars.forEach(function(rv) {
        return rv.attachCache(cache);
      });
    }
    function makeVar(value) {
      var caches = new Set();
      var listeners = new Set();
      var rv = function(newValue) {
        if (arguments.length > 0) {
          if (value !== newValue) {
            value = newValue;
            caches.forEach(function(cache2) {
              getCacheInfo(cache2).dep.dirty(rv);
              broadcast(cache2);
            });
            var oldListeners = Array.from(listeners);
            listeners.clear();
            oldListeners.forEach(function(listener) {
              return listener(value);
            });
          }
        } else {
          var cache = cacheSlot.getValue();
          if (cache) {
            attach(cache);
            getCacheInfo(cache).dep(rv);
          }
        }
        return value;
      };
      rv.onNextChange = function(listener) {
        listeners.add(listener);
        return function() {
          listeners.delete(listener);
        };
      };
      var attach = rv.attachCache = function(cache) {
        caches.add(cache);
        getCacheInfo(cache).vars.add(rv);
        return rv;
      };
      rv.forgetCache = function(cache) {
        return caches.delete(cache);
      };
      return rv;
    }
    function broadcast(cache) {
      if (cache.broadcastWatches) {
        cache.broadcastWatches();
      }
    }
    utilities.getStoreKeyName.setStringify(canonicalStringify);
    function argsFromFieldSpecifier(spec) {
      return spec.args !== void 0 ? spec.args : spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;
    }
    var defaultDataIdFromObject = function(_a, context2) {
      var __typename = _a.__typename, id = _a.id, _id = _a._id;
      if (typeof __typename === "string") {
        if (context2) {
          context2.keyObject = id !== void 0 ? { id } : _id !== void 0 ? { _id } : void 0;
        }
        if (id === void 0)
          id = _id;
        if (id !== void 0) {
          return __typename + ":" + (typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
        }
      }
    };
    var nullKeyFieldsFn = function() {
      return void 0;
    };
    var simpleKeyArgsFn = function(_args, context2) {
      return context2.fieldName;
    };
    var mergeTrueFn = function(existing, incoming, _a) {
      var mergeObjects = _a.mergeObjects;
      return mergeObjects(existing, incoming);
    };
    var mergeFalseFn = function(_, incoming) {
      return incoming;
    };
    var Policies = function() {
      function Policies2(config) {
        this.config = config;
        this.typePolicies = Object.create(null);
        this.toBeAdded = Object.create(null);
        this.supertypeMap = new Map();
        this.fuzzySubtypes = new Map();
        this.rootIdsByTypename = Object.create(null);
        this.rootTypenamesById = Object.create(null);
        this.usingPossibleTypes = false;
        this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject }, config);
        this.cache = this.config.cache;
        this.setRootTypename("Query");
        this.setRootTypename("Mutation");
        this.setRootTypename("Subscription");
        if (config.possibleTypes) {
          this.addPossibleTypes(config.possibleTypes);
        }
        if (config.typePolicies) {
          this.addTypePolicies(config.typePolicies);
        }
      }
      Policies2.prototype.identify = function(object, selectionSet, fragmentMap) {
        var typename = selectionSet && fragmentMap ? utilities.getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;
        if (typename === this.rootTypenamesById.ROOT_QUERY) {
          return ["ROOT_QUERY"];
        }
        var context2 = {
          typename,
          selectionSet,
          fragmentMap
        };
        var id;
        var policy = typename && this.getTypePolicy(typename);
        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
        while (keyFn) {
          var specifierOrId = keyFn(object, context2);
          if (Array.isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier(specifierOrId);
          } else {
            id = specifierOrId;
            break;
          }
        }
        id = id ? String(id) : void 0;
        return context2.keyObject ? [id, context2.keyObject] : [id];
      };
      Policies2.prototype.addTypePolicies = function(typePolicies) {
        var _this = this;
        Object.keys(typePolicies).forEach(function(typename) {
          var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = tslib.__rest(_a, ["queryType", "mutationType", "subscriptionType"]);
          if (queryType)
            _this.setRootTypename("Query", typename);
          if (mutationType)
            _this.setRootTypename("Mutation", typename);
          if (subscriptionType)
            _this.setRootTypename("Subscription", typename);
          if (hasOwn.call(_this.toBeAdded, typename)) {
            _this.toBeAdded[typename].push(incoming);
          } else {
            _this.toBeAdded[typename] = [incoming];
          }
        });
      };
      Policies2.prototype.updateTypePolicy = function(typename, incoming) {
        var _this = this;
        var existing = this.getTypePolicy(typename);
        var keyFields = incoming.keyFields, fields = incoming.fields;
        function setMerge(existing2, merge) {
          existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
        }
        setMerge(existing, incoming.merge);
        existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
        if (fields) {
          Object.keys(fields).forEach(function(fieldName) {
            var existing2 = _this.getFieldPolicy(typename, fieldName, true);
            var incoming2 = fields[fieldName];
            if (typeof incoming2 === "function") {
              existing2.read = incoming2;
            } else {
              var keyArgs = incoming2.keyArgs, read2 = incoming2.read, merge = incoming2.merge;
              existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
              if (typeof read2 === "function") {
                existing2.read = read2;
              }
              setMerge(existing2, merge);
            }
            if (existing2.read && existing2.merge) {
              existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
            }
          });
        }
      };
      Policies2.prototype.setRootTypename = function(which, typename) {
        if (typename === void 0) {
          typename = which;
        }
        var rootId = "ROOT_" + which.toUpperCase();
        var old = this.rootTypenamesById[rootId];
        if (typename !== old) {
          __DEV__ ? tsInvariant.invariant(!old || old === which, "Cannot change root " + which + " __typename more than once") : tsInvariant.invariant(!old || old === which, 3);
          if (old)
            delete this.rootIdsByTypename[old];
          this.rootIdsByTypename[typename] = rootId;
          this.rootTypenamesById[rootId] = typename;
        }
      };
      Policies2.prototype.addPossibleTypes = function(possibleTypes) {
        var _this = this;
        this.usingPossibleTypes = true;
        Object.keys(possibleTypes).forEach(function(supertype) {
          _this.getSupertypeSet(supertype, true);
          possibleTypes[supertype].forEach(function(subtype) {
            _this.getSupertypeSet(subtype, true).add(supertype);
            var match = subtype.match(TypeOrFieldNameRegExp);
            if (!match || match[0] !== subtype) {
              _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
            }
          });
        });
      };
      Policies2.prototype.getTypePolicy = function(typename) {
        var _this = this;
        if (!hasOwn.call(this.typePolicies, typename)) {
          var policy_1 = this.typePolicies[typename] = Object.create(null);
          policy_1.fields = Object.create(null);
          var supertypes = this.supertypeMap.get(typename);
          if (supertypes && supertypes.size) {
            supertypes.forEach(function(supertype) {
              var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = tslib.__rest(_a, ["fields"]);
              Object.assign(policy_1, rest);
              Object.assign(policy_1.fields, fields);
            });
          }
        }
        var inbox = this.toBeAdded[typename];
        if (inbox && inbox.length) {
          inbox.splice(0).forEach(function(policy) {
            _this.updateTypePolicy(typename, policy);
          });
        }
        return this.typePolicies[typename];
      };
      Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
        if (typename) {
          var fieldPolicies = this.getTypePolicy(typename).fields;
          return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));
        }
      };
      Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
        var supertypeSet = this.supertypeMap.get(subtype);
        if (!supertypeSet && createIfMissing) {
          this.supertypeMap.set(subtype, supertypeSet = new Set());
        }
        return supertypeSet;
      };
      Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
        var _this = this;
        if (!fragment.typeCondition)
          return true;
        if (!typename)
          return false;
        var supertype = fragment.typeCondition.name.value;
        if (typename === supertype)
          return true;
        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
          var typenameSupertypeSet = this.getSupertypeSet(typename, true);
          var workQueue_1 = [typenameSupertypeSet];
          var maybeEnqueue_1 = function(subtype) {
            var supertypeSet2 = _this.getSupertypeSet(subtype, false);
            if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
              workQueue_1.push(supertypeSet2);
            }
          };
          var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
          var checkingFuzzySubtypes = false;
          for (var i = 0; i < workQueue_1.length; ++i) {
            var supertypeSet = workQueue_1[i];
            if (supertypeSet.has(supertype)) {
              if (!typenameSupertypeSet.has(supertype)) {
                if (checkingFuzzySubtypes) {
                  __DEV__ && tsInvariant.invariant.warn("Inferring subtype " + typename + " of supertype " + supertype);
                }
                typenameSupertypeSet.add(supertype);
              }
              return true;
            }
            supertypeSet.forEach(maybeEnqueue_1);
            if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
              needToCheckFuzzySubtypes = false;
              checkingFuzzySubtypes = true;
              this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                var match = typename.match(regExp);
                if (match && match[0] === typename) {
                  maybeEnqueue_1(fuzzyString);
                }
              });
            }
          }
        }
        return false;
      };
      Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
        var policy = this.getFieldPolicy(typename, fieldName, false);
        return !!(policy && policy.keyFn);
      };
      Policies2.prototype.getStoreFieldName = function(fieldSpec) {
        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
        var policy = this.getFieldPolicy(typename, fieldName, false);
        var storeFieldName;
        var keyFn = policy && policy.keyFn;
        if (keyFn && typename) {
          var context2 = {
            typename,
            fieldName,
            field: fieldSpec.field || null,
            variables: fieldSpec.variables
          };
          var args = argsFromFieldSpecifier(fieldSpec);
          while (keyFn) {
            var specifierOrString = keyFn(args, context2);
            if (Array.isArray(specifierOrString)) {
              keyFn = keyArgsFnFromSpecifier(specifierOrString);
            } else {
              storeFieldName = specifierOrString || fieldName;
              break;
            }
          }
        }
        if (storeFieldName === void 0) {
          storeFieldName = fieldSpec.field ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
        }
        if (storeFieldName === false) {
          return fieldName;
        }
        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
      };
      Policies2.prototype.readField = function(options2, context2) {
        var objectOrReference = options2.from;
        if (!objectOrReference)
          return;
        var nameOrField = options2.field || options2.fieldName;
        if (!nameOrField)
          return;
        if (options2.typename === void 0) {
          var typename = context2.store.getFieldValue(objectOrReference, "__typename");
          if (typename)
            options2.typename = typename;
        }
        var storeFieldName = this.getStoreFieldName(options2);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
        var policy = this.getFieldPolicy(options2.typename, fieldName, false);
        var read2 = policy && policy.read;
        if (read2) {
          var readOptions = makeFieldFunctionOptions(this, objectOrReference, options2, context2, context2.store.getStorage(utilities.isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
          return cacheSlot.withValue(this.cache, read2, [existing, readOptions]);
        }
        return existing;
      };
      Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
        var policy = this.getFieldPolicy(parentTypename, fieldName, false);
        var merge = policy && policy.merge;
        if (!merge && childTypename) {
          policy = this.getTypePolicy(childTypename);
          merge = policy && policy.merge;
        }
        return merge;
      };
      Policies2.prototype.runMergeFunction = function(existing, incoming, _a, context2, storage) {
        var field = _a.field, typename = _a.typename, merge = _a.merge;
        if (merge === mergeTrueFn) {
          return makeMergeObjectsFunction(context2.store)(existing, incoming);
        }
        if (merge === mergeFalseFn) {
          return incoming;
        }
        if (context2.overwrite) {
          existing = void 0;
        }
        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename, fieldName: field.name.value, field, variables: context2.variables }, context2, storage || Object.create(null)));
      };
      return Policies2;
    }();
    function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
      var storeFieldName = policies.getStoreFieldName(fieldSpec);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var variables = fieldSpec.variables || context2.variables;
      var _a = context2.store, toReference = _a.toReference, canRead = _a.canRead;
      return {
        args: argsFromFieldSpecifier(fieldSpec),
        field: fieldSpec.field || null,
        fieldName,
        storeFieldName,
        variables,
        isReference: utilities.isReference,
        toReference,
        storage,
        cache: policies.cache,
        canRead,
        readField: function(fieldNameOrOptions, from) {
          var options2;
          if (typeof fieldNameOrOptions === "string") {
            options2 = {
              fieldName: fieldNameOrOptions,
              from: arguments.length > 1 ? from : objectOrReference
            };
          } else if (utilities.isNonNullObject(fieldNameOrOptions)) {
            options2 = tslib.__assign({}, fieldNameOrOptions);
            if (!hasOwn.call(fieldNameOrOptions, "from")) {
              options2.from = objectOrReference;
            }
          } else {
            __DEV__ && tsInvariant.invariant.warn("Unexpected readField arguments: " + utilities.stringifyForDisplay(Array.from(arguments)));
            return;
          }
          if (__DEV__ && options2.from === void 0) {
            __DEV__ && tsInvariant.invariant.warn("Undefined 'from' passed to readField with arguments " + utilities.stringifyForDisplay(Array.from(arguments)));
          }
          if (options2.variables === void 0) {
            options2.variables = variables;
          }
          return policies.readField(options2, context2);
        },
        mergeObjects: makeMergeObjectsFunction(context2.store)
      };
    }
    function makeMergeObjectsFunction(store) {
      return function mergeObjects(existing, incoming) {
        if (Array.isArray(existing) || Array.isArray(incoming)) {
          throw __DEV__ ? new tsInvariant.InvariantError("Cannot automatically merge arrays") : new tsInvariant.InvariantError(4);
        }
        if (utilities.isNonNullObject(existing) && utilities.isNonNullObject(incoming)) {
          var eType = store.getFieldValue(existing, "__typename");
          var iType = store.getFieldValue(incoming, "__typename");
          var typesDiffer = eType && iType && eType !== iType;
          if (typesDiffer) {
            return incoming;
          }
          if (utilities.isReference(existing) && storeValueIsStoreObject(incoming)) {
            store.merge(existing.__ref, incoming);
            return existing;
          }
          if (storeValueIsStoreObject(existing) && utilities.isReference(incoming)) {
            store.merge(existing, incoming.__ref);
            return incoming;
          }
          if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
            return tslib.__assign(tslib.__assign({}, existing), incoming);
          }
        }
        return incoming;
      };
    }
    function keyArgsFnFromSpecifier(specifier) {
      return function(args, context2) {
        return args ? context2.fieldName + ":" + JSON.stringify(computeKeyObject(args, specifier, false)) : context2.fieldName;
      };
    }
    function keyFieldsFnFromSpecifier(specifier) {
      var trie$1 = new trie.Trie(utilities.canUseWeakMap);
      return function(object, context2) {
        var aliasMap;
        if (context2.selectionSet && context2.fragmentMap) {
          var info = trie$1.lookupArray([
            context2.selectionSet,
            context2.fragmentMap
          ]);
          aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context2.selectionSet, context2.fragmentMap));
        }
        var keyObject = context2.keyObject = computeKeyObject(object, specifier, true, aliasMap);
        return context2.typename + ":" + JSON.stringify(keyObject);
      };
    }
    function makeAliasMap(selectionSet, fragmentMap) {
      var map = Object.create(null);
      var workQueue = new Set([selectionSet]);
      workQueue.forEach(function(selectionSet2) {
        selectionSet2.selections.forEach(function(selection) {
          if (utilities.isField(selection)) {
            if (selection.alias) {
              var responseKey = selection.alias.value;
              var storeKey = selection.name.value;
              if (storeKey !== responseKey) {
                var aliases = map.aliases || (map.aliases = Object.create(null));
                aliases[storeKey] = responseKey;
              }
            }
            if (selection.selectionSet) {
              var subsets = map.subsets || (map.subsets = Object.create(null));
              subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);
            }
          } else {
            var fragment = utilities.getFragmentFromSelection(selection, fragmentMap);
            if (fragment) {
              workQueue.add(fragment.selectionSet);
            }
          }
        });
      });
      return map;
    }
    function computeKeyObject(response, specifier, strict, aliasMap) {
      var keyObj = Object.create(null);
      var prevKey;
      specifier.forEach(function(s2) {
        if (Array.isArray(s2)) {
          if (typeof prevKey === "string") {
            var subsets = aliasMap && aliasMap.subsets;
            var subset = subsets && subsets[prevKey];
            keyObj[prevKey] = computeKeyObject(response[prevKey], s2, strict, subset);
          }
        } else {
          var aliases = aliasMap && aliasMap.aliases;
          var responseName = aliases && aliases[s2] || s2;
          if (hasOwn.call(response, responseName)) {
            keyObj[prevKey = s2] = response[responseName];
          } else {
            __DEV__ ? tsInvariant.invariant(!strict, "Missing field '" + responseName + "' while computing key fields") : tsInvariant.invariant(!strict, 5);
            prevKey = void 0;
          }
        }
      });
      return keyObj;
    }
    var defaultConfig = {
      dataIdFromObject: defaultDataIdFromObject,
      addTypename: true,
      resultCaching: true,
      typePolicies: {}
    };
    var InMemoryCache2 = function(_super) {
      tslib.__extends(InMemoryCache3, _super);
      function InMemoryCache3(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = new Set();
        _this.typenameDocumentCache = new Map();
        _this.makeVar = makeVar;
        _this.txCount = 0;
        _this.config = tslib.__assign(tslib.__assign({}, defaultConfig), config);
        _this.addTypename = !!_this.config.addTypename;
        _this.policies = new Policies({
          cache: _this,
          dataIdFromObject: _this.config.dataIdFromObject,
          possibleTypes: _this.config.possibleTypes,
          typePolicies: _this.config.typePolicies
        });
        _this.init();
        return _this;
      }
      InMemoryCache3.prototype.init = function() {
        var rootStore = this.data = new exports.EntityStore.Root({
          policies: this.policies,
          resultCaching: this.config.resultCaching
        });
        this.optimisticData = rootStore.stump;
        this.resetResultCache();
      };
      InMemoryCache3.prototype.resetResultCache = function(resetResultIdentities) {
        var _this = this;
        var previousReader = this.storeReader;
        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
          cache: this,
          addTypename: this.addTypename,
          resultCacheMaxSize: this.config.resultCacheMaxSize,
          canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon
        }));
        this.maybeBroadcastWatch = optimism.wrap(function(c, options2) {
          return _this.broadcastWatch(c, options2);
        }, {
          max: this.config.resultCacheMaxSize,
          makeCacheKey: function(c) {
            var store = c.optimistic ? _this.optimisticData : _this.data;
            if (supportsResultCaching(store)) {
              var optimistic = c.optimistic, rootId = c.rootId, variables = c.variables;
              return store.makeCacheKey(c.query, c.callback, canonicalStringify({ optimistic, rootId, variables }));
            }
          }
        });
        new Set([
          this.data.group,
          this.optimisticData.group
        ]).forEach(function(group) {
          return group.resetCaching();
        });
      };
      InMemoryCache3.prototype.restore = function(data) {
        this.init();
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache3.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).extract();
      };
      InMemoryCache3.prototype.read = function(options2) {
        var _a = options2.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
        try {
          return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
        } catch (e) {
          if (e instanceof MissingFieldError) {
            return null;
          }
          throw e;
        }
      };
      InMemoryCache3.prototype.write = function(options2) {
        try {
          ++this.txCount;
          return this.storeWriter.writeToStore(this.data, options2);
        } finally {
          if (!--this.txCount && options2.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.modify = function(options2) {
        if (hasOwn.call(options2, "id") && !options2.id) {
          return false;
        }
        var store = options2.optimistic ? this.optimisticData : this.data;
        try {
          ++this.txCount;
          return store.modify(options2.id || "ROOT_QUERY", options2.fields);
        } finally {
          if (!--this.txCount && options2.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.diff = function(options2) {
        return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, rootId: options2.id || "ROOT_QUERY", config: this.config }));
      };
      InMemoryCache3.prototype.watch = function(watch) {
        var _this = this;
        if (!this.watches.size) {
          recallCache(this);
        }
        this.watches.add(watch);
        if (watch.immediate) {
          this.maybeBroadcastWatch(watch);
        }
        return function() {
          if (_this.watches.delete(watch) && !_this.watches.size) {
            forgetCache(_this);
          }
          _this.maybeBroadcastWatch.forget(watch);
        };
      };
      InMemoryCache3.prototype.gc = function(options2) {
        canonicalStringify.reset();
        var ids = this.optimisticData.gc();
        if (options2 && !this.txCount) {
          if (options2.resetResultCache) {
            this.resetResultCache(options2.resetResultIdentities);
          } else if (options2.resetResultIdentities) {
            this.storeReader.resetCanon();
          }
        }
        return ids;
      };
      InMemoryCache3.prototype.retain = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).retain(rootId);
      };
      InMemoryCache3.prototype.release = function(rootId, optimistic) {
        return (optimistic ? this.optimisticData : this.data).release(rootId);
      };
      InMemoryCache3.prototype.identify = function(object) {
        return utilities.isReference(object) ? object.__ref : this.policies.identify(object)[0];
      };
      InMemoryCache3.prototype.evict = function(options2) {
        if (!options2.id) {
          if (hasOwn.call(options2, "id")) {
            return false;
          }
          options2 = tslib.__assign(tslib.__assign({}, options2), { id: "ROOT_QUERY" });
        }
        try {
          ++this.txCount;
          return this.optimisticData.evict(options2);
        } finally {
          if (!--this.txCount && options2.broadcast !== false) {
            this.broadcastWatches();
          }
        }
      };
      InMemoryCache3.prototype.reset = function() {
        this.init();
        this.broadcastWatches();
        canonicalStringify.reset();
        return Promise.resolve();
      };
      InMemoryCache3.prototype.removeOptimistic = function(idToRemove) {
        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
        if (newOptimisticData !== this.optimisticData) {
          this.optimisticData = newOptimisticData;
          this.broadcastWatches();
        }
      };
      InMemoryCache3.prototype.batch = function(options2) {
        var _this = this;
        var update = options2.update, _a = options2.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options2.removeOptimistic, onWatchUpdated = options2.onWatchUpdated;
        var perform = function(layer) {
          var _a2 = _this, data = _a2.data, optimisticData = _a2.optimisticData;
          ++_this.txCount;
          if (layer) {
            _this.data = _this.optimisticData = layer;
          }
          try {
            update(_this);
          } finally {
            --_this.txCount;
            _this.data = data;
            _this.optimisticData = optimisticData;
          }
        };
        var alreadyDirty = new Set();
        if (onWatchUpdated && !this.txCount) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options2), { onWatchUpdated: function(watch) {
            alreadyDirty.add(watch);
            return false;
          } }));
        }
        if (typeof optimistic === "string") {
          this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
        } else if (optimistic === false) {
          perform(this.data);
        } else {
          perform();
        }
        if (typeof removeOptimistic === "string") {
          this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
        }
        if (onWatchUpdated && alreadyDirty.size) {
          this.broadcastWatches(tslib.__assign(tslib.__assign({}, options2), { onWatchUpdated: function(watch, diff) {
            var result = onWatchUpdated.call(this, watch, diff);
            if (result !== false) {
              alreadyDirty.delete(watch);
            }
            return result;
          } }));
          if (alreadyDirty.size) {
            alreadyDirty.forEach(function(watch) {
              return _this.maybeBroadcastWatch.dirty(watch);
            });
          }
        } else {
          this.broadcastWatches(options2);
        }
      };
      InMemoryCache3.prototype.performTransaction = function(update, optimisticId) {
        return this.batch({
          update,
          optimistic: optimisticId || optimisticId !== null
        });
      };
      InMemoryCache3.prototype.transformDocument = function(document2) {
        if (this.addTypename) {
          var result = this.typenameDocumentCache.get(document2);
          if (!result) {
            result = utilities.addTypenameToDocument(document2);
            this.typenameDocumentCache.set(document2, result);
            this.typenameDocumentCache.set(result, result);
          }
          return result;
        }
        return document2;
      };
      InMemoryCache3.prototype.broadcastWatches = function(options2) {
        var _this = this;
        if (!this.txCount) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c, options2);
          });
        }
      };
      InMemoryCache3.prototype.broadcastWatch = function(c, options2) {
        var lastDiff = c.lastDiff;
        var diff = this.diff({
          query: c.query,
          variables: c.variables,
          optimistic: c.optimistic
        });
        if (options2) {
          if (c.optimistic && typeof options2.optimistic === "string") {
            diff.fromOptimisticTransaction = true;
          }
          if (options2.onWatchUpdated && options2.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
            return;
          }
        }
        if (!lastDiff || !equality.equal(lastDiff.result, diff.result)) {
          c.callback(c.lastDiff = diff, lastDiff);
        }
      };
      return InMemoryCache3;
    }(ApolloCache);
    __DEV__ ? tsInvariant.invariant(typeof utilities.DEV === "boolean", utilities.DEV) : tsInvariant.invariant(typeof utilities.DEV === "boolean", 1);
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.ApolloCache = ApolloCache;
    exports.InMemoryCache = InMemoryCache2;
    exports.MissingFieldError = MissingFieldError;
    exports.Policies = Policies;
    exports.cacheSlot = cacheSlot;
    exports.canonicalStringify = canonicalStringify;
    exports.defaultDataIdFromObject = defaultDataIdFromObject;
    exports.fieldNameFromStoreName = fieldNameFromStoreName;
    exports.makeVar = makeVar;
  }
});

// node_modules/@apollo/client/errors/errors.cjs.js
var require_errors_cjs = __commonJS({
  "node_modules/@apollo/client/errors/errors.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = require_tslib();
    var tsInvariant = require_invariant();
    var utilities = require_utilities_cjs();
    __DEV__ ? tsInvariant.invariant(typeof utilities.DEV === "boolean", utilities.DEV) : tsInvariant.invariant(typeof utilities.DEV === "boolean", 22);
    function isApolloError(err) {
      return err.hasOwnProperty("graphQLErrors");
    }
    var generateErrorMessage = function(err) {
      var message = "";
      if (utilities.isNonEmptyArray(err.graphQLErrors) || utilities.isNonEmptyArray(err.clientErrors)) {
        var errors = (err.graphQLErrors || []).concat(err.clientErrors || []);
        errors.forEach(function(error3) {
          var errorMessage = error3 ? error3.message : "Error message not found.";
          message += errorMessage + "\n";
        });
      }
      if (err.networkError) {
        message += err.networkError.message + "\n";
      }
      message = message.replace(/\n$/, "");
      return message;
    };
    var ApolloError = function(_super) {
      tslib.__extends(ApolloError2, _super);
      function ApolloError2(_a) {
        var graphQLErrors = _a.graphQLErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
        var _this = _super.call(this, errorMessage) || this;
        _this.graphQLErrors = graphQLErrors || [];
        _this.clientErrors = clientErrors || [];
        _this.networkError = networkError || null;
        _this.message = errorMessage || generateErrorMessage(_this);
        _this.extraInfo = extraInfo;
        _this.__proto__ = ApolloError2.prototype;
        return _this;
      }
      return ApolloError2;
    }(Error);
    exports.ApolloError = ApolloError;
    exports.isApolloError = isApolloError;
  }
});

// node_modules/graphql-tag/lib/graphql-tag.umd.js
var require_graphql_tag_umd = __commonJS({
  "node_modules/graphql-tag/lib/graphql-tag.umd.js"(exports, module2) {
    init_shims();
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_tslib(), require_graphql2()) : typeof define === "function" && define.amd ? define(["exports", "tslib", "graphql"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["graphql-tag"] = {}, global2.tslib, global2.graphql));
    })(exports, function(exports2, tslib, graphql) {
      "use strict";
      var docCache = new Map();
      var fragmentSourceMap = new Map();
      var printFragmentWarnings = true;
      var experimentalFragmentVariables = false;
      function normalize3(string) {
        return string.replace(/[\s,]+/g, " ").trim();
      }
      function cacheKeyFromLoc(loc) {
        return normalize3(loc.source.body.substring(loc.start, loc.end));
      }
      function processFragments(ast) {
        var seenKeys = new Set();
        var definitions = [];
        ast.definitions.forEach(function(fragmentDefinition) {
          if (fragmentDefinition.kind === "FragmentDefinition") {
            var fragmentName = fragmentDefinition.name.value;
            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
            var sourceKeySet = fragmentSourceMap.get(fragmentName);
            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
              if (printFragmentWarnings) {
                console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
              }
            } else if (!sourceKeySet) {
              fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());
            }
            sourceKeySet.add(sourceKey);
            if (!seenKeys.has(sourceKey)) {
              seenKeys.add(sourceKey);
              definitions.push(fragmentDefinition);
            }
          } else {
            definitions.push(fragmentDefinition);
          }
        });
        return tslib.__assign(tslib.__assign({}, ast), { definitions });
      }
      function stripLoc(doc) {
        var workSet = new Set(doc.definitions);
        workSet.forEach(function(node) {
          if (node.loc)
            delete node.loc;
          Object.keys(node).forEach(function(key) {
            var value = node[key];
            if (value && typeof value === "object") {
              workSet.add(value);
            }
          });
        });
        var loc = doc.loc;
        if (loc) {
          delete loc.startToken;
          delete loc.endToken;
        }
        return doc;
      }
      function parseDocument(source) {
        var cacheKey = normalize3(source);
        if (!docCache.has(cacheKey)) {
          var parsed = graphql.parse(source, {
            experimentalFragmentVariables
          });
          if (!parsed || parsed.kind !== "Document") {
            throw new Error("Not a valid GraphQL document.");
          }
          docCache.set(cacheKey, stripLoc(processFragments(parsed)));
        }
        return docCache.get(cacheKey);
      }
      function gql2(literals) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (typeof literals === "string") {
          literals = [literals];
        }
        var result = literals[0];
        args.forEach(function(arg, i) {
          if (arg && arg.kind === "Document") {
            result += arg.loc.source.body;
          } else {
            result += arg;
          }
          result += literals[i + 1];
        });
        return parseDocument(result);
      }
      function resetCaches() {
        docCache.clear();
        fragmentSourceMap.clear();
      }
      function disableFragmentWarnings() {
        printFragmentWarnings = false;
      }
      function enableExperimentalFragmentVariables() {
        experimentalFragmentVariables = true;
      }
      function disableExperimentalFragmentVariables() {
        experimentalFragmentVariables = false;
      }
      var extras = {
        gql: gql2,
        resetCaches,
        disableFragmentWarnings,
        enableExperimentalFragmentVariables,
        disableExperimentalFragmentVariables
      };
      (function(gql_1) {
        gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
      })(gql2 || (gql2 = {}));
      gql2["default"] = gql2;
      var gql$1 = gql2;
      exports2.default = gql$1;
      exports2.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
      exports2.disableFragmentWarnings = disableFragmentWarnings;
      exports2.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
      exports2.gql = gql2;
      exports2.resetCaches = resetCaches;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/graphql-tag/main.js
var require_main2 = __commonJS({
  "node_modules/graphql-tag/main.js"(exports, module2) {
    init_shims();
    module2.exports = require_graphql_tag_umd().gql;
  }
});

// node_modules/@apollo/client/core/core.cjs.js
var require_core_cjs2 = __commonJS({
  "node_modules/@apollo/client/core/core.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utilities = require_utilities_cjs();
    var tslib = require_tslib();
    var tsInvariant = require_invariant();
    var core = require_core_cjs();
    var http2 = require_http_cjs();
    var equality = require_equality();
    var cache = require_cache_cjs();
    var errors = require_errors_cjs();
    var graphql = require_graphql2();
    var utils = require_utils_cjs();
    var graphqlTag = require_main2();
    var version = "3.4.7";
    exports.NetworkStatus = void 0;
    (function(NetworkStatus) {
      NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
      NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
      NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
      NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
      NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
      NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
      NetworkStatus[NetworkStatus["error"] = 8] = "error";
    })(exports.NetworkStatus || (exports.NetworkStatus = {}));
    function isNetworkRequestInFlight(networkStatus) {
      return networkStatus ? networkStatus < 7 : false;
    }
    var warnedAboutUpdateQuery = false;
    var ObservableQuery = function(_super) {
      tslib.__extends(ObservableQuery2, _super);
      function ObservableQuery2(_a) {
        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options2 = _a.options;
        var _this = _super.call(this, function(observer) {
          try {
            var subObserver = observer._subscription._observer;
            if (subObserver && !subObserver.error) {
              subObserver.error = defaultSubscriptionObserverErrorCallback;
            }
          } catch (_a2) {
          }
          var first = !_this.observers.size;
          _this.observers.add(observer);
          if (_this.lastError) {
            observer.error && observer.error(_this.lastError);
          } else if (_this.lastResult) {
            observer.next && observer.next(_this.lastResult);
          }
          if (first) {
            _this.reobserve().catch(function() {
            });
          }
          return function() {
            if (_this.observers.delete(observer) && !_this.observers.size) {
              _this.tearDownQuery();
            }
          };
        }) || this;
        _this.observers = new Set();
        _this.subscriptions = new Set();
        _this.observer = {
          next: function(result) {
            if (_this.lastError || _this.isDifferentFromLastResult(result)) {
              _this.updateLastResult(result);
              utilities.iterateObserversSafely(_this.observers, "next", result);
            }
          },
          error: function(error3) {
            _this.updateLastResult(tslib.__assign(tslib.__assign({}, _this.lastResult), { error: error3, errors: error3.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false }));
            utilities.iterateObserversSafely(_this.observers, "error", _this.lastError = error3);
          }
        };
        _this.isTornDown = false;
        _this.options = options2;
        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
        var opDef = utilities.getOperationDefinition(options2.query);
        _this.queryName = opDef && opDef.name && opDef.name.value;
        _this.initialFetchPolicy = options2.fetchPolicy || "cache-first";
        _this.queryManager = queryManager;
        _this.queryInfo = queryInfo;
        return _this;
      }
      Object.defineProperty(ObservableQuery2.prototype, "variables", {
        get: function() {
          return this.options.variables;
        },
        enumerable: false,
        configurable: true
      });
      ObservableQuery2.prototype.result = function() {
        var _this = this;
        return new Promise(function(resolve2, reject) {
          var observer = {
            next: function(result) {
              resolve2(result);
              _this.observers.delete(observer);
              if (!_this.observers.size) {
                _this.queryManager.removeQuery(_this.queryId);
              }
              setTimeout(function() {
                subscription.unsubscribe();
              }, 0);
            },
            error: reject
          };
          var subscription = _this.subscribe(observer);
        });
      };
      ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
        if (saveAsLastResult === void 0) {
          saveAsLastResult = true;
        }
        var _a = this, lastResult = _a.lastResult, _b = _a.options.fetchPolicy, fetchPolicy = _b === void 0 ? "cache-first" : _b;
        var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || exports.NetworkStatus.ready;
        var result = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
        if (!this.queryManager.transform(this.options.query).hasForcedResolvers) {
          var diff = this.queryInfo.getDiff();
          result.data = diff.complete || this.options.returnPartialData ? diff.result : void 0;
          if (diff.complete) {
            if (result.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
              result.networkStatus = exports.NetworkStatus.ready;
              result.loading = false;
            }
            delete result.partial;
          } else if (fetchPolicy !== "no-cache") {
            result.partial = true;
          }
          if (__DEV__ && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
            logMissingFieldErrors(diff.missing);
          }
        }
        if (saveAsLastResult) {
          this.updateLastResult(result);
        }
        return result;
      };
      ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult) {
        return !equality.equal(this.lastResultSnapshot, newResult);
      };
      ObservableQuery2.prototype.getLastResult = function() {
        return this.lastResult;
      };
      ObservableQuery2.prototype.getLastError = function() {
        return this.lastError;
      };
      ObservableQuery2.prototype.resetLastResults = function() {
        delete this.lastResult;
        delete this.lastResultSnapshot;
        delete this.lastError;
        this.isTornDown = false;
      };
      ObservableQuery2.prototype.resetQueryStoreErrors = function() {
        this.queryManager.resetErrors(this.queryId);
      };
      ObservableQuery2.prototype.refetch = function(variables) {
        var reobserveOptions = {
          pollInterval: 0
        };
        var fetchPolicy = this.options.fetchPolicy;
        if (fetchPolicy === "no-cache") {
          reobserveOptions.fetchPolicy = "no-cache";
        } else if (fetchPolicy !== "cache-and-network") {
          reobserveOptions.fetchPolicy = "network-only";
        }
        if (variables && !equality.equal(this.options.variables, variables)) {
          reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
        }
        this.queryInfo.resetLastWrite();
        return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
      };
      ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
        var _this = this;
        var combinedOptions = tslib.__assign(tslib.__assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
        var qid = this.queryManager.generateQueryId();
        if (combinedOptions.notifyOnNetworkStatusChange) {
          this.queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
          this.observe();
        }
        return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
          var data = fetchMoreResult.data;
          var updateQuery = fetchMoreOptions.updateQuery;
          if (updateQuery) {
            if (__DEV__ && !warnedAboutUpdateQuery) {
              __DEV__ && tsInvariant.invariant.warn("The updateQuery callback for fetchMore is deprecated, and will be removed\nin the next major version of Apollo Client.\n\nPlease convert updateQuery functions to field policies with appropriate\nread and merge functions, or use/adapt a helper function (such as\nconcatPagination, offsetLimitPagination, or relayStylePagination) from\n@apollo/client/utilities.\n\nThe field policy system handles pagination more effectively than a\nhand-written updateQuery function, and you only need to define the policy\nonce, rather than every time you call fetchMore.");
              warnedAboutUpdateQuery = true;
            }
            _this.updateQuery(function(previous) {
              return updateQuery(previous, {
                fetchMoreResult: data,
                variables: combinedOptions.variables
              });
            });
          } else {
            _this.queryManager.cache.writeQuery({
              query: combinedOptions.query,
              variables: combinedOptions.variables,
              data
            });
          }
          return fetchMoreResult;
        }).finally(function() {
          _this.queryManager.stopQuery(qid);
          _this.reobserve();
        });
      };
      ObservableQuery2.prototype.subscribeToMore = function(options2) {
        var _this = this;
        var subscription = this.queryManager.startGraphQLSubscription({
          query: options2.document,
          variables: options2.variables,
          context: options2.context
        }).subscribe({
          next: function(subscriptionData) {
            var updateQuery = options2.updateQuery;
            if (updateQuery) {
              _this.updateQuery(function(previous, _a) {
                var variables = _a.variables;
                return updateQuery(previous, {
                  subscriptionData,
                  variables
                });
              });
            }
          },
          error: function(err) {
            if (options2.onError) {
              options2.onError(err);
              return;
            }
            __DEV__ && tsInvariant.invariant.error("Unhandled GraphQL subscription error", err);
          }
        });
        this.subscriptions.add(subscription);
        return function() {
          if (_this.subscriptions.delete(subscription)) {
            subscription.unsubscribe();
          }
        };
      };
      ObservableQuery2.prototype.setOptions = function(newOptions) {
        return this.reobserve(newOptions);
      };
      ObservableQuery2.prototype.setVariables = function(variables) {
        if (equality.equal(this.variables, variables)) {
          return this.observers.size ? this.result() : Promise.resolve();
        }
        this.options.variables = variables;
        if (!this.observers.size) {
          return Promise.resolve();
        }
        return this.reobserve({
          fetchPolicy: this.initialFetchPolicy,
          variables
        }, exports.NetworkStatus.setVariables);
      };
      ObservableQuery2.prototype.updateQuery = function(mapFn) {
        var _a;
        var queryManager = this.queryManager;
        var result = queryManager.cache.diff({
          query: this.options.query,
          variables: this.variables,
          previousResult: (_a = this.lastResult) === null || _a === void 0 ? void 0 : _a.data,
          returnPartialData: true,
          optimistic: false
        }).result;
        var newResult = mapFn(result, {
          variables: this.variables
        });
        if (newResult) {
          queryManager.cache.writeQuery({
            query: this.options.query,
            data: newResult,
            variables: this.variables
          });
          queryManager.broadcastQueries();
        }
      };
      ObservableQuery2.prototype.startPolling = function(pollInterval) {
        this.options.pollInterval = pollInterval;
        this.updatePolling();
      };
      ObservableQuery2.prototype.stopPolling = function() {
        this.options.pollInterval = 0;
        this.updatePolling();
      };
      ObservableQuery2.prototype.fetch = function(options2, newNetworkStatus) {
        this.queryManager.setObservableQuery(this);
        return this.queryManager.fetchQueryObservable(this.queryId, options2, newNetworkStatus);
      };
      ObservableQuery2.prototype.updatePolling = function() {
        var _this = this;
        if (this.queryManager.ssrMode) {
          return;
        }
        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
        if (!pollInterval) {
          if (pollingInfo) {
            clearTimeout(pollingInfo.timeout);
            delete this.pollingInfo;
          }
          return;
        }
        if (pollingInfo && pollingInfo.interval === pollInterval) {
          return;
        }
        __DEV__ ? tsInvariant.invariant(pollInterval, "Attempted to start a polling query without a polling interval.") : tsInvariant.invariant(pollInterval, 13);
        var info = pollingInfo || (this.pollingInfo = {});
        info.interval = pollInterval;
        var maybeFetch = function() {
          if (_this.pollingInfo) {
            if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
              _this.reobserve({
                fetchPolicy: "network-only"
              }, exports.NetworkStatus.poll).then(poll, poll);
            } else {
              poll();
            }
          }
        };
        var poll = function() {
          var info2 = _this.pollingInfo;
          if (info2) {
            clearTimeout(info2.timeout);
            info2.timeout = setTimeout(maybeFetch, info2.interval);
          }
        };
        poll();
      };
      ObservableQuery2.prototype.updateLastResult = function(newResult) {
        var previousResult = this.lastResult;
        this.lastResult = newResult;
        this.lastResultSnapshot = this.queryManager.assumeImmutableResults ? newResult : utilities.cloneDeep(newResult);
        if (!utilities.isNonEmptyArray(newResult.errors)) {
          delete this.lastError;
        }
        return previousResult;
      };
      ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
        this.isTornDown = false;
        var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
        var oldVariables = this.options.variables;
        var options2 = useDisposableConcast ? utilities.compact(this.options, newOptions) : Object.assign(this.options, utilities.compact(newOptions));
        if (!useDisposableConcast) {
          this.updatePolling();
          if (newOptions && newOptions.variables && !newOptions.fetchPolicy && !equality.equal(newOptions.variables, oldVariables)) {
            options2.fetchPolicy = this.initialFetchPolicy;
            if (newNetworkStatus === void 0) {
              newNetworkStatus = exports.NetworkStatus.setVariables;
            }
          }
        }
        var concast = this.fetch(options2, newNetworkStatus);
        if (!useDisposableConcast) {
          if (this.concast) {
            this.concast.removeObserver(this.observer, true);
          }
          this.concast = concast;
        }
        concast.addObserver(this.observer);
        return concast.promise;
      };
      ObservableQuery2.prototype.observe = function() {
        this.observer.next(this.getCurrentResult(false));
      };
      ObservableQuery2.prototype.hasObservers = function() {
        return this.observers.size > 0;
      };
      ObservableQuery2.prototype.tearDownQuery = function() {
        if (this.isTornDown)
          return;
        if (this.concast) {
          this.concast.removeObserver(this.observer);
          delete this.concast;
        }
        this.stopPolling();
        this.subscriptions.forEach(function(sub) {
          return sub.unsubscribe();
        });
        this.subscriptions.clear();
        this.queryManager.stopQuery(this.queryId);
        this.observers.clear();
        this.isTornDown = true;
      };
      return ObservableQuery2;
    }(utilities.Observable);
    utilities.fixObservableSubclass(ObservableQuery);
    function defaultSubscriptionObserverErrorCallback(error3) {
      __DEV__ && tsInvariant.invariant.error("Unhandled error", error3.message, error3.stack);
    }
    function logMissingFieldErrors(missing) {
      if (__DEV__ && utilities.isNonEmptyArray(missing)) {
        __DEV__ && tsInvariant.invariant.debug("Missing cache result fields: " + missing.map(function(m) {
          return m.path.join(".");
        }).join(", "), missing);
      }
    }
    function applyNextFetchPolicy(options2) {
      var _a = options2.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, nextFetchPolicy = options2.nextFetchPolicy;
      if (nextFetchPolicy) {
        options2.fetchPolicy = typeof nextFetchPolicy === "function" ? nextFetchPolicy.call(options2, fetchPolicy) : nextFetchPolicy;
      }
    }
    var LocalState = function() {
      function LocalState2(_a) {
        var cache2 = _a.cache, client2 = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
        this.cache = cache2;
        if (client2) {
          this.client = client2;
        }
        if (resolvers) {
          this.addResolvers(resolvers);
        }
        if (fragmentMatcher) {
          this.setFragmentMatcher(fragmentMatcher);
        }
      }
      LocalState2.prototype.addResolvers = function(resolvers) {
        var _this = this;
        this.resolvers = this.resolvers || {};
        if (Array.isArray(resolvers)) {
          resolvers.forEach(function(resolverGroup) {
            _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
          });
        } else {
          this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
        }
      };
      LocalState2.prototype.setResolvers = function(resolvers) {
        this.resolvers = {};
        this.addResolvers(resolvers);
      };
      LocalState2.prototype.getResolvers = function() {
        return this.resolvers || {};
      };
      LocalState2.prototype.runResolvers = function(_a) {
        var document2 = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_c) {
            if (document2) {
              return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                return tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result });
              })];
            }
            return [2, remoteResult];
          });
        });
      };
      LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
        this.fragmentMatcher = fragmentMatcher;
      };
      LocalState2.prototype.getFragmentMatcher = function() {
        return this.fragmentMatcher;
      };
      LocalState2.prototype.clientQuery = function(document2) {
        if (utilities.hasDirectives(["client"], document2)) {
          if (this.resolvers) {
            return document2;
          }
        }
        return null;
      };
      LocalState2.prototype.serverQuery = function(document2) {
        return utilities.removeClientSetsFromDocument(document2);
      };
      LocalState2.prototype.prepareContext = function(context) {
        var cache2 = this.cache;
        return tslib.__assign(tslib.__assign({}, context), { cache: cache2, getCacheKey: function(obj) {
          return cache2.identify(obj);
        } });
      };
      LocalState2.prototype.addExportedVariables = function(document2, variables, context) {
        if (variables === void 0) {
          variables = {};
        }
        if (context === void 0) {
          context = {};
        }
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_a) {
            if (document2) {
              return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                return tslib.__assign(tslib.__assign({}, variables), data.exportedVariables);
              })];
            }
            return [2, tslib.__assign({}, variables)];
          });
        });
      };
      LocalState2.prototype.shouldForceResolvers = function(document2) {
        var forceResolvers = false;
        graphql.visit(document2, {
          Directive: {
            enter: function(node) {
              if (node.name.value === "client" && node.arguments) {
                forceResolvers = node.arguments.some(function(arg) {
                  return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                });
                if (forceResolvers) {
                  return graphql.BREAK;
                }
              }
            }
          }
        });
        return forceResolvers;
      };
      LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
        return this.cache.diff({
          query: utilities.buildQueryFromSelectionSet(document2),
          variables,
          returnPartialData: true,
          optimistic: false
        }).result;
      };
      LocalState2.prototype.resolveDocument = function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        if (context === void 0) {
          context = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return tslib.__awaiter(this, void 0, void 0, function() {
          var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache2, client2, execContext;
          return tslib.__generator(this, function(_b) {
            mainDefinition = utilities.getMainDefinition(document2);
            fragments = utilities.getFragmentDefinitions(document2);
            fragmentMap = utilities.createFragmentMap(fragments);
            definitionOperation = mainDefinition.operation;
            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
            _a = this, cache2 = _a.cache, client2 = _a.client;
            execContext = {
              fragmentMap,
              context: tslib.__assign(tslib.__assign({}, context), { cache: cache2, client: client2 }),
              variables,
              fragmentMatcher,
              defaultOperationType,
              exportedVariables: {},
              onlyRunForcedResolvers
            };
            return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function(result) {
              return {
                result,
                exportedVariables: execContext.exportedVariables
              };
            })];
          });
        });
      };
      LocalState2.prototype.resolveSelectionSet = function(selectionSet, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var fragmentMap, context, variables, resultsToMerge, execute;
          var _this = this;
          return tslib.__generator(this, function(_a) {
            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
            resultsToMerge = [rootValue];
            execute = function(selection) {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                var fragment, typeCondition;
                return tslib.__generator(this, function(_a2) {
                  if (!utilities.shouldInclude(selection, variables)) {
                    return [2];
                  }
                  if (utilities.isField(selection)) {
                    return [2, this.resolveField(selection, rootValue, execContext).then(function(fieldResult) {
                      var _a3;
                      if (typeof fieldResult !== "undefined") {
                        resultsToMerge.push((_a3 = {}, _a3[utilities.resultKeyNameFromField(selection)] = fieldResult, _a3));
                      }
                    })];
                  }
                  if (utilities.isInlineFragment(selection)) {
                    fragment = selection;
                  } else {
                    fragment = fragmentMap[selection.name.value];
                    __DEV__ ? tsInvariant.invariant(fragment, "No fragment named " + selection.name.value) : tsInvariant.invariant(fragment, 12);
                  }
                  if (fragment && fragment.typeCondition) {
                    typeCondition = fragment.typeCondition.name.value;
                    if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                      return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function(fragmentResult) {
                        resultsToMerge.push(fragmentResult);
                      })];
                    }
                  }
                  return [2];
                });
              });
            };
            return [2, Promise.all(selectionSet.selections.map(execute)).then(function() {
              return utilities.mergeDeepArray(resultsToMerge);
            })];
          });
        });
      };
      LocalState2.prototype.resolveField = function(field, rootValue, execContext) {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve2;
          var _this = this;
          return tslib.__generator(this, function(_a) {
            variables = execContext.variables;
            fieldName = field.name.value;
            aliasedFieldName = utilities.resultKeyNameFromField(field);
            aliasUsed = fieldName !== aliasedFieldName;
            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
            resultPromise = Promise.resolve(defaultResult);
            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
              resolverType = rootValue.__typename || execContext.defaultOperationType;
              resolverMap = this.resolvers && this.resolvers[resolverType];
              if (resolverMap) {
                resolve2 = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                if (resolve2) {
                  resultPromise = Promise.resolve(cache.cacheSlot.withValue(this.cache, resolve2, [
                    rootValue,
                    utilities.argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ]));
                }
              }
            }
            return [2, resultPromise.then(function(result) {
              if (result === void 0) {
                result = defaultResult;
              }
              if (field.directives) {
                field.directives.forEach(function(directive) {
                  if (directive.name.value === "export" && directive.arguments) {
                    directive.arguments.forEach(function(arg) {
                      if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                        execContext.exportedVariables[arg.value.value] = result;
                      }
                    });
                  }
                });
              }
              if (!field.selectionSet) {
                return result;
              }
              if (result == null) {
                return result;
              }
              if (Array.isArray(result)) {
                return _this.resolveSubSelectedArray(field, result, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, result, execContext);
              }
            })];
          });
        });
      };
      LocalState2.prototype.resolveSubSelectedArray = function(field, result, execContext) {
        var _this = this;
        return Promise.all(result.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return _this.resolveSubSelectedArray(field, item, execContext);
          }
          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, item, execContext);
          }
        }));
      };
      return LocalState2;
    }();
    var destructiveMethodCounts = new (utilities.canUseWeakMap ? WeakMap : Map)();
    function wrapDestructiveCacheMethod(cache2, methodName) {
      var original = cache2[methodName];
      if (typeof original === "function") {
        cache2[methodName] = function() {
          destructiveMethodCounts.set(cache2, (destructiveMethodCounts.get(cache2) + 1) % 1e15);
          return original.apply(this, arguments);
        };
      }
    }
    function cancelNotifyTimeout(info) {
      if (info["notifyTimeout"]) {
        clearTimeout(info["notifyTimeout"]);
        info["notifyTimeout"] = void 0;
      }
    }
    var QueryInfo = function() {
      function QueryInfo2(queryManager, queryId) {
        if (queryId === void 0) {
          queryId = queryManager.generateQueryId();
        }
        this.queryId = queryId;
        this.listeners = new Set();
        this.document = null;
        this.lastRequestId = 1;
        this.subscriptions = new Set();
        this.stopped = false;
        this.dirty = false;
        this.observableQuery = null;
        var cache2 = this.cache = queryManager.cache;
        if (!destructiveMethodCounts.has(cache2)) {
          destructiveMethodCounts.set(cache2, 0);
          wrapDestructiveCacheMethod(cache2, "evict");
          wrapDestructiveCacheMethod(cache2, "modify");
          wrapDestructiveCacheMethod(cache2, "reset");
        }
      }
      QueryInfo2.prototype.init = function(query) {
        var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
        if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equality.equal(this.variables, query.variables)) {
          networkStatus = exports.NetworkStatus.setVariables;
        }
        if (!equality.equal(query.variables, this.variables)) {
          this.lastDiff = void 0;
        }
        Object.assign(this, {
          document: query.document,
          variables: query.variables,
          networkError: null,
          graphQLErrors: this.graphQLErrors || [],
          networkStatus
        });
        if (query.observableQuery) {
          this.setObservableQuery(query.observableQuery);
        }
        if (query.lastRequestId) {
          this.lastRequestId = query.lastRequestId;
        }
        return this;
      };
      QueryInfo2.prototype.reset = function() {
        cancelNotifyTimeout(this);
        this.lastDiff = void 0;
        this.dirty = false;
      };
      QueryInfo2.prototype.getDiff = function(variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var options2 = this.getDiffOptions(variables);
        if (this.lastDiff && equality.equal(options2, this.lastDiff.options)) {
          return this.lastDiff.diff;
        }
        this.updateWatch(this.variables = variables);
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return { complete: false };
        }
        var diff = this.cache.diff(options2);
        this.updateLastDiff(diff, options2);
        return diff;
      };
      QueryInfo2.prototype.updateLastDiff = function(diff, options2) {
        this.lastDiff = diff ? {
          diff,
          options: options2 || this.getDiffOptions()
        } : void 0;
      };
      QueryInfo2.prototype.getDiffOptions = function(variables) {
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        return {
          query: this.document,
          variables,
          returnPartialData: true,
          optimistic: true,
          canonizeResults: !oq || oq.options.canonizeResults !== false
        };
      };
      QueryInfo2.prototype.setDiff = function(diff) {
        var _this = this;
        var oldDiff = this.lastDiff && this.lastDiff.diff;
        this.updateLastDiff(diff);
        if (!this.dirty && !equality.equal(oldDiff && oldDiff.result, diff && diff.result)) {
          this.dirty = true;
          if (!this.notifyTimeout) {
            this.notifyTimeout = setTimeout(function() {
              return _this.notify();
            }, 0);
          }
        }
      };
      QueryInfo2.prototype.setObservableQuery = function(oq) {
        var _this = this;
        if (oq === this.observableQuery)
          return;
        if (this.oqListener) {
          this.listeners.delete(this.oqListener);
        }
        this.observableQuery = oq;
        if (oq) {
          oq["queryInfo"] = this;
          this.listeners.add(this.oqListener = function() {
            if (_this.getDiff().fromOptimisticTransaction) {
              oq["observe"]();
            } else {
              oq.reobserve();
            }
          });
        } else {
          delete this.oqListener;
        }
      };
      QueryInfo2.prototype.notify = function() {
        var _this = this;
        cancelNotifyTimeout(this);
        if (this.shouldNotify()) {
          this.listeners.forEach(function(listener) {
            return listener(_this);
          });
        }
        this.dirty = false;
      };
      QueryInfo2.prototype.shouldNotify = function() {
        if (!this.dirty || !this.listeners.size) {
          return false;
        }
        if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
          var fetchPolicy = this.observableQuery.options.fetchPolicy;
          if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
            return false;
          }
        }
        return true;
      };
      QueryInfo2.prototype.stop = function() {
        if (!this.stopped) {
          this.stopped = true;
          this.reset();
          this.cancel();
          this.cancel = QueryInfo2.prototype.cancel;
          this.subscriptions.forEach(function(sub) {
            return sub.unsubscribe();
          });
          var oq = this.observableQuery;
          if (oq)
            oq.stopPolling();
        }
      };
      QueryInfo2.prototype.cancel = function() {
      };
      QueryInfo2.prototype.updateWatch = function(variables) {
        var _this = this;
        if (variables === void 0) {
          variables = this.variables;
        }
        var oq = this.observableQuery;
        if (oq && oq.options.fetchPolicy === "no-cache") {
          return;
        }
        var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
          return _this.setDiff(diff);
        } });
        if (!this.lastWatch || !equality.equal(watchOptions, this.lastWatch)) {
          this.cancel();
          this.cancel = this.cache.watch(this.lastWatch = watchOptions);
        }
      };
      QueryInfo2.prototype.resetLastWrite = function() {
        this.lastWrite = void 0;
      };
      QueryInfo2.prototype.shouldWrite = function(result, variables) {
        var lastWrite = this.lastWrite;
        return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equality.equal(variables, lastWrite.variables) && equality.equal(result.data, lastWrite.result.data));
      };
      QueryInfo2.prototype.markResult = function(result, options2, cacheWriteBehavior) {
        var _this = this;
        this.graphQLErrors = utilities.isNonEmptyArray(result.errors) ? result.errors : [];
        this.reset();
        if (options2.fetchPolicy === "no-cache") {
          this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options2.variables));
        } else if (cacheWriteBehavior !== 0) {
          if (shouldWriteResult(result, options2.errorPolicy)) {
            this.cache.performTransaction(function(cache2) {
              if (_this.shouldWrite(result, options2.variables)) {
                cache2.writeQuery({
                  query: _this.document,
                  data: result.data,
                  variables: options2.variables,
                  overwrite: cacheWriteBehavior === 1
                });
                _this.lastWrite = {
                  result,
                  variables: options2.variables,
                  dmCount: destructiveMethodCounts.get(_this.cache)
                };
              } else {
                if (_this.lastDiff && _this.lastDiff.diff.complete) {
                  result.data = _this.lastDiff.diff.result;
                  return;
                }
              }
              var diffOptions = _this.getDiffOptions(options2.variables);
              var diff = cache2.diff(diffOptions);
              if (!_this.stopped) {
                _this.updateWatch(options2.variables);
              }
              _this.updateLastDiff(diff, diffOptions);
              if (diff.complete) {
                result.data = diff.result;
              }
            });
          } else {
            this.lastWrite = void 0;
          }
        }
      };
      QueryInfo2.prototype.markReady = function() {
        this.networkError = null;
        return this.networkStatus = exports.NetworkStatus.ready;
      };
      QueryInfo2.prototype.markError = function(error3) {
        this.networkStatus = exports.NetworkStatus.error;
        this.lastWrite = void 0;
        this.reset();
        if (error3.graphQLErrors) {
          this.graphQLErrors = error3.graphQLErrors;
        }
        if (error3.networkError) {
          this.networkError = error3.networkError;
        }
        return error3;
      };
      return QueryInfo2;
    }();
    function shouldWriteResult(result, errorPolicy) {
      if (errorPolicy === void 0) {
        errorPolicy = "none";
      }
      var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
      var writeWithErrors = !utilities.graphQLResultHasError(result);
      if (!writeWithErrors && ignoreErrors && result.data) {
        writeWithErrors = true;
      }
      return writeWithErrors;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var QueryManager = function() {
      function QueryManager2(_a) {
        var cache2 = _a.cache, link = _a.link, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;
        this.clientAwareness = {};
        this.queries = new Map();
        this.fetchCancelFns = new Map();
        this.transformCache = new (utilities.canUseWeakMap ? WeakMap : Map)();
        this.queryIdCounter = 1;
        this.requestIdCounter = 1;
        this.mutationIdCounter = 1;
        this.inFlightLinkObservables = new Map();
        this.cache = cache2;
        this.link = link;
        this.queryDeduplication = queryDeduplication;
        this.clientAwareness = clientAwareness;
        this.localState = localState || new LocalState({ cache: cache2 });
        this.ssrMode = ssrMode;
        this.assumeImmutableResults = !!assumeImmutableResults;
        if (this.onBroadcast = onBroadcast) {
          this.mutationStore = Object.create(null);
        }
      }
      QueryManager2.prototype.stop = function() {
        var _this = this;
        this.queries.forEach(function(_info, queryId) {
          _this.stopQueryNoBroadcast(queryId);
        });
        this.cancelPendingFetches(__DEV__ ? new tsInvariant.InvariantError("QueryManager stopped while query was in flight") : new tsInvariant.InvariantError(14));
      };
      QueryManager2.prototype.cancelPendingFetches = function(error3) {
        this.fetchCancelFns.forEach(function(cancel) {
          return cancel(error3);
        });
        this.fetchCancelFns.clear();
      };
      QueryManager2.prototype.mutate = function(_a) {
        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _b = _a.refetchQueries, refetchQueries = _b === void 0 ? [] : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _d = _a.errorPolicy, errorPolicy = _d === void 0 ? "none" : _d, _e = _a.fetchPolicy, fetchPolicy = _e === void 0 ? "network-only" : _e, keepRootFields = _a.keepRootFields, context = _a.context;
        return tslib.__awaiter(this, void 0, void 0, function() {
          var mutationId, mutationStoreValue, self2;
          return tslib.__generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                __DEV__ ? tsInvariant.invariant(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : tsInvariant.invariant(mutation, 15);
                __DEV__ ? tsInvariant.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : tsInvariant.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 16);
                mutationId = this.generateMutationId();
                mutation = this.transform(mutation).document;
                variables = this.getVariables(mutation, variables);
                if (!this.transform(mutation).hasClientExports)
                  return [3, 2];
                return [4, this.localState.addExportedVariables(mutation, variables, context)];
              case 1:
                variables = _f.sent();
                _f.label = 2;
              case 2:
                mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                  mutation,
                  variables,
                  loading: true,
                  error: null
                });
                if (optimisticResponse) {
                  this.markMutationOptimistic(optimisticResponse, {
                    mutationId,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context,
                    updateQueries,
                    update: updateWithProxyFn,
                    keepRootFields
                  });
                }
                this.broadcastQueries();
                self2 = this;
                return [2, new Promise(function(resolve2, reject) {
                  return utilities.asyncMap(self2.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), { optimisticResponse }), variables, false), function(result) {
                    if (utilities.graphQLResultHasError(result) && errorPolicy === "none") {
                      throw new errors.ApolloError({
                        graphQLErrors: result.errors
                      });
                    }
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = null;
                    }
                    var storeResult = tslib.__assign({}, result);
                    if (typeof refetchQueries === "function") {
                      refetchQueries = refetchQueries(storeResult);
                    }
                    if (errorPolicy === "ignore" && utilities.graphQLResultHasError(storeResult)) {
                      delete storeResult.errors;
                    }
                    return self2.markMutationResult({
                      mutationId,
                      result: storeResult,
                      document: mutation,
                      variables,
                      fetchPolicy,
                      errorPolicy,
                      context,
                      update: updateWithProxyFn,
                      updateQueries,
                      awaitRefetchQueries,
                      refetchQueries,
                      removeOptimistic: optimisticResponse ? mutationId : void 0,
                      onQueryUpdated,
                      keepRootFields
                    });
                  }).subscribe({
                    next: function(storeResult) {
                      self2.broadcastQueries();
                      resolve2(storeResult);
                    },
                    error: function(err) {
                      if (mutationStoreValue) {
                        mutationStoreValue.loading = false;
                        mutationStoreValue.error = err;
                      }
                      if (optimisticResponse) {
                        self2.cache.removeOptimistic(mutationId);
                      }
                      self2.broadcastQueries();
                      reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({
                        networkError: err
                      }));
                    }
                  });
                })];
            }
          });
        });
      };
      QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
        var _this = this;
        if (cache2 === void 0) {
          cache2 = this.cache;
        }
        var result = mutation.result;
        var cacheWrites = [];
        var skipCache = mutation.fetchPolicy === "no-cache";
        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
          cacheWrites.push({
            result: result.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
          var updateQueries_1 = mutation.updateQueries;
          if (updateQueries_1) {
            this.queries.forEach(function(_a, queryId) {
              var observableQuery = _a.observableQuery;
              var queryName = observableQuery && observableQuery.queryName;
              if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {
                return;
              }
              var updater = updateQueries_1[queryName];
              var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
              var _c = cache2.diff({
                query: document2,
                variables,
                returnPartialData: true,
                optimistic: false
              }), currentQueryResult = _c.result, complete = _c.complete;
              if (complete && currentQueryResult) {
                var nextQueryResult = updater(currentQueryResult, {
                  mutationResult: result,
                  queryName: document2 && utilities.getOperationName(document2) || void 0,
                  queryVariables: variables
                });
                if (nextQueryResult) {
                  cacheWrites.push({
                    result: nextQueryResult,
                    dataId: "ROOT_QUERY",
                    query: document2,
                    variables
                  });
                }
              }
            });
          }
        }
        if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
          var results_1 = [];
          this.refetchQueries({
            updateCache: function(cache3) {
              if (!skipCache) {
                cacheWrites.forEach(function(write) {
                  return cache3.write(write);
                });
              }
              var update = mutation.update;
              if (update) {
                if (!skipCache) {
                  var diff = cache3.diff({
                    id: "ROOT_MUTATION",
                    query: _this.transform(mutation.document).asQuery,
                    variables: mutation.variables,
                    optimistic: false,
                    returnPartialData: true
                  });
                  if (diff.complete) {
                    result = tslib.__assign(tslib.__assign({}, result), { data: diff.result });
                  }
                }
                update(cache3, result, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
              if (!skipCache && !mutation.keepRootFields) {
                cache3.modify({
                  id: "ROOT_MUTATION",
                  fields: function(value, _a) {
                    var fieldName = _a.fieldName, DELETE = _a.DELETE;
                    return fieldName === "__typename" ? value : DELETE;
                  }
                });
              }
            },
            include: mutation.refetchQueries,
            optimistic: false,
            removeOptimistic: mutation.removeOptimistic,
            onQueryUpdated: mutation.onQueryUpdated || null
          }).forEach(function(result2) {
            return results_1.push(result2);
          });
          if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
            return Promise.all(results_1).then(function() {
              return result;
            });
          }
        }
        return Promise.resolve(result);
      };
      QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
        var _this = this;
        var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
        return this.cache.recordOptimisticTransaction(function(cache2) {
          try {
            _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data } }), cache2);
          } catch (error3) {
            __DEV__ && tsInvariant.invariant.error(error3);
          }
        }, mutation.mutationId);
      };
      QueryManager2.prototype.fetchQuery = function(queryId, options2, networkStatus) {
        return this.fetchQueryObservable(queryId, options2, networkStatus).promise;
      };
      QueryManager2.prototype.getQueryStore = function() {
        var store = Object.create(null);
        this.queries.forEach(function(info, queryId) {
          store[queryId] = {
            variables: info.variables,
            networkStatus: info.networkStatus,
            networkError: info.networkError,
            graphQLErrors: info.graphQLErrors
          };
        });
        return store;
      };
      QueryManager2.prototype.resetErrors = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo) {
          queryInfo.networkError = void 0;
          queryInfo.graphQLErrors = [];
        }
      };
      QueryManager2.prototype.transform = function(document2) {
        var transformCache = this.transformCache;
        if (!transformCache.has(document2)) {
          var transformed = this.cache.transformDocument(document2);
          var forLink = utilities.removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));
          var clientQuery = this.localState.clientQuery(transformed);
          var serverQuery = forLink && this.localState.serverQuery(forLink);
          var cacheEntry_1 = {
            document: transformed,
            hasClientExports: utilities.hasClientExports(transformed),
            hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
            clientQuery,
            serverQuery,
            defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(transformed)),
            asQuery: tslib.__assign(tslib.__assign({}, transformed), { definitions: transformed.definitions.map(function(def) {
              if (def.kind === "OperationDefinition" && def.operation !== "query") {
                return tslib.__assign(tslib.__assign({}, def), { operation: "query" });
              }
              return def;
            }) })
          };
          var add = function(doc) {
            if (doc && !transformCache.has(doc)) {
              transformCache.set(doc, cacheEntry_1);
            }
          };
          add(document2);
          add(transformed);
          add(clientQuery);
          add(serverQuery);
        }
        return transformCache.get(document2);
      };
      QueryManager2.prototype.getVariables = function(document2, variables) {
        return tslib.__assign(tslib.__assign({}, this.transform(document2).defaultVars), variables);
      };
      QueryManager2.prototype.watchQuery = function(options2) {
        options2 = tslib.__assign(tslib.__assign({}, options2), { variables: this.getVariables(options2.query, options2.variables) });
        if (typeof options2.notifyOnNetworkStatusChange === "undefined") {
          options2.notifyOnNetworkStatusChange = false;
        }
        var queryInfo = new QueryInfo(this);
        var observable = new ObservableQuery({
          queryManager: this,
          queryInfo,
          options: options2
        });
        this.queries.set(observable.queryId, queryInfo);
        queryInfo.init({
          document: options2.query,
          observableQuery: observable,
          variables: options2.variables
        });
        return observable;
      };
      QueryManager2.prototype.query = function(options2, queryId) {
        var _this = this;
        if (queryId === void 0) {
          queryId = this.generateQueryId();
        }
        __DEV__ ? tsInvariant.invariant(options2.query, "query option is required. You must specify your GraphQL document in the query option.") : tsInvariant.invariant(options2.query, 17);
        __DEV__ ? tsInvariant.invariant(options2.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : tsInvariant.invariant(options2.query.kind === "Document", 18);
        __DEV__ ? tsInvariant.invariant(!options2.returnPartialData, "returnPartialData option only supported on watchQuery.") : tsInvariant.invariant(!options2.returnPartialData, 19);
        __DEV__ ? tsInvariant.invariant(!options2.pollInterval, "pollInterval option only supported on watchQuery.") : tsInvariant.invariant(!options2.pollInterval, 20);
        return this.fetchQuery(queryId, options2).finally(function() {
          return _this.stopQuery(queryId);
        });
      };
      QueryManager2.prototype.generateQueryId = function() {
        return String(this.queryIdCounter++);
      };
      QueryManager2.prototype.generateRequestId = function() {
        return this.requestIdCounter++;
      };
      QueryManager2.prototype.generateMutationId = function() {
        return String(this.mutationIdCounter++);
      };
      QueryManager2.prototype.stopQueryInStore = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
        var queryInfo = this.queries.get(queryId);
        if (queryInfo)
          queryInfo.stop();
      };
      QueryManager2.prototype.clearStore = function() {
        this.cancelPendingFetches(__DEV__ ? new tsInvariant.InvariantError("Store reset while query was in flight (not completed in link chain)") : new tsInvariant.InvariantError(21));
        this.queries.forEach(function(queryInfo) {
          if (queryInfo.observableQuery) {
            queryInfo.networkStatus = exports.NetworkStatus.loading;
          } else {
            queryInfo.stop();
          }
        });
        if (this.mutationStore) {
          this.mutationStore = Object.create(null);
        }
        return this.cache.reset();
      };
      QueryManager2.prototype.resetStore = function() {
        var _this = this;
        return this.clearStore().then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      QueryManager2.prototype.getObservableQueries = function(include) {
        var _this = this;
        if (include === void 0) {
          include = "active";
        }
        var queries = new Map();
        var queryNamesAndDocs = new Map();
        var legacyQueryOptions = new Set();
        if (Array.isArray(include)) {
          include.forEach(function(desc) {
            if (typeof desc === "string") {
              queryNamesAndDocs.set(desc, false);
            } else if (utilities.isDocumentNode(desc)) {
              queryNamesAndDocs.set(_this.transform(desc).document, false);
            } else if (utilities.isNonNullObject(desc) && desc.query) {
              legacyQueryOptions.add(desc);
            }
          });
        }
        this.queries.forEach(function(_a, queryId) {
          var oq = _a.observableQuery, document2 = _a.document;
          if (oq) {
            if (include === "all") {
              queries.set(queryId, oq);
              return;
            }
            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
            if (fetchPolicy === "standby" || !oq.hasObservers()) {
              return;
            }
            if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
              queries.set(queryId, oq);
              if (queryName)
                queryNamesAndDocs.set(queryName, true);
              if (document2)
                queryNamesAndDocs.set(document2, true);
            }
          }
        });
        if (legacyQueryOptions.size) {
          legacyQueryOptions.forEach(function(options2) {
            var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
            var queryInfo = _this.getQuery(queryId).init({
              document: options2.query,
              variables: options2.variables
            });
            var oq = new ObservableQuery({
              queryManager: _this,
              queryInfo,
              options: tslib.__assign(tslib.__assign({}, options2), { fetchPolicy: "network-only" })
            });
            tsInvariant.invariant(oq.queryId === queryId);
            queryInfo.setObservableQuery(oq);
            queries.set(queryId, oq);
          });
        }
        if (__DEV__ && queryNamesAndDocs.size) {
          queryNamesAndDocs.forEach(function(included, nameOrDoc) {
            if (!included) {
              __DEV__ && tsInvariant.invariant.warn("Unknown query " + (typeof nameOrDoc === "string" ? "named " : "") + JSON.stringify(nameOrDoc, null, 2) + " requested in refetchQueries options.include array");
            }
          });
        }
        return queries;
      };
      QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
        var _this = this;
        if (includeStandby === void 0) {
          includeStandby = false;
        }
        var observableQueryPromises = [];
        this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
          var fetchPolicy = observableQuery.options.fetchPolicy;
          observableQuery.resetLastResults();
          if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
            observableQueryPromises.push(observableQuery.refetch());
          }
          _this.getQuery(queryId).setDiff(null);
        });
        this.broadcastQueries();
        return Promise.all(observableQueryPromises);
      };
      QueryManager2.prototype.setObservableQuery = function(observableQuery) {
        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
      };
      QueryManager2.prototype.startGraphQLSubscription = function(_a) {
        var _this = this;
        var query = _a.query, fetchPolicy = _a.fetchPolicy, errorPolicy = _a.errorPolicy, variables = _a.variables, _b = _a.context, context = _b === void 0 ? {} : _b;
        query = this.transform(query).document;
        variables = this.getVariables(query, variables);
        var makeObservable = function(variables2) {
          return _this.getObservableFromLink(query, context, variables2).map(function(result) {
            if (fetchPolicy !== "no-cache") {
              if (shouldWriteResult(result, errorPolicy)) {
                _this.cache.write({
                  query,
                  result: result.data,
                  dataId: "ROOT_SUBSCRIPTION",
                  variables: variables2
                });
              }
              _this.broadcastQueries();
            }
            if (utilities.graphQLResultHasError(result)) {
              throw new errors.ApolloError({
                graphQLErrors: result.errors
              });
            }
            return result;
          });
        };
        if (this.transform(query).hasClientExports) {
          var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
          return new utilities.Observable(function(observer) {
            var sub = null;
            observablePromise_1.then(function(observable) {
              return sub = observable.subscribe(observer);
            }, observer.error);
            return function() {
              return sub && sub.unsubscribe();
            };
          });
        }
        return makeObservable(variables);
      };
      QueryManager2.prototype.stopQuery = function(queryId) {
        this.stopQueryNoBroadcast(queryId);
        this.broadcastQueries();
      };
      QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
        this.stopQueryInStoreNoBroadcast(queryId);
        this.removeQuery(queryId);
      };
      QueryManager2.prototype.removeQuery = function(queryId) {
        this.fetchCancelFns.delete(queryId);
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      };
      QueryManager2.prototype.broadcastQueries = function() {
        if (this.onBroadcast)
          this.onBroadcast();
        this.queries.forEach(function(info) {
          return info.notify();
        });
      };
      QueryManager2.prototype.getLocalState = function() {
        return this.localState;
      };
      QueryManager2.prototype.getObservableFromLink = function(query, context, variables, deduplication) {
        var _this = this;
        var _a;
        if (deduplication === void 0) {
          deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;
        }
        var observable;
        var serverQuery = this.transform(query).serverQuery;
        if (serverQuery) {
          var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
          var operation = {
            query: serverQuery,
            variables,
            operationName: utilities.getOperationName(serverQuery) || void 0,
            context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), { forceFetch: !deduplication }))
          };
          context = operation.context;
          if (deduplication) {
            var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
            inFlightLinkObservables_1.set(serverQuery, byVariables_1);
            var varJson_1 = cache.canonicalStringify(variables);
            observable = byVariables_1.get(varJson_1);
            if (!observable) {
              var concast = new utilities.Concast([
                core.execute(link, operation)
              ]);
              byVariables_1.set(varJson_1, observable = concast);
              concast.cleanup(function() {
                if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
                  inFlightLinkObservables_1.delete(serverQuery);
                }
              });
            }
          } else {
            observable = new utilities.Concast([
              core.execute(link, operation)
            ]);
          }
        } else {
          observable = new utilities.Concast([
            utilities.Observable.of({ data: {} })
          ]);
          context = this.prepareContext(context);
        }
        var clientQuery = this.transform(query).clientQuery;
        if (clientQuery) {
          observable = utilities.asyncMap(observable, function(result) {
            return _this.localState.runResolvers({
              document: clientQuery,
              remoteResult: result,
              context,
              variables
            });
          });
        }
        return observable;
      };
      QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options2) {
        var requestId = queryInfo.lastRequestId = this.generateRequestId();
        return utilities.asyncMap(this.getObservableFromLink(queryInfo.document, options2.context, options2.variables), function(result) {
          var hasErrors = utilities.isNonEmptyArray(result.errors);
          if (requestId >= queryInfo.lastRequestId) {
            if (hasErrors && options2.errorPolicy === "none") {
              throw queryInfo.markError(new errors.ApolloError({
                graphQLErrors: result.errors
              }));
            }
            queryInfo.markResult(result, options2, cacheWriteBehavior);
            queryInfo.markReady();
          }
          var aqr = {
            data: result.data,
            loading: false,
            networkStatus: queryInfo.networkStatus || exports.NetworkStatus.ready
          };
          if (hasErrors && options2.errorPolicy !== "ignore") {
            aqr.errors = result.errors;
          }
          return aqr;
        }, function(networkError) {
          var error3 = errors.isApolloError(networkError) ? networkError : new errors.ApolloError({ networkError });
          if (requestId >= queryInfo.lastRequestId) {
            queryInfo.markError(error3);
          }
          throw error3;
        });
      };
      QueryManager2.prototype.fetchQueryObservable = function(queryId, options2, networkStatus) {
        var _this = this;
        if (networkStatus === void 0) {
          networkStatus = exports.NetworkStatus.loading;
        }
        var query = this.transform(options2.query).document;
        var variables = this.getVariables(query, options2.variables);
        var queryInfo = this.getQuery(queryId);
        var _a = options2.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options2.errorPolicy, errorPolicy = _b === void 0 ? "none" : _b, _c = options2.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options2.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options2.context, context = _e === void 0 ? {} : _e;
        var normalized = Object.assign({}, options2, {
          query,
          variables,
          fetchPolicy,
          errorPolicy,
          returnPartialData,
          notifyOnNetworkStatusChange,
          context
        });
        var fromVariables = function(variables2) {
          normalized.variables = variables2;
          return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        };
        this.fetchCancelFns.set(queryId, function(reason) {
          Promise.resolve().then(function() {
            return concast.cancel(reason);
          });
        });
        var concast = new utilities.Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
        concast.cleanup(function() {
          _this.fetchCancelFns.delete(queryId);
          applyNextFetchPolicy(options2);
        });
        return concast;
      };
      QueryManager2.prototype.refetchQueries = function(_a) {
        var _this = this;
        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
        var includedQueriesById = new Map();
        if (include) {
          this.getObservableQueries(include).forEach(function(oq, queryId) {
            includedQueriesById.set(queryId, {
              oq,
              lastDiff: _this.getQuery(queryId).getDiff()
            });
          });
        }
        var results = new Map();
        if (updateCache) {
          this.cache.batch({
            update: updateCache,
            optimistic: optimistic && removeOptimistic || false,
            removeOptimistic,
            onWatchUpdated: function(watch, diff, lastDiff) {
              var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
              if (oq) {
                if (onQueryUpdated) {
                  includedQueriesById.delete(oq.queryId);
                  var result = onQueryUpdated(oq, diff, lastDiff);
                  if (result === true) {
                    result = oq.refetch();
                  }
                  if (result !== false) {
                    results.set(oq, result);
                  }
                  return false;
                }
                if (onQueryUpdated !== null) {
                  includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
                }
              }
            }
          });
        }
        if (includedQueriesById.size) {
          includedQueriesById.forEach(function(_a2, queryId) {
            var oq = _a2.oq, lastDiff = _a2.lastDiff, diff = _a2.diff;
            var result;
            if (onQueryUpdated) {
              if (!diff) {
                var info = oq["queryInfo"];
                info.reset();
                diff = info.getDiff();
              }
              result = onQueryUpdated(oq, diff, lastDiff);
            }
            if (!onQueryUpdated || result === true) {
              result = oq.refetch();
            }
            if (result !== false) {
              results.set(oq, result);
            }
            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
              _this.stopQueryNoBroadcast(queryId);
            }
          });
        }
        if (removeOptimistic) {
          this.cache.removeOptimistic(removeOptimistic);
        }
        return results;
      };
      QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a, networkStatus) {
        var _this = this;
        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
        var oldNetworkStatus = queryInfo.networkStatus;
        queryInfo.init({
          document: query,
          variables,
          networkStatus
        });
        var readCache = function() {
          return queryInfo.getDiff(variables);
        };
        var resultsFromCache = function(diff2, networkStatus2) {
          if (networkStatus2 === void 0) {
            networkStatus2 = queryInfo.networkStatus || exports.NetworkStatus.loading;
          }
          var data = diff2.result;
          if (__DEV__ && !returnPartialData && !equality.equal(data, {})) {
            logMissingFieldErrors(diff2.missing);
          }
          var fromData = function(data2) {
            return utilities.Observable.of(tslib.__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
          };
          if (data && _this.transform(query).hasForcedResolvers) {
            return _this.localState.runResolvers({
              document: query,
              remoteResult: { data },
              context,
              variables,
              onlyRunForcedResolvers: true
            }).then(function(resolved) {
              return fromData(resolved.data || void 0);
            });
          }
          return fromData(data);
        };
        var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
        var resultsFromLink = function() {
          return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
            variables,
            context,
            fetchPolicy,
            errorPolicy
          });
        };
        var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
        switch (fetchPolicy) {
          default:
          case "cache-first": {
            var diff = readCache();
            if (diff.complete) {
              return [
                resultsFromCache(diff, queryInfo.markReady())
              ];
            }
            if (returnPartialData || shouldNotify) {
              return [
                resultsFromCache(diff),
                resultsFromLink()
              ];
            }
            return [
              resultsFromLink()
            ];
          }
          case "cache-and-network": {
            var diff = readCache();
            if (diff.complete || returnPartialData || shouldNotify) {
              return [
                resultsFromCache(diff),
                resultsFromLink()
              ];
            }
            return [
              resultsFromLink()
            ];
          }
          case "cache-only":
            return [
              resultsFromCache(readCache(), queryInfo.markReady())
            ];
          case "network-only":
            if (shouldNotify) {
              return [
                resultsFromCache(readCache()),
                resultsFromLink()
              ];
            }
            return [resultsFromLink()];
          case "no-cache":
            if (shouldNotify) {
              return [
                resultsFromCache(queryInfo.getDiff()),
                resultsFromLink()
              ];
            }
            return [resultsFromLink()];
          case "standby":
            return [];
        }
      };
      QueryManager2.prototype.getQuery = function(queryId) {
        if (queryId && !this.queries.has(queryId)) {
          this.queries.set(queryId, new QueryInfo(this, queryId));
        }
        return this.queries.get(queryId);
      };
      QueryManager2.prototype.prepareContext = function(context) {
        if (context === void 0) {
          context = {};
        }
        var newContext = this.localState.prepareContext(context);
        return tslib.__assign(tslib.__assign({}, newContext), { clientAwareness: this.clientAwareness });
      };
      return QueryManager2;
    }();
    var hasSuggestedDevtools = false;
    function mergeOptions(defaults, options2) {
      return utilities.compact(defaults, options2, options2.variables && {
        variables: tslib.__assign(tslib.__assign({}, defaults.variables), options2.variables)
      });
    }
    var ApolloClient = function() {
      function ApolloClient2(options2) {
        var _this = this;
        this.defaultOptions = {};
        this.resetStoreCallbacks = [];
        this.clearStoreCallbacks = [];
        var uri = options2.uri, credentials = options2.credentials, headers = options2.headers, cache2 = options2.cache, _a = options2.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options2.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options2.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options2.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options2.defaultOptions, _e = options2.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options2.resolvers, typeDefs = options2.typeDefs, fragmentMatcher = options2.fragmentMatcher, clientAwarenessName = options2.name, clientAwarenessVersion = options2.version;
        var link = options2.link;
        if (!link) {
          link = uri ? new http2.HttpLink({ uri, credentials, headers }) : core.ApolloLink.empty();
        }
        if (!cache2) {
          throw __DEV__ ? new tsInvariant.InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new tsInvariant.InvariantError(10);
        }
        this.link = link;
        this.cache = cache2;
        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
        this.queryDeduplication = queryDeduplication;
        this.defaultOptions = defaultOptions || {};
        this.typeDefs = typeDefs;
        if (ssrForceFetchDelay) {
          setTimeout(function() {
            return _this.disableNetworkFetches = false;
          }, ssrForceFetchDelay);
        }
        this.watchQuery = this.watchQuery.bind(this);
        this.query = this.query.bind(this);
        this.mutate = this.mutate.bind(this);
        this.resetStore = this.resetStore.bind(this);
        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
        if (connectToDevTools && typeof window === "object") {
          window.__APOLLO_CLIENT__ = this;
        }
        if (!hasSuggestedDevtools && __DEV__) {
          hasSuggestedDevtools = true;
          if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
            var nav = window.navigator;
            var ua = nav && nav.userAgent;
            var url = void 0;
            if (typeof ua === "string") {
              if (ua.indexOf("Chrome/") > -1) {
                url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
              } else if (ua.indexOf("Firefox/") > -1) {
                url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
              }
            }
            if (url) {
              __DEV__ && tsInvariant.invariant.log("Download the Apollo DevTools for a better development experience: " + url);
            }
          }
        }
        this.version = version;
        this.localState = new LocalState({
          cache: cache2,
          client: this,
          resolvers,
          fragmentMatcher
        });
        this.queryManager = new QueryManager({
          cache: this.cache,
          link: this.link,
          queryDeduplication,
          ssrMode,
          clientAwareness: {
            name: clientAwarenessName,
            version: clientAwarenessVersion
          },
          localState: this.localState,
          assumeImmutableResults,
          onBroadcast: connectToDevTools ? function() {
            if (_this.devToolsHookCb) {
              _this.devToolsHookCb({
                action: {},
                state: {
                  queries: _this.queryManager.getQueryStore(),
                  mutations: _this.queryManager.mutationStore || {}
                },
                dataWithOptimisticResults: _this.cache.extract(true)
              });
            }
          } : void 0
        });
      }
      ApolloClient2.prototype.stop = function() {
        this.queryManager.stop();
      };
      ApolloClient2.prototype.watchQuery = function(options2) {
        if (this.defaultOptions.watchQuery) {
          options2 = mergeOptions(this.defaultOptions.watchQuery, options2);
        }
        if (this.disableNetworkFetches && (options2.fetchPolicy === "network-only" || options2.fetchPolicy === "cache-and-network")) {
          options2 = tslib.__assign(tslib.__assign({}, options2), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.watchQuery(options2);
      };
      ApolloClient2.prototype.query = function(options2) {
        if (this.defaultOptions.query) {
          options2 = mergeOptions(this.defaultOptions.query, options2);
        }
        __DEV__ ? tsInvariant.invariant(options2.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : tsInvariant.invariant(options2.fetchPolicy !== "cache-and-network", 11);
        if (this.disableNetworkFetches && options2.fetchPolicy === "network-only") {
          options2 = tslib.__assign(tslib.__assign({}, options2), { fetchPolicy: "cache-first" });
        }
        return this.queryManager.query(options2);
      };
      ApolloClient2.prototype.mutate = function(options2) {
        if (this.defaultOptions.mutate) {
          options2 = mergeOptions(this.defaultOptions.mutate, options2);
        }
        return this.queryManager.mutate(options2);
      };
      ApolloClient2.prototype.subscribe = function(options2) {
        return this.queryManager.startGraphQLSubscription(options2);
      };
      ApolloClient2.prototype.readQuery = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readQuery(options2, optimistic);
      };
      ApolloClient2.prototype.readFragment = function(options2, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.cache.readFragment(options2, optimistic);
      };
      ApolloClient2.prototype.writeQuery = function(options2) {
        this.cache.writeQuery(options2);
        this.queryManager.broadcastQueries();
      };
      ApolloClient2.prototype.writeFragment = function(options2) {
        this.cache.writeFragment(options2);
        this.queryManager.broadcastQueries();
      };
      ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
        this.devToolsHookCb = cb;
      };
      ApolloClient2.prototype.__requestRaw = function(payload) {
        return core.execute(this.link, payload);
      };
      ApolloClient2.prototype.resetStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore();
        }).then(function() {
          return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
            return fn();
          }));
        }).then(function() {
          return _this.reFetchObservableQueries();
        });
      };
      ApolloClient2.prototype.clearStore = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.queryManager.clearStore();
        }).then(function() {
          return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
            return fn();
          }));
        });
      };
      ApolloClient2.prototype.onResetStore = function(cb) {
        var _this = this;
        this.resetStoreCallbacks.push(cb);
        return function() {
          _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.onClearStore = function(cb) {
        var _this = this;
        this.clearStoreCallbacks.push(cb);
        return function() {
          _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
            return c !== cb;
          });
        };
      };
      ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
        return this.queryManager.reFetchObservableQueries(includeStandby);
      };
      ApolloClient2.prototype.refetchQueries = function(options2) {
        var map = this.queryManager.refetchQueries(options2);
        var queries = [];
        var results = [];
        map.forEach(function(result2, obsQuery) {
          queries.push(obsQuery);
          results.push(result2);
        });
        var result = Promise.all(results);
        result.queries = queries;
        result.results = results;
        result.catch(function(error3) {
          __DEV__ && tsInvariant.invariant.debug("In client.refetchQueries, Promise.all promise rejected with error " + error3);
        });
        return result;
      };
      ApolloClient2.prototype.getObservableQueries = function(include) {
        if (include === void 0) {
          include = "active";
        }
        return this.queryManager.getObservableQueries(include);
      };
      ApolloClient2.prototype.extract = function(optimistic) {
        return this.cache.extract(optimistic);
      };
      ApolloClient2.prototype.restore = function(serializedState) {
        return this.cache.restore(serializedState);
      };
      ApolloClient2.prototype.addResolvers = function(resolvers) {
        this.localState.addResolvers(resolvers);
      };
      ApolloClient2.prototype.setResolvers = function(resolvers) {
        this.localState.setResolvers(resolvers);
      };
      ApolloClient2.prototype.getResolvers = function() {
        return this.localState.getResolvers();
      };
      ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
        this.localState.setFragmentMatcher(fragmentMatcher);
      };
      ApolloClient2.prototype.setLink = function(newLink) {
        this.link = this.queryManager.link = newLink;
      };
      return ApolloClient2;
    }();
    tsInvariant.setVerbosity(utilities.DEV ? "log" : "silent");
    exports.Observable = utilities.Observable;
    exports.isReference = utilities.isReference;
    exports.makeReference = utilities.makeReference;
    exports.setLogVerbosity = tsInvariant.setVerbosity;
    exports.ApolloCache = cache.ApolloCache;
    exports.Cache = cache.Cache;
    exports.InMemoryCache = cache.InMemoryCache;
    exports.MissingFieldError = cache.MissingFieldError;
    exports.defaultDataIdFromObject = cache.defaultDataIdFromObject;
    exports.makeVar = cache.makeVar;
    exports.ApolloError = errors.ApolloError;
    exports.isApolloError = errors.isApolloError;
    exports.fromError = utils.fromError;
    exports.fromPromise = utils.fromPromise;
    exports.throwServerError = utils.throwServerError;
    exports.toPromise = utils.toPromise;
    exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
    exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
    exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
    exports.gql = graphqlTag.gql;
    exports.resetCaches = graphqlTag.resetCaches;
    exports.ApolloClient = ApolloClient;
    exports.ObservableQuery = ObservableQuery;
    exports.applyNextFetchPolicy = applyNextFetchPolicy;
    exports.mergeOptions = mergeOptions;
    Object.keys(core).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = core[k];
    });
    Object.keys(http2).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        exports[k] = http2[k];
    });
  }
});

// node_modules/svelte/internal/index.js
var require_internal = __commonJS({
  "node_modules/svelte/internal/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noop3() {
    }
    var identity2 = (x) => x;
    function assign2(tar, src2) {
      for (const k in src2)
        tar[k] = src2[k];
      return tar;
    }
    function is_promise(value) {
      return value && typeof value === "object" && typeof value.then === "function";
    }
    function add_location(element2, file, line, column, char) {
      element2.__svelte_meta = {
        loc: { file, line, column, char }
      };
    }
    function run2(fn) {
      return fn();
    }
    function blank_object2() {
      return Object.create(null);
    }
    function run_all2(fns) {
      fns.forEach(run2);
    }
    function is_function2(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal3(a, b) {
      return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
    }
    function not_equal(a, b) {
      return a != a ? b == b : a !== b;
    }
    function is_empty2(obj) {
      return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== "function") {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }
    function subscribe2(store, ...callbacks) {
      if (store == null) {
        return noop3;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value2(store) {
      let value;
      subscribe2(store, (_) => value = _)();
      return value;
    }
    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe2(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign2($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === void 0) {
          return lets;
        }
        if (typeof lets === "object") {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }
    function update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }
    function exclude_internal_props(props) {
      const result = {};
      for (const k in props)
        if (k[0] !== "$")
          result[k] = props[k];
      return result;
    }
    function compute_rest_props(props, keys) {
      const rest = {};
      keys = new Set(keys);
      for (const k in props)
        if (!keys.has(k) && k[0] !== "$")
          rest[k] = props[k];
      return rest;
    }
    function compute_slots(slots) {
      const result = {};
      for (const key in slots) {
        result[key] = true;
      }
      return result;
    }
    function once(fn) {
      let ran = false;
      return function(...args) {
        if (ran)
          return;
        ran = true;
        fn.call(this, ...args);
      };
    }
    function null_to_empty(value) {
      return value == null ? "" : value;
    }
    function set_store_value(store, ret, value = ret) {
      store.set(value);
      return ret;
    }
    var has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    function action_destroyer(action_result) {
      return action_result && is_function2(action_result.destroy) ? action_result.destroy : noop3;
    }
    var is_client = typeof window !== "undefined";
    exports.now = is_client ? () => window.performance.now() : () => Date.now();
    exports.raf = is_client ? (cb) => requestAnimationFrame(cb) : noop3;
    function set_now(fn) {
      exports.now = fn;
    }
    function set_raf(fn) {
      exports.raf = fn;
    }
    var tasks2 = new Set();
    function run_tasks(now) {
      tasks2.forEach((task) => {
        if (!task.c(now)) {
          tasks2.delete(task);
          task.f();
        }
      });
      if (tasks2.size !== 0)
        exports.raf(run_tasks);
    }
    function clear_loops() {
      tasks2.clear();
    }
    function loop(callback) {
      let task;
      if (tasks2.size === 0)
        exports.raf(run_tasks);
      return {
        promise: new Promise((fulfill) => {
          tasks2.add(task = { c: callback, f: fulfill });
        }),
        abort() {
          tasks2.delete(task);
        }
      };
    }
    var is_hydrating = false;
    function start_hydrating() {
      is_hydrating = true;
    }
    function end_hydrating() {
      is_hydrating = false;
    }
    function upper_bound(low, high, key, value) {
      while (low < high) {
        const mid = low + (high - low >> 1);
        if (key(mid) <= value) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    }
    function init_hydrate(target) {
      if (target.hydrate_init)
        return;
      target.hydrate_init = true;
      const children2 = target.childNodes;
      const m = new Int32Array(children2.length + 1);
      const p = new Int32Array(children2.length);
      m[0] = -1;
      let longest = 0;
      for (let i = 0; i < children2.length; i++) {
        const current = children2[i].claim_order;
        const seqLen = upper_bound(1, longest + 1, (idx) => children2[m[idx]].claim_order, current) - 1;
        p[i] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        m[newLen] = i;
        longest = Math.max(newLen, longest);
      }
      const lis = [];
      const toMove = [];
      let last = children2.length - 1;
      for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
        lis.push(children2[cur - 1]);
        for (; last >= cur; last--) {
          toMove.push(children2[last]);
        }
        last--;
      }
      for (; last >= 0; last--) {
        toMove.push(children2[last]);
      }
      lis.reverse();
      toMove.sort((a, b) => a.claim_order - b.claim_order);
      for (let i = 0, j = 0; i < toMove.length; i++) {
        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
          j++;
        }
        const anchor = j < lis.length ? lis[j] : null;
        target.insertBefore(toMove[i], anchor);
      }
    }
    function append(target, node) {
      if (is_hydrating) {
        init_hydrate(target);
        if (target.actual_end_child === void 0 || target.actual_end_child !== null && target.actual_end_child.parentElement !== target) {
          target.actual_end_child = target.firstChild;
        }
        if (node !== target.actual_end_child) {
          target.insertBefore(node, target.actual_end_child);
        } else {
          target.actual_end_child = node.nextSibling;
        }
      } else if (node.parentNode !== target) {
        target.appendChild(node);
      }
    }
    function insert(target, node, anchor) {
      if (is_hydrating && !anchor) {
        append(target, node);
      } else if (node.parentNode !== target || anchor && node.nextSibling !== anchor) {
        target.insertBefore(node, anchor || null);
      }
    }
    function detach(node) {
      node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
          iterations[i].d(detaching);
      }
    }
    function element(name) {
      return document.createElement(name);
    }
    function element_is(name, is) {
      return document.createElement(name, { is });
    }
    function object_without_properties(obj, exclude) {
      const target = {};
      for (const k in obj) {
        if (has_prop(obj, k) && exclude.indexOf(k) === -1) {
          target[k] = obj[k];
        }
      }
      return target;
    }
    function svg_element(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function text(data) {
      return document.createTextNode(data);
    }
    function space() {
      return text(" ");
    }
    function empty2() {
      return text("");
    }
    function listen(node, event, handler, options2) {
      node.addEventListener(event, handler, options2);
      return () => node.removeEventListener(event, handler, options2);
    }
    function prevent_default(fn) {
      return function(event) {
        event.preventDefault();
        return fn.call(this, event);
      };
    }
    function stop_propagation(fn) {
      return function(event) {
        event.stopPropagation();
        return fn.call(this, event);
      };
    }
    function self2(fn) {
      return function(event) {
        if (event.target === this)
          fn.call(this, event);
      };
    }
    function attr(node, attribute, value) {
      if (value == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === "style") {
          node.style.cssText = attributes[key];
        } else if (key === "__value") {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr(node, key, attributes[key]);
        }
      }
    }
    function set_svg_attributes(node, attributes) {
      for (const key in attributes) {
        attr(node, key, attributes[key]);
      }
    }
    function set_custom_element_data(node, prop, value) {
      if (prop in node) {
        node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
      } else {
        attr(node, prop, value);
      }
    }
    function xlink_attr(node, attribute, value) {
      node.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
    }
    function get_binding_group_value(group, __value, checked) {
      const value = new Set();
      for (let i = 0; i < group.length; i += 1) {
        if (group[i].checked)
          value.add(group[i].__value);
      }
      if (!checked) {
        value.delete(__value);
      }
      return Array.from(value);
    }
    function to_number(value) {
      return value === "" ? null : +value;
    }
    function time_ranges_to_array(ranges) {
      const array = [];
      for (let i = 0; i < ranges.length; i += 1) {
        array.push({ start: ranges.start(i), end: ranges.end(i) });
      }
      return array;
    }
    function children(element2) {
      return Array.from(element2.childNodes);
    }
    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
      if (nodes.claim_info === void 0) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
      }
      const resultNode = (() => {
        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
          const node = nodes[i];
          if (predicate(node)) {
            processNode(node);
            nodes.splice(i, 1);
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i;
            }
            return node;
          }
        }
        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
          const node = nodes[i];
          if (predicate(node)) {
            processNode(node);
            nodes.splice(i, 1);
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i;
            } else {
              nodes.claim_info.last_index--;
            }
            return node;
          }
        }
        return createNode();
      })();
      resultNode.claim_order = nodes.claim_info.total_claimed;
      nodes.claim_info.total_claimed += 1;
      return resultNode;
    }
    function claim_element(nodes, name, attributes, svg) {
      return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j = 0; j < node.attributes.length; j++) {
          const attribute = node.attributes[j];
          if (!attributes[attribute.name]) {
            remove.push(attribute.name);
          }
        }
        remove.forEach((v) => node.removeAttribute(v));
      }, () => svg ? svg_element(name) : element(name));
    }
    function claim_text(nodes, data) {
      return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
        node.data = "" + data;
      }, () => text(data), true);
    }
    function claim_space(nodes) {
      return claim_text(nodes, " ");
    }
    function find_comment(nodes, text2, start) {
      for (let i = start; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeType === 8 && node.textContent.trim() === text2) {
          return i;
        }
      }
      return nodes.length;
    }
    function claim_html_tag(nodes) {
      const start_index = find_comment(nodes, "HTML_TAG_START", 0);
      const end_index = find_comment(nodes, "HTML_TAG_END", start_index);
      if (start_index === end_index) {
        return new HtmlTag();
      }
      const html_tag_nodes = nodes.splice(start_index, end_index + 1);
      detach(html_tag_nodes[0]);
      detach(html_tag_nodes[html_tag_nodes.length - 1]);
      return new HtmlTag(html_tag_nodes.slice(1, html_tag_nodes.length - 1));
    }
    function set_data(text2, data) {
      data = "" + data;
      if (text2.wholeText !== data)
        text2.data = data;
    }
    function set_input_value(input, value) {
      input.value = value == null ? "" : value;
    }
    function set_input_type(input, type) {
      try {
        input.type = type;
      } catch (e) {
      }
    }
    function set_style(node, key, value, important) {
      node.style.setProperty(key, value, important ? "important" : "");
    }
    function select_option(select, value) {
      for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
          option.selected = true;
          return;
        }
      }
    }
    function select_options(select, value) {
      for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
      }
    }
    function select_value(select) {
      const selected_option = select.querySelector(":checked") || select.options[0];
      return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
      return [].map.call(select.querySelectorAll(":checked"), (option) => option.__value);
    }
    var crossorigin;
    function is_crossorigin() {
      if (crossorigin === void 0) {
        crossorigin = false;
        try {
          if (typeof window !== "undefined" && window.parent) {
            void window.parent.document;
          }
        } catch (error3) {
          crossorigin = true;
        }
      }
      return crossorigin;
    }
    function add_resize_listener(node, fn) {
      const computed_style = getComputedStyle(node);
      if (computed_style.position === "static") {
        node.style.position = "relative";
      }
      const iframe = element("iframe");
      iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
      iframe.setAttribute("aria-hidden", "true");
      iframe.tabIndex = -1;
      const crossorigin2 = is_crossorigin();
      let unsubscribe;
      if (crossorigin2) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
        unsubscribe = listen(window, "message", (event) => {
          if (event.source === iframe.contentWindow)
            fn();
        });
      } else {
        iframe.src = "about:blank";
        iframe.onload = () => {
          unsubscribe = listen(iframe.contentWindow, "resize", fn);
        };
      }
      append(node, iframe);
      return () => {
        if (crossorigin2) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }
        detach(iframe);
      };
    }
    function toggle_class(element2, name, toggle) {
      element2.classList[toggle ? "add" : "remove"](name);
    }
    function custom_event2(type, detail) {
      const e = document.createEvent("CustomEvent");
      e.initCustomEvent(type, false, false, detail);
      return e;
    }
    function query_selector_all(selector, parent = document.body) {
      return Array.from(parent.querySelectorAll(selector));
    }
    var HtmlTag = class {
      constructor(claimed_nodes) {
        this.e = this.n = null;
        this.l = claimed_nodes;
      }
      m(html, target, anchor = null) {
        if (!this.e) {
          this.e = element(target.nodeName);
          this.t = target;
          if (this.l) {
            this.n = this.l;
          } else {
            this.h(html);
          }
        }
        this.i(anchor);
      }
      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }
      i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
          insert(this.t, this.n[i], anchor);
        }
      }
      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }
      d() {
        this.n.forEach(detach);
      }
    };
    function attribute_to_object(attributes) {
      const result = {};
      for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
      }
      return result;
    }
    function get_custom_elements_slots(element2) {
      const result = {};
      element2.childNodes.forEach((node) => {
        result[node.slot || "default"] = true;
      });
      return result;
    }
    var active_docs2 = new Set();
    var active = 0;
    function hash2(str) {
      let hash3 = 5381;
      let i = str.length;
      while (i--)
        hash3 = (hash3 << 5) - hash3 ^ str.charCodeAt(i);
      return hash3 >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = "{\n";
      for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
      }
      const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
      const name = `__svelte_${hash2(rule)}_${uid}`;
      const doc = node.ownerDocument;
      active_docs2.add(doc);
      const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element("style")).sheet);
      const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
      if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }
      const animation = node.style.animation || "";
      node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }
    function delete_rule(node, name) {
      const previous = (node.style.animation || "").split(", ");
      const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
      const deleted = previous.length - next.length;
      if (deleted) {
        node.style.animation = next.join(", ");
        active -= deleted;
        if (!active)
          clear_rules();
      }
    }
    function clear_rules() {
      exports.raf(() => {
        if (active)
          return;
        active_docs2.forEach((doc) => {
          const stylesheet = doc.__svelte_stylesheet;
          let i = stylesheet.cssRules.length;
          while (i--)
            stylesheet.deleteRule(i);
          doc.__svelte_rules = {};
        });
        active_docs2.clear();
      });
    }
    function create_animation(node, from, fn, params) {
      if (!from)
        return noop3;
      const to = node.getBoundingClientRect();
      if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop3;
      const {
        delay = 0,
        duration = 300,
        easing = identity2,
        start: start_time = exports.now() + delay,
        end = start_time + duration,
        tick: tick3 = noop3,
        css: css2
      } = fn(node, { from, to }, params);
      let running = true;
      let started = false;
      let name;
      function start() {
        if (css2) {
          name = create_rule(node, 0, 1, duration, delay, easing, css2);
        }
        if (!delay) {
          started = true;
        }
      }
      function stop() {
        if (css2)
          delete_rule(node, name);
        running = false;
      }
      loop((now) => {
        if (!started && now >= start_time) {
          started = true;
        }
        if (started && now >= end) {
          tick3(1, 0);
          stop();
        }
        if (!running) {
          return false;
        }
        if (started) {
          const p = now - start_time;
          const t = 0 + 1 * easing(p / duration);
          tick3(t, 1 - t);
        }
        return true;
      });
      start();
      tick3(0, 1);
      return stop;
    }
    function fix_position(node) {
      const style = getComputedStyle(node);
      if (style.position !== "absolute" && style.position !== "fixed") {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = "absolute";
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
      }
    }
    function add_transform(node, a) {
      const b = node.getBoundingClientRect();
      if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === "none" ? "" : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
      }
    }
    function set_current_component2(component) {
      exports.current_component = component;
    }
    function get_current_component2() {
      if (!exports.current_component)
        throw new Error("Function called outside component initialization");
      return exports.current_component;
    }
    function beforeUpdate2(fn) {
      get_current_component2().$$.before_update.push(fn);
    }
    function onMount2(fn) {
      get_current_component2().$$.on_mount.push(fn);
    }
    function afterUpdate2(fn) {
      get_current_component2().$$.after_update.push(fn);
    }
    function onDestroy2(fn) {
      get_current_component2().$$.on_destroy.push(fn);
    }
    function createEventDispatcher2() {
      const component = get_current_component2();
      return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
          const event = custom_event2(type, detail);
          callbacks.slice().forEach((fn) => {
            fn.call(component, event);
          });
        }
      };
    }
    function setContext2(key, context) {
      get_current_component2().$$.context.set(key, context);
    }
    function getContext2(key) {
      return get_current_component2().$$.context.get(key);
    }
    function hasContext2(key) {
      return get_current_component2().$$.context.has(key);
    }
    function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];
      if (callbacks) {
        callbacks.slice().forEach((fn) => fn.call(this, event));
      }
    }
    var dirty_components = [];
    var intros = { enabled: false };
    var binding_callbacks = [];
    var render_callbacks = [];
    var flush_callbacks = [];
    var resolved_promise2 = Promise.resolve();
    var update_scheduled = false;
    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise2.then(flush);
      }
    }
    function tick2() {
      schedule_update();
      return resolved_promise2;
    }
    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }
    var flushing = false;
    var seen_callbacks2 = new Set();
    function flush() {
      if (flushing)
        return;
      flushing = true;
      do {
        for (let i = 0; i < dirty_components.length; i += 1) {
          const component = dirty_components[i];
          set_current_component2(component);
          update(component.$$);
        }
        set_current_component2(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
          binding_callbacks.pop()();
        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];
          if (!seen_callbacks2.has(callback)) {
            seen_callbacks2.add(callback);
            callback();
          }
        }
        render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }
      update_scheduled = false;
      flushing = false;
      seen_callbacks2.clear();
    }
    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all2($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }
    var promise;
    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }
      return promise;
    }
    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event2(`${direction ? "intro" : "outro"}${kind}`));
    }
    var outroing2 = new Set();
    var outros;
    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros
      };
    }
    function check_outros() {
      if (!outros.r) {
        run_all2(outros.c);
      }
      outros = outros.p;
    }
    function transition_in(block, local) {
      if (block && block.i) {
        outroing2.delete(block);
        block.i(local);
      }
    }
    function transition_out(block, local, detach2, callback) {
      if (block && block.o) {
        if (outroing2.has(block))
          return;
        outroing2.add(block);
        outros.c.push(() => {
          outroing2.delete(block);
          if (callback) {
            if (detach2)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }
    var null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
      let config = fn(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;
      function cleanup() {
        if (animation_name)
          delete_rule(node, animation_name);
      }
      function go() {
        const { delay = 0, duration = 300, easing = identity2, tick: tick3 = noop3, css: css2 } = config || null_transition;
        if (css2)
          animation_name = create_rule(node, 0, 1, duration, delay, easing, css2, uid++);
        tick3(0, 1);
        const start_time = exports.now() + delay;
        const end_time = start_time + duration;
        if (task)
          task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, "start"));
        task = loop((now) => {
          if (running) {
            if (now >= end_time) {
              tick3(1, 0);
              dispatch(node, true, "end");
              cleanup();
              return running = false;
            }
            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick3(t, 1 - t);
            }
          }
          return running;
        });
      }
      let started = false;
      return {
        start() {
          if (started)
            return;
          delete_rule(node);
          if (is_function2(config)) {
            config = config();
            wait().then(go);
          } else {
            go();
          }
        },
        invalidate() {
          started = false;
        },
        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }
      };
    }
    function create_out_transition(node, fn, params) {
      let config = fn(node, params);
      let running = true;
      let animation_name;
      const group = outros;
      group.r += 1;
      function go() {
        const { delay = 0, duration = 300, easing = identity2, tick: tick3 = noop3, css: css2 } = config || null_transition;
        if (css2)
          animation_name = create_rule(node, 1, 0, duration, delay, easing, css2);
        const start_time = exports.now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, "start"));
        loop((now) => {
          if (running) {
            if (now >= end_time) {
              tick3(0, 1);
              dispatch(node, false, "end");
              if (!--group.r) {
                run_all2(group.c);
              }
              return false;
            }
            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick3(1 - t, t);
            }
          }
          return running;
        });
      }
      if (is_function2(config)) {
        wait().then(() => {
          config = config();
          go();
        });
      } else {
        go();
      }
      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }
          if (running) {
            if (animation_name)
              delete_rule(node, animation_name);
            running = false;
          }
        }
      };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
      let config = fn(node, params);
      let t = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;
      function clear_animation() {
        if (animation_name)
          delete_rule(node, animation_name);
      }
      function init3(program, duration) {
        const d2 = program.b - t;
        duration *= Math.abs(d2);
        return {
          a: t,
          b: program.b,
          d: d2,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }
      function go(b) {
        const { delay = 0, duration = 300, easing = identity2, tick: tick3 = noop3, css: css2 } = config || null_transition;
        const program = {
          start: exports.now() + delay,
          b
        };
        if (!b) {
          program.group = outros;
          outros.r += 1;
        }
        if (running_program || pending_program) {
          pending_program = program;
        } else {
          if (css2) {
            clear_animation();
            animation_name = create_rule(node, t, b, duration, delay, easing, css2);
          }
          if (b)
            tick3(0, 1);
          running_program = init3(program, duration);
          add_render_callback(() => dispatch(node, b, "start"));
          loop((now) => {
            if (pending_program && now > pending_program.start) {
              running_program = init3(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, "start");
              if (css2) {
                clear_animation();
                animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }
            if (running_program) {
              if (now >= running_program.end) {
                tick3(t = running_program.b, 1 - t);
                dispatch(node, running_program.b, "end");
                if (!pending_program) {
                  if (running_program.b) {
                    clear_animation();
                  } else {
                    if (!--running_program.group.r)
                      run_all2(running_program.group.c);
                  }
                }
                running_program = null;
              } else if (now >= running_program.start) {
                const p = now - running_program.start;
                t = running_program.a + running_program.d * easing(p / running_program.duration);
                tick3(t, 1 - t);
              }
            }
            return !!(running_program || pending_program);
          });
        }
      }
      return {
        run(b) {
          if (is_function2(config)) {
            wait().then(() => {
              config = config();
              go(b);
            });
          } else {
            go(b);
          }
        },
        end() {
          clear_animation();
          running_program = pending_program = null;
        }
      };
    }
    function handle_promise(promise2, info) {
      const token = info.token = {};
      function update2(type, index2, key, value) {
        if (info.token !== token)
          return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== void 0) {
          child_ctx = child_ctx.slice();
          child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
          if (info.blocks) {
            info.blocks.forEach((block2, i) => {
              if (i !== index2 && block2) {
                group_outros();
                transition_out(block2, 1, 1, () => {
                  if (info.blocks[i] === block2) {
                    info.blocks[i] = null;
                  }
                });
                check_outros();
              }
            });
          } else {
            info.block.d(1);
          }
          block.c();
          transition_in(block, 1);
          block.m(info.mount(), info.anchor);
          needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
          info.blocks[index2] = block;
        if (needs_flush) {
          flush();
        }
      }
      if (is_promise(promise2)) {
        const current_component2 = get_current_component2();
        promise2.then((value) => {
          set_current_component2(current_component2);
          update2(info.then, 1, info.value, value);
          set_current_component2(null);
        }, (error3) => {
          set_current_component2(current_component2);
          update2(info.catch, 2, info.error, error3);
          set_current_component2(null);
          if (!info.hasCatch) {
            throw error3;
          }
        });
        if (info.current !== info.pending) {
          update2(info.pending, 0);
          return true;
        }
      } else {
        if (info.current !== info.then) {
          update2(info.then, 1, info.value, promise2);
          return true;
        }
        info.resolved = promise2;
      }
    }
    function update_await_block_branch(info, ctx, dirty) {
      const child_ctx = ctx.slice();
      const { resolved } = info;
      if (info.current === info.then) {
        child_ctx[info.value] = resolved;
      }
      if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
      }
      info.block.p(child_ctx, dirty);
    }
    var globals2 = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
    function destroy_block(block, lookup) {
      block.d(1);
      lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }
    function fix_and_destroy_block(block, lookup) {
      block.f();
      destroy_block(block, lookup);
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
      block.f();
      outro_and_destroy_block(block, lookup);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};
      while (i--)
        old_indexes[old_blocks[i].key] = i;
      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;
      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
          deltas.set(key, Math.abs(i - old_indexes[key]));
      }
      const will_move = new Set();
      const did_move = new Set();
      function insert2(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }
      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          next = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          destroy(old_block, lookup);
          o--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert2(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert2(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }
      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
          destroy(old_block, lookup);
      }
      while (n)
        insert2(new_blocks[n - 1]);
      return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
      const keys = new Set();
      for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
          throw new Error("Cannot have duplicate keys in a keyed each");
        }
        keys.add(key);
      }
    }
    function get_spread_update(levels, updates) {
      const update2 = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i = levels.length;
      while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
          for (const key in o) {
            if (!(key in n))
              to_null_out[key] = 1;
          }
          for (const key in n) {
            if (!accounted_for[key]) {
              update2[key] = n[key];
              accounted_for[key] = 1;
            }
          }
          levels[i] = n;
        } else {
          for (const key in o) {
            accounted_for[key] = 1;
          }
        }
      }
      for (const key in to_null_out) {
        if (!(key in update2))
          update2[key] = void 0;
      }
      return update2;
    }
    function get_spread_object(spread_props) {
      return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
    }
    var boolean_attributes2 = new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    function spread(args, classes_to_add) {
      const attributes = Object.assign({}, ...args);
      if (classes_to_add) {
        if (attributes.class == null) {
          attributes.class = classes_to_add;
        } else {
          attributes.class += " " + classes_to_add;
        }
      }
      let str = "";
      Object.keys(attributes).forEach((name) => {
        if (invalid_attribute_name_character.test(name))
          return;
        const value = attributes[name];
        if (value === true)
          str += " " + name;
        else if (boolean_attributes2.has(name.toLowerCase())) {
          if (value)
            str += " " + name;
        } else if (value != null) {
          str += ` ${name}="${value}"`;
        }
      });
      return str;
    }
    var escaped3 = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    function escape3(html) {
      return String(html).replace(/["'&<>]/g, (match) => escaped3[match]);
    }
    function escape_attribute_value(value) {
      return typeof value === "string" ? escape3(value) : value;
    }
    function escape_object(obj) {
      const result = {};
      for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
      }
      return result;
    }
    function each2(items, fn) {
      let str = "";
      for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
      }
      return str;
    }
    var missing_component2 = {
      $$render: () => ""
    };
    function validate_component2(component, name) {
      if (!component || !component.$$render) {
        if (name === "svelte:component")
          name += " this={...}";
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
      }
      return component;
    }
    function debug(file, line, column, values) {
      console.log(`{@debug} ${file ? file + " " : ""}(${line}:${column})`);
      console.log(values);
      return "";
    }
    var on_destroy2;
    function create_ssr_component2(fn) {
      function $$render(result, props, bindings, slots, context) {
        const parent_component = exports.current_component;
        const $$ = {
          on_destroy: on_destroy2,
          context: new Map(parent_component ? parent_component.$$.context : context || []),
          on_mount: [],
          before_update: [],
          after_update: [],
          callbacks: blank_object2()
        };
        set_current_component2({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component2(parent_component);
        return html;
      }
      return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
          on_destroy2 = [];
          const result = { title: "", head: "", css: new Set() };
          const html = $$render(result, props, {}, $$slots, context);
          run_all2(on_destroy2);
          return {
            html,
            css: {
              code: Array.from(result.css).map((css2) => css2.code).join("\n"),
              map: null
            },
            head: result.title + result.head
          };
        },
        $$render
      };
    }
    function add_attribute2(name, value, boolean) {
      if (value == null || boolean && !value)
        return "";
      return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape3(value)) : `"${value}"`}`}`;
    }
    function add_classes(classes) {
      return classes ? ` class="${classes}"` : "";
    }
    function bind(component, name, callback) {
      const index2 = component.$$.props[name];
      if (index2 !== void 0) {
        component.$$.bound[index2] = callback;
        callback(component.$$.ctx[index2]);
      }
    }
    function create_component(block) {
      block && block.c();
    }
    function claim_component(block, parent_nodes) {
      block && block.l(parent_nodes);
    }
    function mount_component(component, target, anchor, customElement) {
      const { fragment, on_mount, on_destroy: on_destroy3, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      if (!customElement) {
        add_render_callback(() => {
          const new_on_destroy = on_mount.map(run2).filter(is_function2);
          if (on_destroy3) {
            on_destroy3.push(...new_on_destroy);
          } else {
            run_all2(new_on_destroy);
          }
          component.$$.on_mount = [];
        });
      }
      after_update.forEach(add_render_callback);
    }
    function destroy_component2(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        run_all2($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }
    function init2(component, options2, instance, create_fragment, not_equal2, props, dirty = [-1]) {
      const parent_component = exports.current_component;
      set_current_component2(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        props,
        update: noop3,
        not_equal: not_equal2,
        bound: blank_object2(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options2.context || []),
        callbacks: blank_object2(),
        dirty,
        skip_bound: false
      };
      let ready = false;
      $$.ctx = instance ? instance(component, options2.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal2($$.ctx[i], $$.ctx[i] = value)) {
          if (!$$.skip_bound && $$.bound[i])
            $$.bound[i](value);
          if (ready)
            make_dirty(component, i);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all2($$.before_update);
      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
      if (options2.target) {
        if (options2.hydrate) {
          start_hydrating();
          const nodes = children(options2.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options2.intro)
          transition_in(component.$$.fragment);
        mount_component(component, options2.target, options2.anchor, options2.customElement);
        end_hydrating();
        flush();
      }
      set_current_component2(parent_component);
    }
    if (typeof HTMLElement === "function") {
      exports.SvelteElement = class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { on_mount } = this.$$;
          this.$$.on_disconnect = on_mount.map(run2).filter(is_function2);
          for (const key in this.$$.slotted) {
            this.appendChild(this.$$.slotted[key]);
          }
        }
        attributeChangedCallback(attr2, _oldValue, newValue) {
          this[attr2] = newValue;
        }
        disconnectedCallback() {
          run_all2(this.$$.on_disconnect);
        }
        $destroy() {
          destroy_component2(this, 1);
          this.$destroy = noop3;
        }
        $on(type, callback) {
          const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return () => {
            const index2 = callbacks.indexOf(callback);
            if (index2 !== -1)
              callbacks.splice(index2, 1);
          };
        }
        $set($$props) {
          if (this.$$set && !is_empty2($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      };
    }
    var SvelteComponent = class {
      $destroy() {
        destroy_component2(this, 1);
        this.$destroy = noop3;
      }
      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index2 = callbacks.indexOf(callback);
          if (index2 !== -1)
            callbacks.splice(index2, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty2($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event2(type, Object.assign({ version: "3.38.3" }, detail)));
    }
    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append(target, node);
    }
    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert(target, node, anchor);
    }
    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", { node });
      detach(node);
    }
    function detach_between_dev(before, after) {
      while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
      }
    }
    function detach_before_dev(after) {
      while (after.previousSibling) {
        detach_dev(after.previousSibling);
      }
    }
    function detach_after_dev(before) {
      while (before.nextSibling) {
        detach_dev(before.nextSibling);
      }
    }
    function listen_dev(node, event, handler, options2, has_prevent_default, has_stop_propagation) {
      const modifiers = options2 === true ? ["capture"] : options2 ? Array.from(Object.keys(options2)) : [];
      if (has_prevent_default)
        modifiers.push("preventDefault");
      if (has_stop_propagation)
        modifiers.push("stopPropagation");
      dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
      const dispose = listen(node, event, handler, options2);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
      };
    }
    function attr_dev(node, attribute, value) {
      attr(node, attribute, value);
      if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
      else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function dataset_dev(node, property, value) {
      node.dataset[property] = value;
      dispatch_dev("SvelteDOMSetDataset", { node, property, value });
    }
    function set_data_dev(text2, data) {
      data = "" + data;
      if (text2.wholeText === data)
        return;
      dispatch_dev("SvelteDOMSetData", { node: text2, data });
      text2.data = data;
    }
    function validate_each_argument(arg) {
      if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg)) {
        let msg = "{#each} only iterates over array-like objects.";
        if (typeof Symbol === "function" && arg && Symbol.iterator in arg) {
          msg += " You can use a spread to convert this iterable into an array.";
        }
        throw new Error(msg);
      }
    }
    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }
    var SvelteComponentDev2 = class extends SvelteComponent {
      constructor(options2) {
        if (!options2 || !options2.target && !options2.$$inline) {
          throw new Error("'target' is a required option");
        }
        super();
      }
      $destroy() {
        super.$destroy();
        this.$destroy = () => {
          console.warn("Component was already destroyed");
        };
      }
      $capture_state() {
      }
      $inject_state() {
      }
    };
    var SvelteComponentTyped2 = class extends SvelteComponentDev2 {
      constructor(options2) {
        super(options2);
      }
    };
    function loop_guard(timeout) {
      const start = Date.now();
      return () => {
        if (Date.now() - start > timeout) {
          throw new Error("Infinite loop detected");
        }
      };
    }
    exports.HtmlTag = HtmlTag;
    exports.SvelteComponent = SvelteComponent;
    exports.SvelteComponentDev = SvelteComponentDev2;
    exports.SvelteComponentTyped = SvelteComponentTyped2;
    exports.action_destroyer = action_destroyer;
    exports.add_attribute = add_attribute2;
    exports.add_classes = add_classes;
    exports.add_flush_callback = add_flush_callback;
    exports.add_location = add_location;
    exports.add_render_callback = add_render_callback;
    exports.add_resize_listener = add_resize_listener;
    exports.add_transform = add_transform;
    exports.afterUpdate = afterUpdate2;
    exports.append = append;
    exports.append_dev = append_dev;
    exports.assign = assign2;
    exports.attr = attr;
    exports.attr_dev = attr_dev;
    exports.attribute_to_object = attribute_to_object;
    exports.beforeUpdate = beforeUpdate2;
    exports.bind = bind;
    exports.binding_callbacks = binding_callbacks;
    exports.blank_object = blank_object2;
    exports.bubble = bubble;
    exports.check_outros = check_outros;
    exports.children = children;
    exports.claim_component = claim_component;
    exports.claim_element = claim_element;
    exports.claim_html_tag = claim_html_tag;
    exports.claim_space = claim_space;
    exports.claim_text = claim_text;
    exports.clear_loops = clear_loops;
    exports.component_subscribe = component_subscribe;
    exports.compute_rest_props = compute_rest_props;
    exports.compute_slots = compute_slots;
    exports.createEventDispatcher = createEventDispatcher2;
    exports.create_animation = create_animation;
    exports.create_bidirectional_transition = create_bidirectional_transition;
    exports.create_component = create_component;
    exports.create_in_transition = create_in_transition;
    exports.create_out_transition = create_out_transition;
    exports.create_slot = create_slot;
    exports.create_ssr_component = create_ssr_component2;
    exports.custom_event = custom_event2;
    exports.dataset_dev = dataset_dev;
    exports.debug = debug;
    exports.destroy_block = destroy_block;
    exports.destroy_component = destroy_component2;
    exports.destroy_each = destroy_each;
    exports.detach = detach;
    exports.detach_after_dev = detach_after_dev;
    exports.detach_before_dev = detach_before_dev;
    exports.detach_between_dev = detach_between_dev;
    exports.detach_dev = detach_dev;
    exports.dirty_components = dirty_components;
    exports.dispatch_dev = dispatch_dev;
    exports.each = each2;
    exports.element = element;
    exports.element_is = element_is;
    exports.empty = empty2;
    exports.end_hydrating = end_hydrating;
    exports.escape = escape3;
    exports.escape_attribute_value = escape_attribute_value;
    exports.escape_object = escape_object;
    exports.escaped = escaped3;
    exports.exclude_internal_props = exclude_internal_props;
    exports.fix_and_destroy_block = fix_and_destroy_block;
    exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
    exports.fix_position = fix_position;
    exports.flush = flush;
    exports.getContext = getContext2;
    exports.get_binding_group_value = get_binding_group_value;
    exports.get_current_component = get_current_component2;
    exports.get_custom_elements_slots = get_custom_elements_slots;
    exports.get_slot_changes = get_slot_changes;
    exports.get_slot_context = get_slot_context;
    exports.get_spread_object = get_spread_object;
    exports.get_spread_update = get_spread_update;
    exports.get_store_value = get_store_value2;
    exports.globals = globals2;
    exports.group_outros = group_outros;
    exports.handle_promise = handle_promise;
    exports.hasContext = hasContext2;
    exports.has_prop = has_prop;
    exports.identity = identity2;
    exports.init = init2;
    exports.insert = insert;
    exports.insert_dev = insert_dev;
    exports.intros = intros;
    exports.invalid_attribute_name_character = invalid_attribute_name_character;
    exports.is_client = is_client;
    exports.is_crossorigin = is_crossorigin;
    exports.is_empty = is_empty2;
    exports.is_function = is_function2;
    exports.is_promise = is_promise;
    exports.listen = listen;
    exports.listen_dev = listen_dev;
    exports.loop = loop;
    exports.loop_guard = loop_guard;
    exports.missing_component = missing_component2;
    exports.mount_component = mount_component;
    exports.noop = noop3;
    exports.not_equal = not_equal;
    exports.null_to_empty = null_to_empty;
    exports.object_without_properties = object_without_properties;
    exports.onDestroy = onDestroy2;
    exports.onMount = onMount2;
    exports.once = once;
    exports.outro_and_destroy_block = outro_and_destroy_block;
    exports.prevent_default = prevent_default;
    exports.prop_dev = prop_dev;
    exports.query_selector_all = query_selector_all;
    exports.run = run2;
    exports.run_all = run_all2;
    exports.safe_not_equal = safe_not_equal3;
    exports.schedule_update = schedule_update;
    exports.select_multiple_value = select_multiple_value;
    exports.select_option = select_option;
    exports.select_options = select_options;
    exports.select_value = select_value;
    exports.self = self2;
    exports.setContext = setContext2;
    exports.set_attributes = set_attributes;
    exports.set_current_component = set_current_component2;
    exports.set_custom_element_data = set_custom_element_data;
    exports.set_data = set_data;
    exports.set_data_dev = set_data_dev;
    exports.set_input_type = set_input_type;
    exports.set_input_value = set_input_value;
    exports.set_now = set_now;
    exports.set_raf = set_raf;
    exports.set_store_value = set_store_value;
    exports.set_style = set_style;
    exports.set_svg_attributes = set_svg_attributes;
    exports.space = space;
    exports.spread = spread;
    exports.start_hydrating = start_hydrating;
    exports.stop_propagation = stop_propagation;
    exports.subscribe = subscribe2;
    exports.svg_element = svg_element;
    exports.text = text;
    exports.tick = tick2;
    exports.time_ranges_to_array = time_ranges_to_array;
    exports.to_number = to_number;
    exports.toggle_class = toggle_class;
    exports.transition_in = transition_in;
    exports.transition_out = transition_out;
    exports.update_await_block_branch = update_await_block_branch;
    exports.update_keyed_each = update_keyed_each;
    exports.update_slot = update_slot;
    exports.update_slot_spread = update_slot_spread;
    exports.validate_component = validate_component2;
    exports.validate_each_argument = validate_each_argument;
    exports.validate_each_keys = validate_each_keys;
    exports.validate_slots = validate_slots;
    exports.validate_store = validate_store;
    exports.xlink_attr = xlink_attr;
  }
});

// node_modules/svelte/store/index.js
var require_store = __commonJS({
  "node_modules/svelte/store/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var internal = require_internal();
    var subscriber_queue3 = [];
    function readable(value, start) {
      return {
        subscribe: writable3(value, start).subscribe
      };
    }
    function writable3(value, start = internal.noop) {
      let stop;
      const subscribers = [];
      function set(new_value) {
        if (internal.safe_not_equal(value, new_value)) {
          value = new_value;
          if (stop) {
            const run_queue = !subscriber_queue3.length;
            for (let i = 0; i < subscribers.length; i += 1) {
              const s2 = subscribers[i];
              s2[1]();
              subscriber_queue3.push(s2, value);
            }
            if (run_queue) {
              for (let i = 0; i < subscriber_queue3.length; i += 2) {
                subscriber_queue3[i][0](subscriber_queue3[i + 1]);
              }
              subscriber_queue3.length = 0;
            }
          }
        }
      }
      function update(fn) {
        set(fn(value));
      }
      function subscribe2(run2, invalidate = internal.noop) {
        const subscriber = [run2, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
          stop = start(set) || internal.noop;
        }
        run2(value);
        return () => {
          const index2 = subscribers.indexOf(subscriber);
          if (index2 !== -1) {
            subscribers.splice(index2, 1);
          }
          if (subscribers.length === 0) {
            stop();
            stop = null;
          }
        };
      }
      return { set, update, subscribe: subscribe2 };
    }
    function derived(stores, fn, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      const auto = fn.length < 2;
      return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = internal.noop;
        const sync = () => {
          if (pending) {
            return;
          }
          cleanup();
          const result = fn(single ? values[0] : values, set);
          if (auto) {
            set(result);
          } else {
            cleanup = internal.is_function(result) ? result : internal.noop;
          }
        };
        const unsubscribers = stores_array.map((store, i) => internal.subscribe(store, (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (inited) {
            sync();
          }
        }, () => {
          pending |= 1 << i;
        }));
        inited = true;
        sync();
        return function stop() {
          internal.run_all(unsubscribers);
          cleanup();
        };
      });
    }
    Object.defineProperty(exports, "get", {
      enumerable: true,
      get: function() {
        return internal.get_store_value;
      }
    });
    exports.derived = derived;
    exports.readable = readable;
    exports.writable = writable3;
  }
});

// node_modules/svelte/index.js
var require_svelte = __commonJS({
  "node_modules/svelte/index.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var internal = require_internal();
    Object.defineProperty(exports, "SvelteComponent", {
      enumerable: true,
      get: function() {
        return internal.SvelteComponentDev;
      }
    });
    Object.defineProperty(exports, "SvelteComponentTyped", {
      enumerable: true,
      get: function() {
        return internal.SvelteComponentTyped;
      }
    });
    Object.defineProperty(exports, "afterUpdate", {
      enumerable: true,
      get: function() {
        return internal.afterUpdate;
      }
    });
    Object.defineProperty(exports, "beforeUpdate", {
      enumerable: true,
      get: function() {
        return internal.beforeUpdate;
      }
    });
    Object.defineProperty(exports, "createEventDispatcher", {
      enumerable: true,
      get: function() {
        return internal.createEventDispatcher;
      }
    });
    Object.defineProperty(exports, "getContext", {
      enumerable: true,
      get: function() {
        return internal.getContext;
      }
    });
    Object.defineProperty(exports, "hasContext", {
      enumerable: true,
      get: function() {
        return internal.hasContext;
      }
    });
    Object.defineProperty(exports, "onDestroy", {
      enumerable: true,
      get: function() {
        return internal.onDestroy;
      }
    });
    Object.defineProperty(exports, "onMount", {
      enumerable: true,
      get: function() {
        return internal.onMount;
      }
    });
    Object.defineProperty(exports, "setContext", {
      enumerable: true,
      get: function() {
        return internal.setContext;
      }
    });
    Object.defineProperty(exports, "tick", {
      enumerable: true,
      get: function() {
        return internal.tick;
      }
    });
  }
});

// node_modules/svelte-apollo-client/dist/svelte-apollo-client.cjs.js
var require_svelte_apollo_client_cjs = __commonJS({
  "node_modules/svelte-apollo-client/dist/svelte-apollo-client.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_core_cjs2();
    var store = require_store();
    var svelte = require_svelte();
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t[p] = s2[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function observableToReadable(observable, initialValue) {
      if (initialValue === void 0) {
        initialValue = {
          loading: true,
          data: void 0,
          error: void 0
        };
      }
      var store$1 = store.readable(initialValue, function(set) {
        var skipDuplicate = (initialValue === null || initialValue === void 0 ? void 0 : initialValue.data) !== void 0;
        var skipped = false;
        var subscription = observable.subscribe(function(result) {
          if (skipDuplicate && !skipped) {
            skipped = true;
            return;
          }
          if (result.errors) {
            var error3 = new core.ApolloError({ graphQLErrors: result.errors });
            set({ loading: false, data: void 0, error: error3 });
          } else {
            set({ loading: false, data: result.data, error: void 0 });
          }
        }, function(error3) {
          return set({ loading: false, data: void 0, error: error3 });
        });
        return function() {
          return subscription.unsubscribe();
        };
      });
      return store$1;
    }
    var extensions = [
      "fetchMore",
      "getCurrentResult",
      "getLastError",
      "getLastResult",
      "isDifferentFromLastResult",
      "refetch",
      "resetLastResults",
      "resetQueryStoreErrors",
      "result",
      "setOptions",
      "setVariables",
      "startPolling",
      "stopPolling",
      "subscribeToMore",
      "updateQuery"
    ];
    function observableQueryToReadable(query2, initialValue) {
      var store2 = observableToReadable(query2, initialValue);
      for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
        var extension = extensions_1[_i];
        store2[extension] = query2[extension].bind(query2);
      }
      return store2;
    }
    var restoring = typeof WeakSet !== "undefined" ? new WeakSet() : new Set();
    function restore(client2, query2, options2) {
      restoring.add(client2);
      afterHydrate(function() {
        return restoring.delete(client2);
      });
      client2.writeQuery(__assign({ query: query2 }, options2));
    }
    function afterHydrate(callback) {
      try {
        svelte.onMount(callback);
      } catch (_error) {
        setTimeout(callback, 1);
      }
    }
    function query(client2, query2, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var queryOptions = __assign(__assign({}, options2), { query: query2 });
      var initialValue;
      if (restoring.has(client2)) {
        try {
          initialValue = client2.readQuery(queryOptions) || void 0;
        } catch (err) {
        }
      }
      var observable = client2.watchQuery(queryOptions);
      var store2 = observableQueryToReadable(observable, initialValue !== void 0 ? {
        data: initialValue
      } : void 0);
      return store2;
    }
    function SvelteApolloClient2(options2) {
      var _a;
      var apolloClient = (_a = options2 === null || options2 === void 0 ? void 0 : options2.client) !== null && _a !== void 0 ? _a : new core.ApolloClient(options2);
      apolloClient.query = function(_query, options3) {
        if (options3 === void 0) {
          options3 = {};
        }
        return query(apolloClient, _query, options3);
      };
      var originalMutateFn = apolloClient.mutate;
      apolloClient.mutate = function(mutation, options3) {
        return originalMutateFn(__assign({ mutation }, options3));
      };
      apolloClient.restore = function(query2, options3) {
        return restore(apolloClient, query2, options3);
      };
      var _subscribe = apolloClient.subscribe.bind(apolloClient);
      apolloClient.subscribe = function(query2, options3) {
        if (options3 === void 0) {
          options3 = {};
        }
        var observable = _subscribe(__assign({ query: query2 }, options3));
        return observableToReadable(observable);
      };
      return apolloClient;
    }
    exports.SvelteApolloClient = SvelteApolloClient2;
  }
});

// node_modules/backo2/index.js
var require_backo2 = __commonJS({
  "node_modules/backo2/index.js"(exports, module2) {
    init_shims();
    module2.exports = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 1e4;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    init_shims();
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (typeof module2 !== "undefined") {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/subscriptions-transport-ws/dist/utils/is-string.js
var require_is_string = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/utils/is-string.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isString(value) {
      return typeof value === "string";
    }
    exports.default = isString;
  }
});

// node_modules/subscriptions-transport-ws/dist/utils/is-object.js
var require_is_object = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/utils/is-object.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject(value) {
      return value !== null && typeof value === "object";
    }
    exports.default = isObject;
  }
});

// node_modules/subscriptions-transport-ws/node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol("observable");
          _Symbol.observable = result;
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/symbol-observable/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/symbol-observable/lib/index.js"(exports, module2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _ponyfill = require_ponyfill2();
    var _ponyfill2 = _interopRequireDefault(_ponyfill);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var root;
    if (typeof self !== "undefined") {
      root = self;
    } else if (typeof window !== "undefined") {
      root = window;
    } else if (typeof global !== "undefined") {
      root = global;
    } else if (typeof module2 !== "undefined") {
      root = module2;
    } else {
      root = Function("return this")();
    }
    var result = (0, _ponyfill2["default"])(root);
    exports["default"] = result;
  }
});

// node_modules/subscriptions-transport-ws/dist/protocol.js
var require_protocol = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/protocol.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GRAPHQL_SUBSCRIPTIONS = exports.GRAPHQL_WS = void 0;
    var GRAPHQL_WS = "graphql-ws";
    exports.GRAPHQL_WS = GRAPHQL_WS;
    var GRAPHQL_SUBSCRIPTIONS = "graphql-subscriptions";
    exports.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;
  }
});

// node_modules/subscriptions-transport-ws/dist/defaults.js
var require_defaults = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/defaults.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WS_TIMEOUT = exports.MIN_WS_TIMEOUT = void 0;
    var MIN_WS_TIMEOUT = 1e3;
    exports.MIN_WS_TIMEOUT = MIN_WS_TIMEOUT;
    var WS_TIMEOUT = 3e4;
    exports.WS_TIMEOUT = WS_TIMEOUT;
  }
});

// node_modules/subscriptions-transport-ws/dist/message-types.js
var require_message_types = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/message-types.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MessageTypes = function() {
      function MessageTypes2() {
        throw new Error("Static Class");
      }
      MessageTypes2.GQL_CONNECTION_INIT = "connection_init";
      MessageTypes2.GQL_CONNECTION_ACK = "connection_ack";
      MessageTypes2.GQL_CONNECTION_ERROR = "connection_error";
      MessageTypes2.GQL_CONNECTION_KEEP_ALIVE = "ka";
      MessageTypes2.GQL_CONNECTION_TERMINATE = "connection_terminate";
      MessageTypes2.GQL_START = "start";
      MessageTypes2.GQL_DATA = "data";
      MessageTypes2.GQL_ERROR = "error";
      MessageTypes2.GQL_COMPLETE = "complete";
      MessageTypes2.GQL_STOP = "stop";
      MessageTypes2.SUBSCRIPTION_START = "subscription_start";
      MessageTypes2.SUBSCRIPTION_DATA = "subscription_data";
      MessageTypes2.SUBSCRIPTION_SUCCESS = "subscription_success";
      MessageTypes2.SUBSCRIPTION_FAIL = "subscription_fail";
      MessageTypes2.SUBSCRIPTION_END = "subscription_end";
      MessageTypes2.INIT = "init";
      MessageTypes2.INIT_SUCCESS = "init_success";
      MessageTypes2.INIT_FAIL = "init_fail";
      MessageTypes2.KEEP_ALIVE = "keepalive";
      return MessageTypes2;
    }();
    exports.default = MessageTypes;
  }
});

// node_modules/subscriptions-transport-ws/dist/client.js
var require_client = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/client.js"(exports) {
    init_shims();
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t[p] = s2[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
        s2 += arguments[i].length;
      for (var r = Array(s2), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionClient = void 0;
    var _global = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {};
    var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
    var Backoff = require_backo2();
    var eventemitter3_1 = require_eventemitter3();
    var is_string_1 = require_is_string();
    var is_object_1 = require_is_object();
    var printer_1 = require_printer();
    var getOperationAST_1 = require_getOperationAST();
    var symbol_observable_1 = require_lib2();
    var protocol_1 = require_protocol();
    var defaults_1 = require_defaults();
    var message_types_1 = require_message_types();
    var SubscriptionClient = function() {
      function SubscriptionClient2(url, options2, webSocketImpl, webSocketProtocols) {
        var _a = options2 || {}, _b = _a.connectionCallback, connectionCallback = _b === void 0 ? void 0 : _b, _c = _a.connectionParams, connectionParams = _c === void 0 ? {} : _c, _d = _a.minTimeout, minTimeout = _d === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d, _e = _a.timeout, timeout = _e === void 0 ? defaults_1.WS_TIMEOUT : _e, _f = _a.reconnect, reconnect = _f === void 0 ? false : _f, _g = _a.reconnectionAttempts, reconnectionAttempts = _g === void 0 ? Infinity : _g, _h = _a.lazy, lazy = _h === void 0 ? false : _h, _j = _a.inactivityTimeout, inactivityTimeout = _j === void 0 ? 0 : _j, _k = _a.wsOptionArguments, wsOptionArguments = _k === void 0 ? [] : _k;
        this.wsImpl = webSocketImpl || NativeWebSocket;
        if (!this.wsImpl) {
          throw new Error("Unable to find native implementation, or alternative implementation for WebSocket!");
        }
        this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;
        this.connectionCallback = connectionCallback;
        this.url = url;
        this.operations = {};
        this.nextOperationId = 0;
        this.minWsTimeout = minTimeout;
        this.wsTimeout = timeout;
        this.unsentMessagesQueue = [];
        this.reconnect = reconnect;
        this.reconnecting = false;
        this.reconnectionAttempts = reconnectionAttempts;
        this.lazy = !!lazy;
        this.inactivityTimeout = inactivityTimeout;
        this.closedByUser = false;
        this.backoff = new Backoff({ jitter: 0.5 });
        this.eventEmitter = new eventemitter3_1.EventEmitter();
        this.middlewares = [];
        this.client = null;
        this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
        this.connectionParams = this.getConnectionParams(connectionParams);
        this.wsOptionArguments = wsOptionArguments;
        if (!this.lazy) {
          this.connect();
        }
      }
      Object.defineProperty(SubscriptionClient2.prototype, "status", {
        get: function() {
          if (this.client === null) {
            return this.wsImpl.CLOSED;
          }
          return this.client.readyState;
        },
        enumerable: false,
        configurable: true
      });
      SubscriptionClient2.prototype.close = function(isForced, closedByUser) {
        if (isForced === void 0) {
          isForced = true;
        }
        if (closedByUser === void 0) {
          closedByUser = true;
        }
        this.clearInactivityTimeout();
        if (this.client !== null) {
          this.closedByUser = closedByUser;
          if (isForced) {
            this.clearCheckConnectionInterval();
            this.clearMaxConnectTimeout();
            this.clearTryReconnectTimeout();
            this.unsubscribeAll();
            this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_TERMINATE, null);
          }
          this.client.close();
          this.client.onopen = null;
          this.client.onclose = null;
          this.client.onerror = null;
          this.client.onmessage = null;
          this.client = null;
          this.eventEmitter.emit("disconnected");
          if (!isForced) {
            this.tryReconnect();
          }
        }
      };
      SubscriptionClient2.prototype.request = function(request) {
        var _a;
        var getObserver = this.getObserver.bind(this);
        var executeOperation = this.executeOperation.bind(this);
        var unsubscribe = this.unsubscribe.bind(this);
        var opId;
        this.clearInactivityTimeout();
        return _a = {}, _a[symbol_observable_1.default] = function() {
          return this;
        }, _a.subscribe = function(observerOrNext, onError, onComplete) {
          var observer = getObserver(observerOrNext, onError, onComplete);
          opId = executeOperation(request, function(error3, result) {
            if (error3 === null && result === null) {
              if (observer.complete) {
                observer.complete();
              }
            } else if (error3) {
              if (observer.error) {
                observer.error(error3[0]);
              }
            } else {
              if (observer.next) {
                observer.next(result);
              }
            }
          });
          return {
            unsubscribe: function() {
              if (opId) {
                unsubscribe(opId);
                opId = null;
              }
            }
          };
        }, _a;
      };
      SubscriptionClient2.prototype.on = function(eventName, callback, context) {
        var handler = this.eventEmitter.on(eventName, callback, context);
        return function() {
          handler.off(eventName, callback, context);
        };
      };
      SubscriptionClient2.prototype.onConnected = function(callback, context) {
        return this.on("connected", callback, context);
      };
      SubscriptionClient2.prototype.onConnecting = function(callback, context) {
        return this.on("connecting", callback, context);
      };
      SubscriptionClient2.prototype.onDisconnected = function(callback, context) {
        return this.on("disconnected", callback, context);
      };
      SubscriptionClient2.prototype.onReconnected = function(callback, context) {
        return this.on("reconnected", callback, context);
      };
      SubscriptionClient2.prototype.onReconnecting = function(callback, context) {
        return this.on("reconnecting", callback, context);
      };
      SubscriptionClient2.prototype.onError = function(callback, context) {
        return this.on("error", callback, context);
      };
      SubscriptionClient2.prototype.unsubscribeAll = function() {
        var _this = this;
        Object.keys(this.operations).forEach(function(subId) {
          _this.unsubscribe(subId);
        });
      };
      SubscriptionClient2.prototype.applyMiddlewares = function(options2) {
        var _this = this;
        return new Promise(function(resolve2, reject) {
          var queue = function(funcs, scope) {
            var next = function(error3) {
              if (error3) {
                reject(error3);
              } else {
                if (funcs.length > 0) {
                  var f = funcs.shift();
                  if (f) {
                    f.applyMiddleware.apply(scope, [options2, next]);
                  }
                } else {
                  resolve2(options2);
                }
              }
            };
            next();
          };
          queue(__spreadArrays(_this.middlewares), _this);
        });
      };
      SubscriptionClient2.prototype.use = function(middlewares) {
        var _this = this;
        middlewares.map(function(middleware) {
          if (typeof middleware.applyMiddleware === "function") {
            _this.middlewares.push(middleware);
          } else {
            throw new Error("Middleware must implement the applyMiddleware function.");
          }
        });
        return this;
      };
      SubscriptionClient2.prototype.getConnectionParams = function(connectionParams) {
        return function() {
          return new Promise(function(resolve2, reject) {
            if (typeof connectionParams === "function") {
              try {
                return resolve2(connectionParams.call(null));
              } catch (error3) {
                return reject(error3);
              }
            }
            resolve2(connectionParams);
          });
        };
      };
      SubscriptionClient2.prototype.executeOperation = function(options2, handler) {
        var _this = this;
        if (this.client === null) {
          this.connect();
        }
        var opId = this.generateOperationId();
        this.operations[opId] = { options: options2, handler };
        this.applyMiddlewares(options2).then(function(processedOptions) {
          _this.checkOperationOptions(processedOptions, handler);
          if (_this.operations[opId]) {
            _this.operations[opId] = { options: processedOptions, handler };
            _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);
          }
        }).catch(function(error3) {
          _this.unsubscribe(opId);
          handler(_this.formatErrors(error3));
        });
        return opId;
      };
      SubscriptionClient2.prototype.getObserver = function(observerOrNext, error3, complete) {
        if (typeof observerOrNext === "function") {
          return {
            next: function(v) {
              return observerOrNext(v);
            },
            error: function(e) {
              return error3 && error3(e);
            },
            complete: function() {
              return complete && complete();
            }
          };
        }
        return observerOrNext;
      };
      SubscriptionClient2.prototype.createMaxConnectTimeGenerator = function() {
        var minValue = this.minWsTimeout;
        var maxValue = this.wsTimeout;
        return new Backoff({
          min: minValue,
          max: maxValue,
          factor: 1.2
        });
      };
      SubscriptionClient2.prototype.clearCheckConnectionInterval = function() {
        if (this.checkConnectionIntervalId) {
          clearInterval(this.checkConnectionIntervalId);
          this.checkConnectionIntervalId = null;
        }
      };
      SubscriptionClient2.prototype.clearMaxConnectTimeout = function() {
        if (this.maxConnectTimeoutId) {
          clearTimeout(this.maxConnectTimeoutId);
          this.maxConnectTimeoutId = null;
        }
      };
      SubscriptionClient2.prototype.clearTryReconnectTimeout = function() {
        if (this.tryReconnectTimeoutId) {
          clearTimeout(this.tryReconnectTimeoutId);
          this.tryReconnectTimeoutId = null;
        }
      };
      SubscriptionClient2.prototype.clearInactivityTimeout = function() {
        if (this.inactivityTimeoutId) {
          clearTimeout(this.inactivityTimeoutId);
          this.inactivityTimeoutId = null;
        }
      };
      SubscriptionClient2.prototype.setInactivityTimeout = function() {
        var _this = this;
        if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {
          this.inactivityTimeoutId = setTimeout(function() {
            if (Object.keys(_this.operations).length === 0) {
              _this.close();
            }
          }, this.inactivityTimeout);
        }
      };
      SubscriptionClient2.prototype.checkOperationOptions = function(options2, handler) {
        var query = options2.query, variables = options2.variables, operationName = options2.operationName;
        if (!query) {
          throw new Error("Must provide a query.");
        }
        if (!handler) {
          throw new Error("Must provide an handler.");
        }
        if (!is_string_1.default(query) && !getOperationAST_1.getOperationAST(query, operationName) || operationName && !is_string_1.default(operationName) || variables && !is_object_1.default(variables)) {
          throw new Error("Incorrect option types. query must be a string or a document,`operationName` must be a string, and `variables` must be an object.");
        }
      };
      SubscriptionClient2.prototype.buildMessage = function(id, type, payload) {
        var payloadToReturn = payload && payload.query ? __assign(__assign({}, payload), { query: typeof payload.query === "string" ? payload.query : printer_1.print(payload.query) }) : payload;
        return {
          id,
          type,
          payload: payloadToReturn
        };
      };
      SubscriptionClient2.prototype.formatErrors = function(errors) {
        if (Array.isArray(errors)) {
          return errors;
        }
        if (errors && errors.errors) {
          return this.formatErrors(errors.errors);
        }
        if (errors && errors.message) {
          return [errors];
        }
        return [{
          name: "FormatedError",
          message: "Unknown error",
          originalError: errors
        }];
      };
      SubscriptionClient2.prototype.sendMessage = function(id, type, payload) {
        this.sendMessageRaw(this.buildMessage(id, type, payload));
      };
      SubscriptionClient2.prototype.sendMessageRaw = function(message) {
        switch (this.status) {
          case this.wsImpl.OPEN:
            var serializedMessage = JSON.stringify(message);
            try {
              JSON.parse(serializedMessage);
            } catch (e) {
              this.eventEmitter.emit("error", new Error("Message must be JSON-serializable. Got: " + message));
            }
            this.client.send(serializedMessage);
            break;
          case this.wsImpl.CONNECTING:
            this.unsentMessagesQueue.push(message);
            break;
          default:
            if (!this.reconnecting) {
              this.eventEmitter.emit("error", new Error("A message was not sent because socket is not connected, is closing or is already closed. Message was: " + JSON.stringify(message)));
            }
        }
      };
      SubscriptionClient2.prototype.generateOperationId = function() {
        return String(++this.nextOperationId);
      };
      SubscriptionClient2.prototype.tryReconnect = function() {
        var _this = this;
        if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
          return;
        }
        if (!this.reconnecting) {
          Object.keys(this.operations).forEach(function(key) {
            _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));
          });
          this.reconnecting = true;
        }
        this.clearTryReconnectTimeout();
        var delay = this.backoff.duration();
        this.tryReconnectTimeoutId = setTimeout(function() {
          _this.connect();
        }, delay);
      };
      SubscriptionClient2.prototype.flushUnsentMessagesQueue = function() {
        var _this = this;
        this.unsentMessagesQueue.forEach(function(message) {
          _this.sendMessageRaw(message);
        });
        this.unsentMessagesQueue = [];
      };
      SubscriptionClient2.prototype.checkConnection = function() {
        if (this.wasKeepAliveReceived) {
          this.wasKeepAliveReceived = false;
          return;
        }
        if (!this.reconnecting) {
          this.close(false, true);
        }
      };
      SubscriptionClient2.prototype.checkMaxConnectTimeout = function() {
        var _this = this;
        this.clearMaxConnectTimeout();
        this.maxConnectTimeoutId = setTimeout(function() {
          if (_this.status !== _this.wsImpl.OPEN) {
            _this.reconnecting = true;
            _this.close(false, true);
          }
        }, this.maxConnectTimeGenerator.duration());
      };
      SubscriptionClient2.prototype.connect = function() {
        var _a;
        var _this = this;
        this.client = new ((_a = this.wsImpl).bind.apply(_a, __spreadArrays([void 0, this.url, this.wsProtocols], this.wsOptionArguments)))();
        this.checkMaxConnectTimeout();
        this.client.onopen = function() {
          return __awaiter(_this, void 0, void 0, function() {
            var connectionParams, error_1;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (!(this.status === this.wsImpl.OPEN))
                    return [3, 4];
                  this.clearMaxConnectTimeout();
                  this.closedByUser = false;
                  this.eventEmitter.emit(this.reconnecting ? "reconnecting" : "connecting");
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 3, , 4]);
                  return [4, this.connectionParams()];
                case 2:
                  connectionParams = _a2.sent();
                  this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);
                  this.flushUnsentMessagesQueue();
                  return [3, 4];
                case 3:
                  error_1 = _a2.sent();
                  this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_ERROR, error_1);
                  this.flushUnsentMessagesQueue();
                  return [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        };
        this.client.onclose = function() {
          if (!_this.closedByUser) {
            _this.close(false, false);
          }
        };
        this.client.onerror = function(err) {
          _this.eventEmitter.emit("error", err);
        };
        this.client.onmessage = function(_a2) {
          var data = _a2.data;
          _this.processReceivedData(data);
        };
      };
      SubscriptionClient2.prototype.processReceivedData = function(receivedData) {
        var parsedMessage;
        var opId;
        try {
          parsedMessage = JSON.parse(receivedData);
          opId = parsedMessage.id;
        } catch (e) {
          throw new Error("Message must be JSON-parseable. Got: " + receivedData);
        }
        if ([
          message_types_1.default.GQL_DATA,
          message_types_1.default.GQL_COMPLETE,
          message_types_1.default.GQL_ERROR
        ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {
          this.unsubscribe(opId);
          return;
        }
        switch (parsedMessage.type) {
          case message_types_1.default.GQL_CONNECTION_ERROR:
            if (this.connectionCallback) {
              this.connectionCallback(parsedMessage.payload);
            }
            break;
          case message_types_1.default.GQL_CONNECTION_ACK:
            this.eventEmitter.emit(this.reconnecting ? "reconnected" : "connected", parsedMessage.payload);
            this.reconnecting = false;
            this.backoff.reset();
            this.maxConnectTimeGenerator.reset();
            if (this.connectionCallback) {
              this.connectionCallback();
            }
            break;
          case message_types_1.default.GQL_COMPLETE:
            var handler = this.operations[opId].handler;
            delete this.operations[opId];
            handler.call(this, null, null);
            break;
          case message_types_1.default.GQL_ERROR:
            this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);
            delete this.operations[opId];
            break;
          case message_types_1.default.GQL_DATA:
            var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign(__assign({}, parsedMessage.payload), { errors: this.formatErrors(parsedMessage.payload.errors) });
            this.operations[opId].handler(null, parsedPayload);
            break;
          case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:
            var firstKA = typeof this.wasKeepAliveReceived === "undefined";
            this.wasKeepAliveReceived = true;
            if (firstKA) {
              this.checkConnection();
            }
            if (this.checkConnectionIntervalId) {
              clearInterval(this.checkConnectionIntervalId);
              this.checkConnection();
            }
            this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);
            break;
          default:
            throw new Error("Invalid message type!");
        }
      };
      SubscriptionClient2.prototype.unsubscribe = function(opId) {
        if (this.operations[opId]) {
          delete this.operations[opId];
          this.setInactivityTimeout();
          this.sendMessage(opId, message_types_1.default.GQL_STOP, void 0);
        }
      };
      return SubscriptionClient2;
    }();
    exports.SubscriptionClient = SubscriptionClient;
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/constants.js"(exports, module2) {
    init_shims();
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports, module2) {
    init_shims();
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : "node";
    var arch = os.arch();
    var platform = os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load2;
    function load2(dir) {
      return runtimeRequire(load2.path(dir));
    }
    load2.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve2(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve2(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve2(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load2.parseTags = parseTags;
    load2.matchTags = matchTags;
    load2.compareTags = compareTags;
    load2.parseTuple = parseTuple;
    load2.matchTuple = matchTuple;
    load2.compareTuples = compareTuples;
  }
});

// node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "node_modules/bufferutil/fallback.js"(exports, module2) {
    init_shims();
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask2[i & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "node_modules/bufferutil/index.js"(exports, module2) {
    init_shims();
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e) {
      module2.exports = require_fallback();
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/buffer-util.js"(exports, module2) {
    init_shims();
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require_bufferutil();
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/limiter.js"(exports, module2) {
    init_shims();
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    init_shims();
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "node_modules/utf-8-validate/fallback.js"(exports, module2) {
    init_shims();
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "node_modules/utf-8-validate/index.js"(exports, module2) {
    init_shims();
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e) {
      module2.exports = require_fallback2();
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/validation.js
var require_validation2 = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/validation.js"(exports, module2) {
    init_shims();
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require_utf_8_validate();
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/receiver.js"(exports, module2) {
    init_shims();
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation2();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error3(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error3(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error3(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error3(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error3(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error3(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error3(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error3(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error3(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error3(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error3(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error3(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error3(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error3(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error3(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error3(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error3(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error3(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error3(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error3);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/sender.js"(exports, module2) {
    init_shims();
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation2();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options2) {
        const merge = options2.mask && options2.readOnly;
        let offset = options2.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options2.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options2, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options2.fin,
            rsv1,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options2.fin,
            rsv1: false,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options2.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options2.readOnly = false;
          this.sendFrame(Sender.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/event-target.js"(exports, module2) {
    init_shims();
    "use strict";
    var Event2 = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event2 {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event2 {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event2 {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event2 {
      constructor(error3, target) {
        super("error", target);
        this.message = error3.message;
        this.error = error3;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options2) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error3) {
          listener.call(this, new ErrorEvent(error3, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options2 && options2.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/extension.js"(exports, module2) {
    init_shims();
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format2(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format: format2, parse };
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/websocket.js"(exports, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events");
    var https2 = require("https");
    var http2 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes: randomBytes2, createHash } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format: format2, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options2 = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get onclose() {
        return void 0;
      }
      set onclose(listener) {
      }
      get onerror() {
        return void 0;
      }
      set onerror(listener) {
      }
      get onopen() {
        return void 0;
      }
      set onopen(listener) {
      }
      get onmessage() {
        return void 0;
      }
      set onmessage(listener) {
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options2
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options2) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options2,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes2(16).toString("base64");
      const get = isSecure ? https2.get : http2.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format2({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options2);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options2) {
      options2.path = options2.socketPath;
      return net.connect(options2);
    }
    function tlsConnect(options2) {
      options2.path = void 0;
      if (!options2.servername && options2.servername !== "") {
        options2.servername = net.isIP(options2.host) ? "" : options2.host;
      }
      return tls.connect(options2);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/stream.js"(exports, module2) {
    init_shims();
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws2, options2) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws2._socket.resume();
      }
      if (ws2.readyState === ws2.CONNECTING) {
        ws2.once("open", function open() {
          ws2._receiver.removeAllListeners("drain");
          ws2._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws2._receiver.removeAllListeners("drain");
        ws2._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options2,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws2.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws2._socket.pause();
        }
      });
      ws2.once("error", function error3(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws2.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws2.readyState === ws2.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws2.once("error", function error3(err2) {
          called = true;
          callback(err2);
        });
        ws2.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws2.terminate();
      };
      duplex._final = function(callback) {
        if (ws2.readyState === ws2.CONNECTING) {
          ws2.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws2._socket === null)
          return;
        if (ws2._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws2._socket.once("finish", function finish2() {
            callback();
          });
          ws2.close();
        }
      };
      duplex._read = function() {
        if ((ws2.readyState === ws2.OPEN || ws2.readyState === ws2.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws2._receiver._writableState.needDrain)
            ws2._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws2.readyState === ws2.CONNECTING) {
          ws2.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws2.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/lib/websocket-server.js"(exports, module2) {
    init_shims();
    "use strict";
    var EventEmitter = require("events");
    var http2 = require("http");
    var https2 = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format: format2, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options2, callback) {
        super();
        options2 = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options2
        };
        if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options2.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options2.port, options2.host, options2.backlog, callback);
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true)
          options2.perMessageDeflate = {};
        if (options2.clientTracking)
          this.clients = new Set();
        this.options = options2;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client2 of this.clients)
            client2.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index2 = req.url.indexOf("?");
          const pathname = index2 !== -1 ? req.url.slice(0, index2) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws2 = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws2._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format2({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws2._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws2.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws2);
          ws2.on("close", () => this.clients.delete(ws2));
        }
        cb(ws2, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http2.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/subscriptions-transport-ws/node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/subscriptions-transport-ws/node_modules/ws/index.js"(exports, module2) {
    init_shims();
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/iterall/index.js
var require_iterall = __commonJS({
  "node_modules/iterall/index.js"(exports) {
    init_shims();
    "use strict";
    exports.isIterable = isIterable;
    exports.isArrayLike = isArrayLike;
    exports.isCollection = isCollection;
    exports.getIterator = getIterator;
    exports.getIteratorMethod = getIteratorMethod;
    exports.createIterator = createIterator;
    exports.forEach = forEach;
    exports.isAsyncIterable = isAsyncIterable;
    exports.getAsyncIterator = getAsyncIterator;
    exports.getAsyncIteratorMethod = getAsyncIteratorMethod;
    exports.createAsyncIterator = createAsyncIterator;
    exports.forAwaitEach = forAwaitEach;
    var SYMBOL = typeof Symbol === "function" ? Symbol : void 0;
    var SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator;
    var $$iterator = exports.$$iterator = SYMBOL_ITERATOR || "@@iterator";
    function isIterable(obj) {
      return !!getIteratorMethod(obj);
    }
    function isArrayLike(obj) {
      var length = obj != null && obj.length;
      return typeof length === "number" && length >= 0 && length % 1 === 0;
    }
    function isCollection(obj) {
      return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj));
    }
    function getIterator(iterable) {
      var method = getIteratorMethod(iterable);
      if (method) {
        return method.call(iterable);
      }
    }
    function getIteratorMethod(iterable) {
      if (iterable != null) {
        var method = SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR] || iterable["@@iterator"];
        if (typeof method === "function") {
          return method;
        }
      }
    }
    function createIterator(collection) {
      if (collection != null) {
        var iterator = getIterator(collection);
        if (iterator) {
          return iterator;
        }
        if (isArrayLike(collection)) {
          return new ArrayLikeIterator(collection);
        }
      }
    }
    function ArrayLikeIterator(obj) {
      this._o = obj;
      this._i = 0;
    }
    ArrayLikeIterator.prototype[$$iterator] = function() {
      return this;
    };
    ArrayLikeIterator.prototype.next = function() {
      if (this._o === void 0 || this._i >= this._o.length) {
        this._o = void 0;
        return { value: void 0, done: true };
      }
      return { value: this._o[this._i++], done: false };
    };
    function forEach(collection, callback, thisArg) {
      if (collection != null) {
        if (typeof collection.forEach === "function") {
          return collection.forEach(callback, thisArg);
        }
        var i = 0;
        var iterator = getIterator(collection);
        if (iterator) {
          var step;
          while (!(step = iterator.next()).done) {
            callback.call(thisArg, step.value, i++, collection);
            if (i > 9999999) {
              throw new TypeError("Near-infinite iteration.");
            }
          }
        } else if (isArrayLike(collection)) {
          for (; i < collection.length; i++) {
            if (collection.hasOwnProperty(i)) {
              callback.call(thisArg, collection[i], i, collection);
            }
          }
        }
      }
    }
    var SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator;
    var $$asyncIterator = exports.$$asyncIterator = SYMBOL_ASYNC_ITERATOR || "@@asyncIterator";
    function isAsyncIterable(obj) {
      return !!getAsyncIteratorMethod(obj);
    }
    function getAsyncIterator(asyncIterable) {
      var method = getAsyncIteratorMethod(asyncIterable);
      if (method) {
        return method.call(asyncIterable);
      }
    }
    function getAsyncIteratorMethod(asyncIterable) {
      if (asyncIterable != null) {
        var method = SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR] || asyncIterable["@@asyncIterator"];
        if (typeof method === "function") {
          return method;
        }
      }
    }
    function createAsyncIterator(source) {
      if (source != null) {
        var asyncIterator = getAsyncIterator(source);
        if (asyncIterator) {
          return asyncIterator;
        }
        var iterator = createIterator(source);
        if (iterator) {
          return new AsyncFromSyncIterator(iterator);
        }
      }
    }
    function AsyncFromSyncIterator(iterator) {
      this._i = iterator;
    }
    AsyncFromSyncIterator.prototype[$$asyncIterator] = function() {
      return this;
    };
    AsyncFromSyncIterator.prototype.next = function(value) {
      return unwrapAsyncFromSync(this._i, "next", value);
    };
    AsyncFromSyncIterator.prototype.return = function(value) {
      return this._i.return ? unwrapAsyncFromSync(this._i, "return", value) : Promise.resolve({ value, done: true });
    };
    AsyncFromSyncIterator.prototype.throw = function(value) {
      return this._i.throw ? unwrapAsyncFromSync(this._i, "throw", value) : Promise.reject(value);
    };
    function unwrapAsyncFromSync(iterator, fn, value) {
      var step;
      return new Promise(function(resolve2) {
        step = iterator[fn](value);
        resolve2(step.value);
      }).then(function(value2) {
        return { value: value2, done: step.done };
      });
    }
    function forAwaitEach(source, callback, thisArg) {
      var asyncIterator = createAsyncIterator(source);
      if (asyncIterator) {
        var i = 0;
        return new Promise(function(resolve2, reject) {
          function next() {
            asyncIterator.next().then(function(step) {
              if (!step.done) {
                Promise.resolve(callback.call(thisArg, step.value, i++, source)).then(next).catch(reject);
              } else {
                resolve2();
              }
              return null;
            }).catch(reject);
            return null;
          }
          next();
        });
      }
    }
  }
});

// node_modules/subscriptions-transport-ws/dist/utils/empty-iterable.js
var require_empty_iterable = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/utils/empty-iterable.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEmptyIterable = void 0;
    var iterall_1 = require_iterall();
    exports.createEmptyIterable = function() {
      var _a;
      return _a = {
        next: function() {
          return Promise.resolve({ value: void 0, done: true });
        },
        return: function() {
          return Promise.resolve({ value: void 0, done: true });
        },
        throw: function(e) {
          return Promise.reject(e);
        }
      }, _a[iterall_1.$$asyncIterator] = function() {
        return this;
      }, _a;
    };
  }
});

// node_modules/subscriptions-transport-ws/dist/utils/is-subscriptions.js
var require_is_subscriptions = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/utils/is-subscriptions.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isASubscriptionOperation = void 0;
    var graphql_1 = require_graphql2();
    exports.isASubscriptionOperation = function(document2, operationName) {
      var operationAST = graphql_1.getOperationAST(document2, operationName);
      return !!operationAST && operationAST.operation === "subscription";
    };
  }
});

// node_modules/subscriptions-transport-ws/dist/legacy/parse-legacy-protocol.js
var require_parse_legacy_protocol = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/legacy/parse-legacy-protocol.js"(exports) {
    init_shims();
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t[p] = s2[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseLegacyProtocolMessage = void 0;
    var message_types_1 = require_message_types();
    exports.parseLegacyProtocolMessage = function(connectionContext, message) {
      var messageToReturn = message;
      switch (message.type) {
        case message_types_1.default.INIT:
          connectionContext.isLegacy = true;
          messageToReturn = __assign(__assign({}, message), { type: message_types_1.default.GQL_CONNECTION_INIT });
          break;
        case message_types_1.default.SUBSCRIPTION_START:
          messageToReturn = {
            id: message.id,
            type: message_types_1.default.GQL_START,
            payload: {
              query: message.query,
              operationName: message.operationName,
              variables: message.variables
            }
          };
          break;
        case message_types_1.default.SUBSCRIPTION_END:
          messageToReturn = __assign(__assign({}, message), { type: message_types_1.default.GQL_STOP });
          break;
        case message_types_1.default.GQL_CONNECTION_ACK:
          if (connectionContext.isLegacy) {
            messageToReturn = __assign(__assign({}, message), { type: message_types_1.default.INIT_SUCCESS });
          }
          break;
        case message_types_1.default.GQL_CONNECTION_ERROR:
          if (connectionContext.isLegacy) {
            messageToReturn = __assign(__assign({}, message), { type: message_types_1.default.INIT_FAIL, payload: message.payload.message ? { error: message.payload.message } : message.payload });
          }
          break;
        case message_types_1.default.GQL_ERROR:
          if (connectionContext.isLegacy) {
            messageToReturn = __assign(__assign({}, message), { type: message_types_1.default.SUBSCRIPTION_FAIL });
          }
          break;
        case message_types_1.default.GQL_DATA:
          if (connectionContext.isLegacy) {
            messageToReturn = __assign(__assign({}, message), { type: message_types_1.default.SUBSCRIPTION_DATA });
          }
          break;
        case message_types_1.default.GQL_COMPLETE:
          if (connectionContext.isLegacy) {
            messageToReturn = null;
          }
          break;
        case message_types_1.default.SUBSCRIPTION_SUCCESS:
          if (!connectionContext.isLegacy) {
            messageToReturn = null;
          }
          break;
        default:
          break;
      }
      return messageToReturn;
    };
  }
});

// node_modules/subscriptions-transport-ws/dist/server.js
var require_server = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/server.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionServer = void 0;
    var WebSocket = require_ws();
    var message_types_1 = require_message_types();
    var protocol_1 = require_protocol();
    var is_object_1 = require_is_object();
    var graphql_1 = require_graphql2();
    var empty_iterable_1 = require_empty_iterable();
    var iterall_1 = require_iterall();
    var is_subscriptions_1 = require_is_subscriptions();
    var parse_legacy_protocol_1 = require_parse_legacy_protocol();
    var isWebSocketServer = function(socket) {
      return socket.on;
    };
    var SubscriptionServer = function() {
      function SubscriptionServer2(options2, socketOptionsOrServer) {
        var _this = this;
        var onOperation = options2.onOperation, onOperationComplete = options2.onOperationComplete, onConnect = options2.onConnect, onDisconnect = options2.onDisconnect, keepAlive = options2.keepAlive;
        this.specifiedRules = options2.validationRules || graphql_1.specifiedRules;
        this.loadExecutor(options2);
        this.onOperation = onOperation;
        this.onOperationComplete = onOperationComplete;
        this.onConnect = onConnect;
        this.onDisconnect = onDisconnect;
        this.keepAlive = keepAlive;
        if (isWebSocketServer(socketOptionsOrServer)) {
          this.wsServer = socketOptionsOrServer;
        } else {
          this.wsServer = new WebSocket.Server(socketOptionsOrServer || {});
        }
        var connectionHandler = function(socket, request) {
          socket.upgradeReq = request;
          if (socket.protocol === void 0 || socket.protocol.indexOf(protocol_1.GRAPHQL_WS) === -1 && socket.protocol.indexOf(protocol_1.GRAPHQL_SUBSCRIPTIONS) === -1) {
            socket.close(1002);
            return;
          }
          var connectionContext = Object.create(null);
          connectionContext.initPromise = Promise.resolve(true);
          connectionContext.isLegacy = false;
          connectionContext.socket = socket;
          connectionContext.request = request;
          connectionContext.operations = {};
          var connectionClosedHandler = function(error3) {
            if (error3) {
              _this.sendError(connectionContext, "", { message: error3.message ? error3.message : error3 }, message_types_1.default.GQL_CONNECTION_ERROR);
              setTimeout(function() {
                connectionContext.socket.close(1011);
              }, 10);
            }
            _this.onClose(connectionContext);
            if (_this.onDisconnect) {
              _this.onDisconnect(socket, connectionContext);
            }
          };
          socket.on("error", connectionClosedHandler);
          socket.on("close", connectionClosedHandler);
          socket.on("message", _this.onMessage(connectionContext));
        };
        this.wsServer.on("connection", connectionHandler);
        this.closeHandler = function() {
          _this.wsServer.removeListener("connection", connectionHandler);
          _this.wsServer.close();
        };
      }
      SubscriptionServer2.create = function(options2, socketOptionsOrServer) {
        return new SubscriptionServer2(options2, socketOptionsOrServer);
      };
      Object.defineProperty(SubscriptionServer2.prototype, "server", {
        get: function() {
          return this.wsServer;
        },
        enumerable: false,
        configurable: true
      });
      SubscriptionServer2.prototype.close = function() {
        this.closeHandler();
      };
      SubscriptionServer2.prototype.loadExecutor = function(options2) {
        var execute = options2.execute, subscribe2 = options2.subscribe, schema = options2.schema, rootValue = options2.rootValue;
        if (!execute) {
          throw new Error("Must provide `execute` for websocket server constructor.");
        }
        this.schema = schema;
        this.rootValue = rootValue;
        this.execute = execute;
        this.subscribe = subscribe2;
      };
      SubscriptionServer2.prototype.unsubscribe = function(connectionContext, opId) {
        if (connectionContext.operations && connectionContext.operations[opId]) {
          if (connectionContext.operations[opId].return) {
            connectionContext.operations[opId].return();
          }
          delete connectionContext.operations[opId];
          if (this.onOperationComplete) {
            this.onOperationComplete(connectionContext.socket, opId);
          }
        }
      };
      SubscriptionServer2.prototype.onClose = function(connectionContext) {
        var _this = this;
        Object.keys(connectionContext.operations).forEach(function(opId) {
          _this.unsubscribe(connectionContext, opId);
        });
      };
      SubscriptionServer2.prototype.onMessage = function(connectionContext) {
        var _this = this;
        return function(message) {
          var parsedMessage;
          try {
            parsedMessage = parse_legacy_protocol_1.parseLegacyProtocolMessage(connectionContext, JSON.parse(message));
          } catch (e) {
            _this.sendError(connectionContext, null, { message: e.message }, message_types_1.default.GQL_CONNECTION_ERROR);
            return;
          }
          var opId = parsedMessage.id;
          switch (parsedMessage.type) {
            case message_types_1.default.GQL_CONNECTION_INIT:
              if (_this.onConnect) {
                connectionContext.initPromise = new Promise(function(resolve2, reject) {
                  try {
                    resolve2(_this.onConnect(parsedMessage.payload, connectionContext.socket, connectionContext));
                  } catch (e) {
                    reject(e);
                  }
                });
              }
              connectionContext.initPromise.then(function(result) {
                if (result === false) {
                  throw new Error("Prohibited connection!");
                }
                _this.sendMessage(connectionContext, void 0, message_types_1.default.GQL_CONNECTION_ACK, void 0);
                if (_this.keepAlive) {
                  _this.sendKeepAlive(connectionContext);
                  var keepAliveTimer_1 = setInterval(function() {
                    if (connectionContext.socket.readyState === WebSocket.OPEN) {
                      _this.sendKeepAlive(connectionContext);
                    } else {
                      clearInterval(keepAliveTimer_1);
                    }
                  }, _this.keepAlive);
                }
              }).catch(function(error3) {
                _this.sendError(connectionContext, opId, { message: error3.message }, message_types_1.default.GQL_CONNECTION_ERROR);
                setTimeout(function() {
                  connectionContext.socket.close(1011);
                }, 10);
              });
              break;
            case message_types_1.default.GQL_CONNECTION_TERMINATE:
              connectionContext.socket.close();
              break;
            case message_types_1.default.GQL_START:
              connectionContext.initPromise.then(function(initResult) {
                if (connectionContext.operations && connectionContext.operations[opId]) {
                  _this.unsubscribe(connectionContext, opId);
                }
                var baseParams = {
                  query: parsedMessage.payload.query,
                  variables: parsedMessage.payload.variables,
                  operationName: parsedMessage.payload.operationName,
                  context: is_object_1.default(initResult) ? Object.assign(Object.create(Object.getPrototypeOf(initResult)), initResult) : {},
                  formatResponse: void 0,
                  formatError: void 0,
                  callback: void 0,
                  schema: _this.schema
                };
                var promisedParams = Promise.resolve(baseParams);
                connectionContext.operations[opId] = empty_iterable_1.createEmptyIterable();
                if (_this.onOperation) {
                  var messageForCallback = parsedMessage;
                  promisedParams = Promise.resolve(_this.onOperation(messageForCallback, baseParams, connectionContext.socket));
                }
                return promisedParams.then(function(params) {
                  if (typeof params !== "object") {
                    var error3 = "Invalid params returned from onOperation! return values must be an object!";
                    _this.sendError(connectionContext, opId, { message: error3 });
                    throw new Error(error3);
                  }
                  if (!params.schema) {
                    var error3 = "Missing schema information. The GraphQL schema should be provided either statically in the `SubscriptionServer` constructor or as a property on the object returned from onOperation!";
                    _this.sendError(connectionContext, opId, { message: error3 });
                    throw new Error(error3);
                  }
                  var document2 = typeof baseParams.query !== "string" ? baseParams.query : graphql_1.parse(baseParams.query);
                  var executionPromise;
                  var validationErrors = graphql_1.validate(params.schema, document2, _this.specifiedRules);
                  if (validationErrors.length > 0) {
                    executionPromise = Promise.resolve({ errors: validationErrors });
                  } else {
                    var executor = _this.execute;
                    if (_this.subscribe && is_subscriptions_1.isASubscriptionOperation(document2, params.operationName)) {
                      executor = _this.subscribe;
                    }
                    executionPromise = Promise.resolve(executor(params.schema, document2, _this.rootValue, params.context, params.variables, params.operationName));
                  }
                  return executionPromise.then(function(executionResult) {
                    return {
                      executionIterable: iterall_1.isAsyncIterable(executionResult) ? executionResult : iterall_1.createAsyncIterator([executionResult]),
                      params
                    };
                  });
                }).then(function(_a) {
                  var executionIterable = _a.executionIterable, params = _a.params;
                  iterall_1.forAwaitEach(executionIterable, function(value) {
                    var result = value;
                    if (params.formatResponse) {
                      try {
                        result = params.formatResponse(value, params);
                      } catch (err) {
                        console.error("Error in formatResponse function:", err);
                      }
                    }
                    _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_DATA, result);
                  }).then(function() {
                    _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_COMPLETE, null);
                  }).catch(function(e) {
                    var error3 = e;
                    if (params.formatError) {
                      try {
                        error3 = params.formatError(e, params);
                      } catch (err) {
                        console.error("Error in formatError function: ", err);
                      }
                    }
                    if (Object.keys(error3).length === 0) {
                      error3 = { name: error3.name, message: error3.message };
                    }
                    _this.sendError(connectionContext, opId, error3);
                  });
                  return executionIterable;
                }).then(function(subscription) {
                  connectionContext.operations[opId] = subscription;
                }).then(function() {
                  _this.sendMessage(connectionContext, opId, message_types_1.default.SUBSCRIPTION_SUCCESS, void 0);
                }).catch(function(e) {
                  if (e.errors) {
                    _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_DATA, { errors: e.errors });
                  } else {
                    _this.sendError(connectionContext, opId, { message: e.message });
                  }
                  _this.unsubscribe(connectionContext, opId);
                  return;
                });
              }).catch(function(error3) {
                _this.sendError(connectionContext, opId, { message: error3.message });
                _this.unsubscribe(connectionContext, opId);
              });
              break;
            case message_types_1.default.GQL_STOP:
              _this.unsubscribe(connectionContext, opId);
              break;
            default:
              _this.sendError(connectionContext, opId, { message: "Invalid message type!" });
          }
        };
      };
      SubscriptionServer2.prototype.sendKeepAlive = function(connectionContext) {
        if (connectionContext.isLegacy) {
          this.sendMessage(connectionContext, void 0, message_types_1.default.KEEP_ALIVE, void 0);
        } else {
          this.sendMessage(connectionContext, void 0, message_types_1.default.GQL_CONNECTION_KEEP_ALIVE, void 0);
        }
      };
      SubscriptionServer2.prototype.sendMessage = function(connectionContext, opId, type, payload) {
        var parsedMessage = parse_legacy_protocol_1.parseLegacyProtocolMessage(connectionContext, {
          type,
          id: opId,
          payload
        });
        if (parsedMessage && connectionContext.socket.readyState === WebSocket.OPEN) {
          connectionContext.socket.send(JSON.stringify(parsedMessage));
        }
      };
      SubscriptionServer2.prototype.sendError = function(connectionContext, opId, errorPayload, overrideDefaultErrorType) {
        var sanitizedOverrideDefaultErrorType = overrideDefaultErrorType || message_types_1.default.GQL_ERROR;
        if ([
          message_types_1.default.GQL_CONNECTION_ERROR,
          message_types_1.default.GQL_ERROR
        ].indexOf(sanitizedOverrideDefaultErrorType) === -1) {
          throw new Error("overrideDefaultErrorType should be one of the allowed error messages GQL_CONNECTION_ERROR or GQL_ERROR");
        }
        this.sendMessage(connectionContext, opId, sanitizedOverrideDefaultErrorType, errorPayload);
      };
      return SubscriptionServer2;
    }();
    exports.SubscriptionServer = SubscriptionServer;
  }
});

// node_modules/subscriptions-transport-ws/dist/index.js
var require_dist = __commonJS({
  "node_modules/subscriptions-transport-ws/dist/index.js"(exports) {
    init_shims();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_client(), exports);
    __exportStar(require_server(), exports);
    var message_types_1 = require_message_types();
    Object.defineProperty(exports, "MessageTypes", { enumerable: true, get: function() {
      return message_types_1.default;
    } });
    __exportStar(require_protocol(), exports);
  }
});

// node_modules/@apollo/client/link/ws/ws.cjs.js
var require_ws_cjs = __commonJS({
  "node_modules/@apollo/client/link/ws/ws.cjs.js"(exports) {
    init_shims();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib = require_tslib();
    var subscriptionsTransportWs = require_dist();
    var core = require_core_cjs();
    var WebSocketLink2 = function(_super) {
      tslib.__extends(WebSocketLink3, _super);
      function WebSocketLink3(paramsOrClient) {
        var _this = _super.call(this) || this;
        if (paramsOrClient instanceof subscriptionsTransportWs.SubscriptionClient) {
          _this.subscriptionClient = paramsOrClient;
        } else {
          _this.subscriptionClient = new subscriptionsTransportWs.SubscriptionClient(paramsOrClient.uri, paramsOrClient.options, paramsOrClient.webSocketImpl);
        }
        return _this;
      }
      WebSocketLink3.prototype.request = function(operation) {
        return this.subscriptionClient.request(operation);
      };
      return WebSocketLink3;
    }(core.ApolloLink);
    exports.WebSocketLink = WebSocketLink2;
  }
});

// node_modules/websocket/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/websocket/node_modules/ms/index.js"(exports, module2) {
    init_shims();
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d2 = h * 24;
    var y = d2 * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d2, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s2, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/websocket/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/websocket/node_modules/debug/src/debug.js"(exports, module2) {
    init_shims();
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports.colors[Math.abs(hash2) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index2++;
          var formatter = exports.formatters[format2];
          if (typeof formatter === "function") {
            var val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split2.length;
      for (var i = 0; i < len; i++) {
        if (!split2[i])
          continue;
        namespaces = split2[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/websocket/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/websocket/node_modules/debug/src/browser.js"(exports, module2) {
    init_shims();
    exports = module2.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/websocket/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/websocket/node_modules/debug/src/node.js"(exports, module2) {
    init_shims();
    var tty = require("tty");
    var util = require("util");
    exports = module2.exports = require_debug();
    exports.init = init2;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init2(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    exports.enable(load2());
  }
});

// node_modules/websocket/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/websocket/node_modules/debug/src/index.js"(exports, module2) {
    init_shims();
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/websocket/lib/utils.js
var require_utils = __commonJS({
  "node_modules/websocket/lib/utils.js"(exports) {
    init_shims();
    var noop3 = exports.noop = function() {
    };
    exports.extend = function extend(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    };
    exports.eventEmitterListenerCount = require("events").EventEmitter.listenerCount || function(emitter, type) {
      return emitter.listeners(type).length;
    };
    exports.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {
      return new Buffer(size);
    };
    exports.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {
      return new Buffer(string, encoding);
    };
    exports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {
      var logFunction = require_src()(identifier);
      if (logFunction.enabled) {
        var logger = new BufferingLogger(identifier, uniqueID, logFunction);
        var debug = logger.log.bind(logger);
        debug.printOutput = logger.printOutput.bind(logger);
        debug.enabled = logFunction.enabled;
        return debug;
      }
      logFunction.printOutput = noop3;
      return logFunction;
    };
    function BufferingLogger(identifier, uniqueID, logFunction) {
      this.logFunction = logFunction;
      this.identifier = identifier;
      this.uniqueID = uniqueID;
      this.buffer = [];
    }
    BufferingLogger.prototype.log = function() {
      this.buffer.push([new Date(), Array.prototype.slice.call(arguments)]);
      return this;
    };
    BufferingLogger.prototype.clear = function() {
      this.buffer = [];
      return this;
    };
    BufferingLogger.prototype.printOutput = function(logFunction) {
      if (!logFunction) {
        logFunction = this.logFunction;
      }
      var uniqueID = this.uniqueID;
      this.buffer.forEach(function(entry) {
        var date = entry[0].toLocaleString();
        var args = entry[1].slice();
        var formatString = args[0];
        if (formatString !== void 0 && formatString !== null) {
          formatString = "%s - %s - " + formatString.toString();
          args.splice(0, 1, formatString, date, uniqueID);
          logFunction.apply(global, args);
        }
      });
    };
  }
});

// node_modules/websocket/lib/WebSocketFrame.js
var require_WebSocketFrame = __commonJS({
  "node_modules/websocket/lib/WebSocketFrame.js"(exports, module2) {
    init_shims();
    var bufferUtil = require_bufferutil();
    var bufferAllocUnsafe = require_utils().bufferAllocUnsafe;
    var DECODE_HEADER = 1;
    var WAITING_FOR_16_BIT_LENGTH = 2;
    var WAITING_FOR_64_BIT_LENGTH = 3;
    var WAITING_FOR_MASK_KEY = 4;
    var WAITING_FOR_PAYLOAD = 5;
    var COMPLETE = 6;
    function WebSocketFrame(maskBytes, frameHeader, config) {
      this.maskBytes = maskBytes;
      this.frameHeader = frameHeader;
      this.config = config;
      this.maxReceivedFrameSize = config.maxReceivedFrameSize;
      this.protocolError = false;
      this.frameTooLarge = false;
      this.invalidCloseFrameLength = false;
      this.parseState = DECODE_HEADER;
      this.closeStatus = -1;
    }
    WebSocketFrame.prototype.addData = function(bufferList) {
      if (this.parseState === DECODE_HEADER) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 0, 0, 2);
          bufferList.advance(2);
          var firstByte = this.frameHeader[0];
          var secondByte = this.frameHeader[1];
          this.fin = Boolean(firstByte & 128);
          this.rsv1 = Boolean(firstByte & 64);
          this.rsv2 = Boolean(firstByte & 32);
          this.rsv3 = Boolean(firstByte & 16);
          this.mask = Boolean(secondByte & 128);
          this.opcode = firstByte & 15;
          this.length = secondByte & 127;
          if (this.opcode >= 8) {
            if (this.length > 125) {
              this.protocolError = true;
              this.dropReason = "Illegal control frame longer than 125 bytes.";
              return true;
            }
            if (!this.fin) {
              this.protocolError = true;
              this.dropReason = "Control frames must not be fragmented.";
              return true;
            }
          }
          if (this.length === 126) {
            this.parseState = WAITING_FOR_16_BIT_LENGTH;
          } else if (this.length === 127) {
            this.parseState = WAITING_FOR_64_BIT_LENGTH;
          } else {
            this.parseState = WAITING_FOR_MASK_KEY;
          }
        }
      }
      if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {
        if (bufferList.length >= 2) {
          bufferList.joinInto(this.frameHeader, 2, 0, 2);
          bufferList.advance(2);
          this.length = this.frameHeader.readUInt16BE(2);
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {
        if (bufferList.length >= 8) {
          bufferList.joinInto(this.frameHeader, 2, 0, 8);
          bufferList.advance(8);
          var lengthPair = [
            this.frameHeader.readUInt32BE(2),
            this.frameHeader.readUInt32BE(2 + 4)
          ];
          if (lengthPair[0] !== 0) {
            this.protocolError = true;
            this.dropReason = "Unsupported 64-bit length frame received";
            return true;
          }
          this.length = lengthPair[1];
          this.parseState = WAITING_FOR_MASK_KEY;
        }
      }
      if (this.parseState === WAITING_FOR_MASK_KEY) {
        if (this.mask) {
          if (bufferList.length >= 4) {
            bufferList.joinInto(this.maskBytes, 0, 0, 4);
            bufferList.advance(4);
            this.parseState = WAITING_FOR_PAYLOAD;
          }
        } else {
          this.parseState = WAITING_FOR_PAYLOAD;
        }
      }
      if (this.parseState === WAITING_FOR_PAYLOAD) {
        if (this.length > this.maxReceivedFrameSize) {
          this.frameTooLarge = true;
          this.dropReason = "Frame size of " + this.length.toString(10) + " bytes exceeds maximum accepted frame size";
          return true;
        }
        if (this.length === 0) {
          this.binaryPayload = bufferAllocUnsafe(0);
          this.parseState = COMPLETE;
          return true;
        }
        if (bufferList.length >= this.length) {
          this.binaryPayload = bufferList.take(this.length);
          bufferList.advance(this.length);
          if (this.mask) {
            bufferUtil.unmask(this.binaryPayload, this.maskBytes);
          }
          if (this.opcode === 8) {
            if (this.length === 1) {
              this.binaryPayload = bufferAllocUnsafe(0);
              this.invalidCloseFrameLength = true;
            }
            if (this.length >= 2) {
              this.closeStatus = this.binaryPayload.readUInt16BE(0);
              this.binaryPayload = this.binaryPayload.slice(2);
            }
          }
          this.parseState = COMPLETE;
          return true;
        }
      }
      return false;
    };
    WebSocketFrame.prototype.throwAwayPayload = function(bufferList) {
      if (bufferList.length >= this.length) {
        bufferList.advance(this.length);
        this.parseState = COMPLETE;
        return true;
      }
      return false;
    };
    WebSocketFrame.prototype.toBuffer = function(nullMask) {
      var maskKey;
      var headerLength = 2;
      var data;
      var outputPos;
      var firstByte = 0;
      var secondByte = 0;
      if (this.fin) {
        firstByte |= 128;
      }
      if (this.rsv1) {
        firstByte |= 64;
      }
      if (this.rsv2) {
        firstByte |= 32;
      }
      if (this.rsv3) {
        firstByte |= 16;
      }
      if (this.mask) {
        secondByte |= 128;
      }
      firstByte |= this.opcode & 15;
      if (this.opcode === 8) {
        this.length = 2;
        if (this.binaryPayload) {
          this.length += this.binaryPayload.length;
        }
        data = bufferAllocUnsafe(this.length);
        data.writeUInt16BE(this.closeStatus, 0);
        if (this.length > 2) {
          this.binaryPayload.copy(data, 2);
        }
      } else if (this.binaryPayload) {
        data = this.binaryPayload;
        this.length = data.length;
      } else {
        this.length = 0;
      }
      if (this.length <= 125) {
        secondByte |= this.length & 127;
      } else if (this.length > 125 && this.length <= 65535) {
        secondByte |= 126;
        headerLength += 2;
      } else if (this.length > 65535) {
        secondByte |= 127;
        headerLength += 8;
      }
      var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));
      output[0] = firstByte;
      output[1] = secondByte;
      outputPos = 2;
      if (this.length > 125 && this.length <= 65535) {
        output.writeUInt16BE(this.length, outputPos);
        outputPos += 2;
      } else if (this.length > 65535) {
        output.writeUInt32BE(0, outputPos);
        output.writeUInt32BE(this.length, outputPos + 4);
        outputPos += 8;
      }
      if (this.mask) {
        maskKey = nullMask ? 0 : Math.random() * 4294967295 >>> 0;
        this.maskBytes.writeUInt32BE(maskKey, 0);
        this.maskBytes.copy(output, outputPos);
        outputPos += 4;
        if (data) {
          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);
        }
      } else if (data) {
        data.copy(output, outputPos);
      }
      return output;
    };
    WebSocketFrame.prototype.toString = function() {
      return "Opcode: " + this.opcode + ", fin: " + this.fin + ", length: " + this.length + ", hasPayload: " + Boolean(this.binaryPayload) + ", masked: " + this.mask;
    };
    module2.exports = WebSocketFrame;
  }
});

// node_modules/websocket/vendor/FastBufferList.js
var require_FastBufferList = __commonJS({
  "node_modules/websocket/vendor/FastBufferList.js"(exports, module2) {
    init_shims();
    var Buffer2 = require("buffer").Buffer;
    var EventEmitter = require("events").EventEmitter;
    var bufferAllocUnsafe = require_utils().bufferAllocUnsafe;
    module2.exports = BufferList;
    module2.exports.BufferList = BufferList;
    function BufferList(opts) {
      if (!(this instanceof BufferList))
        return new BufferList(opts);
      EventEmitter.call(this);
      var self2 = this;
      if (typeof opts == "undefined")
        opts = {};
      self2.encoding = opts.encoding;
      var head = { next: null, buffer: null };
      var last = { next: null, buffer: null };
      var length = 0;
      self2.__defineGetter__("length", function() {
        return length;
      });
      var offset = 0;
      self2.write = function(buf) {
        if (!head.buffer) {
          head.buffer = buf;
          last = head;
        } else {
          last.next = { next: null, buffer: buf };
          last = last.next;
        }
        length += buf.length;
        self2.emit("write", buf);
        return true;
      };
      self2.end = function(buf) {
        if (Buffer2.isBuffer(buf))
          self2.write(buf);
      };
      self2.push = function() {
        var args = [].concat.apply([], arguments);
        args.forEach(self2.write);
        return self2;
      };
      self2.forEach = function(fn) {
        if (!head.buffer)
          return bufferAllocUnsafe(0);
        if (head.buffer.length - offset <= 0)
          return self2;
        var firstBuf = head.buffer.slice(offset);
        var b = { buffer: firstBuf, next: head.next };
        while (b && b.buffer) {
          var r = fn(b.buffer);
          if (r)
            break;
          b = b.next;
        }
        return self2;
      };
      self2.join = function(start, end) {
        if (!head.buffer)
          return bufferAllocUnsafe(0);
        if (start == void 0)
          start = 0;
        if (end == void 0)
          end = self2.length;
        var big = bufferAllocUnsafe(end - start);
        var ix = 0;
        self2.forEach(function(buffer) {
          if (start < ix + buffer.length && ix < end) {
            buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));
          }
          ix += buffer.length;
          if (ix > end)
            return true;
        });
        return big;
      };
      self2.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {
        if (!head.buffer)
          return new bufferAllocUnsafe(0);
        if (sourceStart == void 0)
          sourceStart = 0;
        if (sourceEnd == void 0)
          sourceEnd = self2.length;
        var big = targetBuffer;
        if (big.length - targetStart < sourceEnd - sourceStart) {
          throw new Error("Insufficient space available in target Buffer.");
        }
        var ix = 0;
        self2.forEach(function(buffer) {
          if (sourceStart < ix + buffer.length && ix < sourceEnd) {
            buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));
          }
          ix += buffer.length;
          if (ix > sourceEnd)
            return true;
        });
        return big;
      };
      self2.advance = function(n) {
        offset += n;
        length -= n;
        while (head.buffer && offset >= head.buffer.length) {
          offset -= head.buffer.length;
          head = head.next ? head.next : { buffer: null, next: null };
        }
        if (head.buffer === null)
          last = { next: null, buffer: null };
        self2.emit("advance", n);
        return self2;
      };
      self2.take = function(n, encoding) {
        if (n == void 0)
          n = self2.length;
        else if (typeof n !== "number") {
          encoding = n;
          n = self2.length;
        }
        var b = head;
        if (!encoding)
          encoding = self2.encoding;
        if (encoding) {
          var acc = "";
          self2.forEach(function(buffer) {
            if (n <= 0)
              return true;
            acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));
            n -= buffer.length;
          });
          return acc;
        } else {
          return self2.join(0, n);
        }
      };
      self2.toString = function() {
        return self2.take("binary");
      };
    }
    require("util").inherits(BufferList, EventEmitter);
  }
});

// node_modules/websocket/lib/WebSocketConnection.js
var require_WebSocketConnection = __commonJS({
  "node_modules/websocket/lib/WebSocketConnection.js"(exports, module2) {
    init_shims();
    var util = require("util");
    var utils = require_utils();
    var EventEmitter = require("events").EventEmitter;
    var WebSocketFrame = require_WebSocketFrame();
    var BufferList = require_FastBufferList();
    var isValidUTF8 = require_utf_8_validate();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var bufferFromString = utils.bufferFromString;
    var STATE_OPEN = "open";
    var STATE_PEER_REQUESTED_CLOSE = "peer_requested_close";
    var STATE_ENDING = "ending";
    var STATE_CLOSED = "closed";
    var setImmediateImpl = "setImmediate" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);
    var idCounter = 0;
    function WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {
      this._debug = utils.BufferingLogger("websocket:connection", ++idCounter);
      this._debug("constructor");
      if (this._debug.enabled) {
        instrumentSocketForDebugging(this, socket);
      }
      EventEmitter.call(this);
      this._pingListenerCount = 0;
      this.on("newListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount++;
        }
      }).on("removeListener", function(ev) {
        if (ev === "ping") {
          this._pingListenerCount--;
        }
      });
      this.config = config;
      this.socket = socket;
      this.protocol = protocol;
      this.extensions = extensions;
      this.remoteAddress = socket.remoteAddress;
      this.closeReasonCode = -1;
      this.closeDescription = null;
      this.closeEventEmitted = false;
      this.maskOutgoingPackets = maskOutgoingPackets;
      this.maskBytes = bufferAllocUnsafe(4);
      this.frameHeader = bufferAllocUnsafe(10);
      this.bufferList = new BufferList();
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      this.fragmentationSize = 0;
      this.frameQueue = [];
      this.connected = true;
      this.state = STATE_OPEN;
      this.waitingForCloseResponse = false;
      this.receivedEnd = false;
      this.closeTimeout = this.config.closeTimeout;
      this.assembleFragments = this.config.assembleFragments;
      this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;
      this.outputBufferFull = false;
      this.inputPaused = false;
      this.receivedDataHandler = this.processReceivedData.bind(this);
      this._closeTimerHandler = this.handleCloseTimer.bind(this);
      this.socket.setNoDelay(this.config.disableNagleAlgorithm);
      this.socket.setTimeout(0);
      if (this.config.keepalive && !this.config.useNativeKeepalive) {
        if (typeof this.config.keepaliveInterval !== "number") {
          throw new Error("keepaliveInterval must be specified and numeric if keepalive is true.");
        }
        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);
        this.setKeepaliveTimer();
        if (this.config.dropConnectionOnKeepaliveTimeout) {
          if (typeof this.config.keepaliveGracePeriod !== "number") {
            throw new Error("keepaliveGracePeriod  must be specified and numeric if dropConnectionOnKeepaliveTimeout is true.");
          }
          this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);
        }
      } else if (this.config.keepalive && this.config.useNativeKeepalive) {
        if (!("setKeepAlive" in this.socket)) {
          throw new Error("Unable to use native keepalive: unsupported by this version of Node.");
        }
        this.socket.setKeepAlive(true, this.config.keepaliveInterval);
      }
      this.socket.removeAllListeners("error");
    }
    WebSocketConnection.CLOSE_REASON_NORMAL = 1e3;
    WebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;
    WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;
    WebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;
    WebSocketConnection.CLOSE_REASON_RESERVED = 1004;
    WebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005;
    WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006;
    WebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;
    WebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;
    WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;
    WebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;
    WebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;
    WebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015;
    WebSocketConnection.CLOSE_DESCRIPTIONS = {
      1e3: "Normal connection closure",
      1001: "Remote peer is going away",
      1002: "Protocol error",
      1003: "Unprocessable input",
      1004: "Reserved",
      1005: "Reason not provided",
      1006: "Abnormal closure, no further detail available",
      1007: "Invalid data received",
      1008: "Policy violation",
      1009: "Message too big",
      1010: "Extension requested by client is required",
      1011: "Internal Server Error",
      1015: "TLS Handshake Failed"
    };
    function validateCloseReason(code) {
      if (code < 1e3) {
        return false;
      }
      if (code >= 1e3 && code <= 2999) {
        return [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;
      }
      if (code >= 3e3 && code <= 3999) {
        return true;
      }
      if (code >= 4e3 && code <= 4999) {
        return true;
      }
      if (code >= 5e3) {
        return false;
      }
    }
    util.inherits(WebSocketConnection, EventEmitter);
    WebSocketConnection.prototype._addSocketEventListeners = function() {
      this.socket.on("error", this.handleSocketError.bind(this));
      this.socket.on("end", this.handleSocketEnd.bind(this));
      this.socket.on("close", this.handleSocketClose.bind(this));
      this.socket.on("drain", this.handleSocketDrain.bind(this));
      this.socket.on("pause", this.handleSocketPause.bind(this));
      this.socket.on("resume", this.handleSocketResume.bind(this));
      this.socket.on("data", this.handleSocketData.bind(this));
    };
    WebSocketConnection.prototype.setKeepaliveTimer = function() {
      this._debug("setKeepaliveTimer");
      if (!this.config.keepalive || this.config.useNativeKeepalive) {
        return;
      }
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);
    };
    WebSocketConnection.prototype.clearKeepaliveTimer = function() {
      if (this._keepaliveTimeoutID) {
        clearTimeout(this._keepaliveTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleKeepaliveTimer = function() {
      this._debug("handleKeepaliveTimer");
      this._keepaliveTimeoutID = null;
      this.ping();
      if (this.config.dropConnectionOnKeepaliveTimeout) {
        this.setGracePeriodTimer();
      } else {
        this.setKeepaliveTimer();
      }
    };
    WebSocketConnection.prototype.setGracePeriodTimer = function() {
      this._debug("setGracePeriodTimer");
      this.clearGracePeriodTimer();
      this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);
    };
    WebSocketConnection.prototype.clearGracePeriodTimer = function() {
      if (this._gracePeriodTimeoutID) {
        clearTimeout(this._gracePeriodTimeoutID);
      }
    };
    WebSocketConnection.prototype.handleGracePeriodTimer = function() {
      this._debug("handleGracePeriodTimer");
      this._gracePeriodTimeoutID = null;
      this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, "Peer not responding.", true);
    };
    WebSocketConnection.prototype.handleSocketData = function(data) {
      this._debug("handleSocketData");
      this.setKeepaliveTimer();
      this.bufferList.write(data);
      this.processReceivedData();
    };
    WebSocketConnection.prototype.processReceivedData = function() {
      this._debug("processReceivedData");
      if (!this.connected) {
        return;
      }
      if (this.inputPaused) {
        return;
      }
      var frame = this.currentFrame;
      if (!frame.addData(this.bufferList)) {
        this._debug("-- insufficient data for frame");
        return;
      }
      var self2 = this;
      if (frame.protocolError) {
        this._debug("-- protocol error");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);
        });
        return;
      } else if (frame.frameTooLarge) {
        this._debug("-- frame too large");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);
        });
        return;
      }
      if (frame.rsv1 || frame.rsv2 || frame.rsv3) {
        this._debug("-- illegal rsv flag");
        process.nextTick(function() {
          self2.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unsupported usage of rsv bits without negotiated extension.");
        });
        return;
      }
      if (!this.assembleFragments) {
        this._debug("-- emitting frame");
        process.nextTick(function() {
          self2.emit("frame", frame);
        });
      }
      process.nextTick(function() {
        self2.processFrame(frame);
      });
      this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      if (this.bufferList.length > 0) {
        setImmediateImpl(this.receivedDataHandler);
      }
    };
    WebSocketConnection.prototype.handleSocketError = function(error3) {
      this._debug("handleSocketError: %j", error3);
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'error' after 'close'");
        return;
      }
      this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
      this.closeDescription = "Socket Error: " + error3.syscall + " " + error3.code;
      this.connected = false;
      this.state = STATE_CLOSED;
      this.fragmentationSize = 0;
      if (utils.eventEmitterListenerCount(this, "error") > 0) {
        this.emit("error", error3);
      }
      this.socket.destroy();
      this._debug.printOutput();
    };
    WebSocketConnection.prototype.handleSocketEnd = function() {
      this._debug("handleSocketEnd: received socket end.  state = %s", this.state);
      this.receivedEnd = true;
      if (this.state === STATE_CLOSED) {
        this._debug("  --- Socket 'end' after 'close'");
        return;
      }
      if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {
        this._debug("  --- UNEXPECTED socket end.");
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.handleSocketClose = function(hadError) {
      this._debug("handleSocketClose: received socket close");
      this.socketHadError = hadError;
      this.connected = false;
      this.state = STATE_CLOSED;
      if (this.closeReasonCode === -1) {
        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;
        this.closeDescription = "Connection dropped by remote peer.";
      }
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("-- Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
    };
    WebSocketConnection.prototype.handleSocketDrain = function() {
      this._debug("handleSocketDrain: socket drain event");
      this.outputBufferFull = false;
      this.emit("drain");
    };
    WebSocketConnection.prototype.handleSocketPause = function() {
      this._debug("handleSocketPause: socket pause event");
      this.inputPaused = true;
      this.emit("pause");
    };
    WebSocketConnection.prototype.handleSocketResume = function() {
      this._debug("handleSocketResume: socket resume event");
      this.inputPaused = false;
      this.emit("resume");
      this.processReceivedData();
    };
    WebSocketConnection.prototype.pause = function() {
      this._debug("pause: pause requested");
      this.socket.pause();
    };
    WebSocketConnection.prototype.resume = function() {
      this._debug("resume: resume requested");
      this.socket.resume();
    };
    WebSocketConnection.prototype.close = function(reasonCode, description) {
      if (this.connected) {
        this._debug("close: Initating clean WebSocket close sequence.");
        if (typeof reasonCode !== "number") {
          reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
        }
        if (!validateCloseReason(reasonCode)) {
          throw new Error("Close code " + reasonCode + " is not valid.");
        }
        if (typeof description !== "string") {
          description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
        }
        this.closeReasonCode = reasonCode;
        this.closeDescription = description;
        this.setCloseTimer();
        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);
        this.state = STATE_ENDING;
        this.connected = false;
      }
    };
    WebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {
      this._debug("drop");
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
      }
      if (typeof description !== "string") {
        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];
      }
      this._debug("Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s", skipCloseFrame, reasonCode, description);
      this.closeReasonCode = reasonCode;
      this.closeDescription = description;
      this.frameQueue = [];
      this.fragmentationSize = 0;
      if (!skipCloseFrame) {
        this.sendCloseFrame(reasonCode, description);
      }
      this.connected = false;
      this.state = STATE_CLOSED;
      this.clearCloseTimer();
      this.clearKeepaliveTimer();
      this.clearGracePeriodTimer();
      if (!this.closeEventEmitted) {
        this.closeEventEmitted = true;
        this._debug("Emitting WebSocketConnection close event");
        this.emit("close", this.closeReasonCode, this.closeDescription);
      }
      this._debug("Drop: destroying socket");
      this.socket.destroy();
    };
    WebSocketConnection.prototype.setCloseTimer = function() {
      this._debug("setCloseTimer");
      this.clearCloseTimer();
      this._debug("Setting close timer");
      this.waitingForCloseResponse = true;
      this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);
    };
    WebSocketConnection.prototype.clearCloseTimer = function() {
      this._debug("clearCloseTimer");
      if (this.closeTimer) {
        this._debug("Clearing close timer");
        clearTimeout(this.closeTimer);
        this.waitingForCloseResponse = false;
        this.closeTimer = null;
      }
    };
    WebSocketConnection.prototype.handleCloseTimer = function() {
      this._debug("handleCloseTimer");
      this.closeTimer = null;
      if (this.waitingForCloseResponse) {
        this._debug("Close response not received from client.  Forcing socket end.");
        this.waitingForCloseResponse = false;
        this.state = STATE_CLOSED;
        this.socket.end();
      }
    };
    WebSocketConnection.prototype.processFrame = function(frame) {
      this._debug("processFrame");
      this._debug(" -- frame: %s", frame);
      if (this.frameQueue.length !== 0 && (frame.opcode > 0 && frame.opcode < 8)) {
        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Illegal frame opcode 0x" + frame.opcode.toString(16) + " received in middle of fragmented message.");
        return;
      }
      switch (frame.opcode) {
        case 2:
          this._debug("-- Binary Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "binary",
                binaryData: frame.binaryPayload
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 1:
          this._debug("-- Text Frame");
          if (this.assembleFragments) {
            if (frame.fin) {
              if (!isValidUTF8(frame.binaryPayload)) {
                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, "Invalid UTF-8 Data Received");
                return;
              }
              this._debug("---- Emitting 'message' event");
              this.emit("message", {
                type: "utf8",
                utf8Data: frame.binaryPayload.toString("utf8")
              });
            } else {
              this.frameQueue.push(frame);
              this.fragmentationSize = frame.length;
            }
          }
          break;
        case 0:
          this._debug("-- Continuation Frame");
          if (this.assembleFragments) {
            if (this.frameQueue.length === 0) {
              this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unexpected Continuation Frame");
              return;
            }
            this.fragmentationSize += frame.length;
            if (this.fragmentationSize > this.maxReceivedMessageSize) {
              this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, "Maximum message size exceeded.");
              return;
            }
            this.frameQueue.push(frame);
            if (frame.fin) {
              var bytesCopied = 0;
              var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);
              var opcode = this.frameQueue[0].opcode;
              this.frameQueue.forEach(function(currentFrame) {
                currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);
                bytesCopied += currentFrame.binaryPayload.length;
              });
              this.frameQueue = [];
              this.fragmentationSize = 0;
              switch (opcode) {
                case 2:
                  this.emit("message", {
                    type: "binary",
                    binaryData: binaryPayload
                  });
                  break;
                case 1:
                  if (!isValidUTF8(binaryPayload)) {
                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, "Invalid UTF-8 Data Received");
                    return;
                  }
                  this.emit("message", {
                    type: "utf8",
                    utf8Data: binaryPayload.toString("utf8")
                  });
                  break;
                default:
                  this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unexpected first opcode in fragmentation sequence: 0x" + opcode.toString(16));
                  return;
              }
            }
          }
          break;
        case 9:
          this._debug("-- Ping Frame");
          if (this._pingListenerCount > 0) {
            var cancelled = false;
            var cancel = function() {
              cancelled = true;
            };
            this.emit("ping", cancel, frame.binaryPayload);
            if (!cancelled) {
              this.pong(frame.binaryPayload);
            }
          } else {
            this.pong(frame.binaryPayload);
          }
          break;
        case 10:
          this._debug("-- Pong Frame");
          this.emit("pong", frame.binaryPayload);
          break;
        case 8:
          this._debug("-- Close Frame");
          if (this.waitingForCloseResponse) {
            this._debug("---- Got close response from peer.  Completing closing handshake.");
            this.clearCloseTimer();
            this.waitingForCloseResponse = false;
            this.state = STATE_CLOSED;
            this.socket.end();
            return;
          }
          this._debug("---- Closing handshake initiated by peer.");
          this.state = STATE_PEER_REQUESTED_CLOSE;
          var respondCloseReasonCode;
          if (frame.invalidCloseFrameLength) {
            this.closeReasonCode = 1005;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
          } else {
            this.closeReasonCode = frame.closeStatus;
            respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;
          }
          if (frame.binaryPayload.length > 1) {
            if (!isValidUTF8(frame.binaryPayload)) {
              this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, "Invalid UTF-8 Data Received");
              return;
            }
            this.closeDescription = frame.binaryPayload.toString("utf8");
          } else {
            this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];
          }
          this._debug("------ Remote peer %s - code: %d - %s - close frame payload length: %d", this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);
          this._debug("------ responding to remote peer's close request.");
          this.sendCloseFrame(respondCloseReasonCode, null);
          this.connected = false;
          break;
        default:
          this._debug("-- Unrecognized Opcode %d", frame.opcode);
          this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, "Unrecognized Opcode: 0x" + frame.opcode.toString(16));
          break;
      }
    };
    WebSocketConnection.prototype.send = function(data, cb) {
      this._debug("send");
      if (Buffer.isBuffer(data)) {
        this.sendBytes(data, cb);
      } else if (typeof data["toString"] === "function") {
        this.sendUTF(data, cb);
      } else {
        throw new Error("Data provided must either be a Node Buffer or implement toString()");
      }
    };
    WebSocketConnection.prototype.sendUTF = function(data, cb) {
      data = bufferFromString(data.toString(), "utf8");
      this._debug("sendUTF: %d bytes", data.length);
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 1;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.sendBytes = function(data, cb) {
      this._debug("sendBytes");
      if (!Buffer.isBuffer(data)) {
        throw new Error("You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()");
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 2;
      frame.binaryPayload = data;
      this.fragmentAndSend(frame, cb);
    };
    WebSocketConnection.prototype.ping = function(data) {
      this._debug("ping");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 9;
      frame.fin = true;
      if (data) {
        if (!Buffer.isBuffer(data)) {
          data = bufferFromString(data.toString(), "utf8");
        }
        if (data.length > 125) {
          this._debug("WebSocket: Data for ping is longer than 125 bytes.  Truncating.");
          data = data.slice(0, 124);
        }
        frame.binaryPayload = data;
      }
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.pong = function(binaryPayload) {
      this._debug("pong");
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.opcode = 10;
      if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {
        this._debug("WebSocket: Data for pong is longer than 125 bytes.  Truncating.");
        binaryPayload = binaryPayload.slice(0, 124);
      }
      frame.binaryPayload = binaryPayload;
      frame.fin = true;
      this.sendFrame(frame);
    };
    WebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {
      this._debug("fragmentAndSend");
      if (frame.opcode > 7) {
        throw new Error("You cannot fragment control frames.");
      }
      var threshold = this.config.fragmentationThreshold;
      var length = frame.binaryPayload.length;
      if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {
        frame.fin = true;
        this.sendFrame(frame, cb);
        return;
      }
      var numFragments = Math.ceil(length / threshold);
      var sentFragments = 0;
      var sentCallback = function fragmentSentCallback(err) {
        if (err) {
          if (typeof cb === "function") {
            cb(err);
            cb = null;
          }
          return;
        }
        ++sentFragments;
        if (sentFragments === numFragments && typeof cb === "function") {
          cb();
        }
      };
      for (var i = 1; i <= numFragments; i++) {
        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
        currentFrame.opcode = i === 1 ? frame.opcode : 0;
        currentFrame.fin = i === numFragments;
        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;
        var sliceStart = threshold * (i - 1);
        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);
        this.sendFrame(currentFrame, sentCallback);
      }
    };
    WebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {
      if (typeof reasonCode !== "number") {
        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;
      }
      this._debug("sendCloseFrame state: %s, reasonCode: %d, description: %s", this.state, reasonCode, description);
      if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {
        return;
      }
      var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);
      frame.fin = true;
      frame.opcode = 8;
      frame.closeStatus = reasonCode;
      if (typeof description === "string") {
        frame.binaryPayload = bufferFromString(description, "utf8");
      }
      this.sendFrame(frame, cb);
      this.socket.end();
    };
    WebSocketConnection.prototype.sendFrame = function(frame, cb) {
      this._debug("sendFrame");
      frame.mask = this.maskOutgoingPackets;
      var flushed = this.socket.write(frame.toBuffer(), cb);
      this.outputBufferFull = !flushed;
      return flushed;
    };
    module2.exports = WebSocketConnection;
    function instrumentSocketForDebugging(connection, socket) {
      if (!connection._debug.enabled) {
        return;
      }
      var originalSocketEmit = socket.emit;
      socket.emit = function(event) {
        connection._debug("||| Socket Event  '%s'", event);
        originalSocketEmit.apply(this, arguments);
      };
      for (var key in socket) {
        if (typeof socket[key] !== "function") {
          continue;
        }
        if (["emit"].indexOf(key) !== -1) {
          continue;
        }
        (function(key2) {
          var original = socket[key2];
          if (key2 === "on") {
            socket[key2] = function proxyMethod__EventEmitter__On() {
              connection._debug("||| Socket method called:  %s (%s)", key2, arguments[0]);
              return original.apply(this, arguments);
            };
            return;
          }
          socket[key2] = function proxyMethod() {
            connection._debug("||| Socket method called:  %s", key2);
            return original.apply(this, arguments);
          };
        })(key);
      }
    }
  }
});

// node_modules/websocket/lib/WebSocketRequest.js
var require_WebSocketRequest = __commonJS({
  "node_modules/websocket/lib/WebSocketRequest.js"(exports, module2) {
    init_shims();
    var crypto = require("crypto");
    var util = require("util");
    var url = require("url");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketConnection = require_WebSocketConnection();
    var headerValueSplitRegExp = /,\s*/;
    var headerParamSplitRegExp = /;\s*/;
    var headerSanitizeRegExp = /[\r\n]/g;
    var xForwardedForSeparatorRegExp = /,\s*/;
    var separators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var controlChars = [String.fromCharCode(127)];
    for (var i = 0; i < 31; i++) {
      controlChars.push(String.fromCharCode(i));
    }
    var cookieNameValidateRegEx = /([\x00-\x20\x22\x28\x29\x2c\x2f\x3a-\x3f\x40\x5b-\x5e\x7b\x7d\x7f])/;
    var cookieValueValidateRegEx = /[^\x21\x23-\x2b\x2d-\x3a\x3c-\x5b\x5d-\x7e]/;
    var cookieValueDQuoteValidateRegEx = /^"[^"]*"$/;
    var controlCharsAndSemicolonRegEx = /[\x00-\x20\x3b]/g;
    var cookieSeparatorRegEx = /[;,] */;
    var httpStatusDescriptions = {
      100: "Continue",
      101: "Switching Protocols",
      200: "OK",
      201: "Created",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      406: "Not Acceptable",
      407: "Proxy Authorization Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Request Entity Too Long",
      414: "Request-URI Too Long",
      415: "Unsupported Media Type",
      416: "Requested Range Not Satisfiable",
      417: "Expectation Failed",
      426: "Upgrade Required",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported"
    };
    function WebSocketRequest(socket, httpRequest, serverConfig) {
      EventEmitter.call(this);
      this.socket = socket;
      this.httpRequest = httpRequest;
      this.resource = httpRequest.url;
      this.remoteAddress = socket.remoteAddress;
      this.remoteAddresses = [this.remoteAddress];
      this.serverConfig = serverConfig;
      this._socketIsClosing = false;
      this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);
      this.socket.on("end", this._socketCloseHandler);
      this.socket.on("close", this._socketCloseHandler);
      this._resolved = false;
    }
    util.inherits(WebSocketRequest, EventEmitter);
    WebSocketRequest.prototype.readHandshake = function() {
      var self2 = this;
      var request = this.httpRequest;
      this.resourceURL = url.parse(this.resource, true);
      this.host = request.headers["host"];
      if (!this.host) {
        throw new Error("Client must provide a Host header.");
      }
      this.key = request.headers["sec-websocket-key"];
      if (!this.key) {
        throw new Error("Client must provide a value for Sec-WebSocket-Key.");
      }
      this.webSocketVersion = parseInt(request.headers["sec-websocket-version"], 10);
      if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {
        throw new Error("Client must provide a value for Sec-WebSocket-Version.");
      }
      switch (this.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          var e = new Error("Unsupported websocket client version: " + this.webSocketVersion + "Only versions 8 and 13 are supported.");
          e.httpCode = 426;
          e.headers = {
            "Sec-WebSocket-Version": "13"
          };
          throw e;
      }
      if (this.webSocketVersion === 13) {
        this.origin = request.headers["origin"];
      } else if (this.webSocketVersion === 8) {
        this.origin = request.headers["sec-websocket-origin"];
      }
      var protocolString = request.headers["sec-websocket-protocol"];
      this.protocolFullCaseMap = {};
      this.requestedProtocols = [];
      if (protocolString) {
        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);
        requestedProtocolsFullCase.forEach(function(protocol) {
          var lcProtocol = protocol.toLocaleLowerCase();
          self2.requestedProtocols.push(lcProtocol);
          self2.protocolFullCaseMap[lcProtocol] = protocol;
        });
      }
      if (!this.serverConfig.ignoreXForwardedFor && request.headers["x-forwarded-for"]) {
        var immediatePeerIP = this.remoteAddress;
        this.remoteAddresses = request.headers["x-forwarded-for"].split(xForwardedForSeparatorRegExp);
        this.remoteAddresses.push(immediatePeerIP);
        this.remoteAddress = this.remoteAddresses[0];
      }
      if (this.serverConfig.parseExtensions) {
        var extensionsString = request.headers["sec-websocket-extensions"];
        this.requestedExtensions = this.parseExtensions(extensionsString);
      } else {
        this.requestedExtensions = [];
      }
      if (this.serverConfig.parseCookies) {
        var cookieString = request.headers["cookie"];
        this.cookies = this.parseCookies(cookieString);
      } else {
        this.cookies = [];
      }
    };
    WebSocketRequest.prototype.parseExtensions = function(extensionsString) {
      if (!extensionsString || extensionsString.length === 0) {
        return [];
      }
      var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);
      extensions.forEach(function(extension, index2, array) {
        var params = extension.split(headerParamSplitRegExp);
        var extensionName = params[0];
        var extensionParams = params.slice(1);
        extensionParams.forEach(function(rawParam, index3, array2) {
          var arr = rawParam.split("=");
          var obj2 = {
            name: arr[0],
            value: arr[1]
          };
          array2.splice(index3, 1, obj2);
        });
        var obj = {
          name: extensionName,
          params: extensionParams
        };
        array.splice(index2, 1, obj);
      });
      return extensions;
    };
    WebSocketRequest.prototype.parseCookies = function(str) {
      if (!str || typeof str !== "string") {
        return [];
      }
      var cookies = [];
      var pairs = str.split(cookieSeparatorRegEx);
      pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf("=");
        if (eq_idx === -1) {
          cookies.push({
            name: pair,
            value: null
          });
          return;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if (val[0] === '"') {
          val = val.slice(1, -1);
        }
        cookies.push({
          name: key,
          value: decodeURIComponent(val)
        });
      });
      return cookies;
    };
    WebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {
      this._verifyResolution();
      var protocolFullCase;
      if (acceptedProtocol) {
        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];
        if (typeof protocolFullCase === "undefined") {
          protocolFullCase = acceptedProtocol;
        }
      } else {
        protocolFullCase = acceptedProtocol;
      }
      this.protocolFullCaseMap = null;
      var sha1 = crypto.createHash("sha1");
      sha1.update(this.key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var acceptKey = sha1.digest("base64");
      var response = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: " + acceptKey + "\r\n";
      if (protocolFullCase) {
        for (var i2 = 0; i2 < protocolFullCase.length; i2++) {
          var charCode = protocolFullCase.charCodeAt(i2);
          var character = protocolFullCase.charAt(i2);
          if (charCode < 33 || charCode > 126 || separators.indexOf(character) !== -1) {
            this.reject(500);
            throw new Error('Illegal character "' + String.fromCharCode(character) + '" in subprotocol.');
          }
        }
        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {
          this.reject(500);
          throw new Error("Specified protocol was not requested by the client.");
        }
        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, "");
        response += "Sec-WebSocket-Protocol: " + protocolFullCase + "\r\n";
      }
      this.requestedProtocols = null;
      if (allowedOrigin) {
        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, "");
        if (this.webSocketVersion === 13) {
          response += "Origin: " + allowedOrigin + "\r\n";
        } else if (this.webSocketVersion === 8) {
          response += "Sec-WebSocket-Origin: " + allowedOrigin + "\r\n";
        }
      }
      if (cookies) {
        if (!Array.isArray(cookies)) {
          this.reject(500);
          throw new Error('Value supplied for "cookies" argument must be an array.');
        }
        var seenCookies = {};
        cookies.forEach(function(cookie) {
          if (!cookie.name || !cookie.value) {
            this.reject(500);
            throw new Error('Each cookie to set must at least provide a "name" and "value"');
          }
          cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, "");
          cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, "");
          if (seenCookies[cookie.name]) {
            this.reject(500);
            throw new Error("You may not specify the same cookie name twice.");
          }
          seenCookies[cookie.name] = true;
          var invalidChar = cookie.name.match(cookieNameValidateRegEx);
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie name");
          }
          if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {
            invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);
          } else {
            invalidChar = cookie.value.match(cookieValueValidateRegEx);
          }
          if (invalidChar) {
            this.reject(500);
            throw new Error("Illegal character " + invalidChar[0] + " in cookie value");
          }
          var cookieParts = [cookie.name + "=" + cookie.value];
          if (cookie.path) {
            invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie path");
            }
            cookieParts.push("Path=" + cookie.path);
          }
          if (cookie.domain) {
            if (typeof cookie.domain !== "string") {
              this.reject(500);
              throw new Error("Domain must be specified and must be a string.");
            }
            invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);
            if (invalidChar) {
              this.reject(500);
              throw new Error("Illegal character " + invalidChar[0] + " in cookie domain");
            }
            cookieParts.push("Domain=" + cookie.domain.toLowerCase());
          }
          if (cookie.expires) {
            if (!(cookie.expires instanceof Date)) {
              this.reject(500);
              throw new Error('Value supplied for cookie "expires" must be a vaild date object');
            }
            cookieParts.push("Expires=" + cookie.expires.toGMTString());
          }
          if (cookie.maxage) {
            var maxage = cookie.maxage;
            if (typeof maxage === "string") {
              maxage = parseInt(maxage, 10);
            }
            if (isNaN(maxage) || maxage <= 0) {
              this.reject(500);
              throw new Error('Value supplied for cookie "maxage" must be a non-zero number');
            }
            maxage = Math.round(maxage);
            cookieParts.push("Max-Age=" + maxage.toString(10));
          }
          if (cookie.secure) {
            if (typeof cookie.secure !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "secure" must be of type boolean');
            }
            cookieParts.push("Secure");
          }
          if (cookie.httponly) {
            if (typeof cookie.httponly !== "boolean") {
              this.reject(500);
              throw new Error('Value supplied for cookie "httponly" must be of type boolean');
            }
            cookieParts.push("HttpOnly");
          }
          response += "Set-Cookie: " + cookieParts.join(";") + "\r\n";
        }.bind(this));
      }
      this._resolved = true;
      this.emit("requestResolved", this);
      response += "\r\n";
      var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);
      connection.webSocketVersion = this.webSocketVersion;
      connection.remoteAddress = this.remoteAddress;
      connection.remoteAddresses = this.remoteAddresses;
      var self2 = this;
      if (this._socketIsClosing) {
        cleanupFailedConnection(connection);
      } else {
        this.socket.write(response, "ascii", function(error3) {
          if (error3) {
            cleanupFailedConnection(connection);
            return;
          }
          self2._removeSocketCloseListeners();
          connection._addSocketEventListeners();
        });
      }
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {
      this._verifyResolution();
      this._resolved = true;
      this.emit("requestResolved", this);
      if (typeof status !== "number") {
        status = 403;
      }
      var response = "HTTP/1.1 " + status + " " + httpStatusDescriptions[status] + "\r\nConnection: close\r\n";
      if (reason) {
        reason = reason.replace(headerSanitizeRegExp, "");
        response += "X-WebSocket-Reject-Reason: " + reason + "\r\n";
      }
      if (extraHeaders) {
        for (var key in extraHeaders) {
          var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, "");
          var sanitizedKey = key.replace(headerSanitizeRegExp, "");
          response += sanitizedKey + ": " + sanitizedValue + "\r\n";
        }
      }
      response += "\r\n";
      this.socket.end(response, "ascii");
      this.emit("requestRejected", this);
    };
    WebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {
      this._socketIsClosing = true;
      this._removeSocketCloseListeners();
    };
    WebSocketRequest.prototype._removeSocketCloseListeners = function() {
      this.socket.removeListener("end", this._socketCloseHandler);
      this.socket.removeListener("close", this._socketCloseHandler);
    };
    WebSocketRequest.prototype._verifyResolution = function() {
      if (this._resolved) {
        throw new Error("WebSocketRequest may only be accepted or rejected one time.");
      }
    };
    function cleanupFailedConnection(connection) {
      process.nextTick(function() {
        connection.drop(1006, "TCP connection lost before handshake completed.", true);
      });
    }
    module2.exports = WebSocketRequest;
  }
});

// node_modules/websocket/lib/WebSocketServer.js
var require_WebSocketServer = __commonJS({
  "node_modules/websocket/lib/WebSocketServer.js"(exports, module2) {
    init_shims();
    var extend = require_utils().extend;
    var utils = require_utils();
    var util = require("util");
    var debug = require_src()("websocket:server");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketRequest = require_WebSocketRequest();
    var WebSocketServer = function WebSocketServer2(config) {
      EventEmitter.call(this);
      this._handlers = {
        upgrade: this.handleUpgrade.bind(this),
        requestAccepted: this.handleRequestAccepted.bind(this),
        requestResolved: this.handleRequestResolved.bind(this)
      };
      this.connections = [];
      this.pendingRequests = [];
      if (config) {
        this.mount(config);
      }
    };
    util.inherits(WebSocketServer, EventEmitter);
    WebSocketServer.prototype.mount = function(config) {
      this.config = {
        httpServer: null,
        maxReceivedFrameSize: 65536,
        maxReceivedMessageSize: 1048576,
        fragmentOutgoingMessages: true,
        fragmentationThreshold: 16384,
        keepalive: true,
        keepaliveInterval: 2e4,
        dropConnectionOnKeepaliveTimeout: true,
        keepaliveGracePeriod: 1e4,
        useNativeKeepalive: false,
        assembleFragments: true,
        autoAcceptConnections: false,
        ignoreXForwardedFor: false,
        parseCookies: true,
        parseExtensions: true,
        disableNagleAlgorithm: true,
        closeTimeout: 5e3
      };
      extend(this.config, config);
      if (this.config.httpServer) {
        if (!Array.isArray(this.config.httpServer)) {
          this.config.httpServer = [this.config.httpServer];
        }
        var upgradeHandler = this._handlers.upgrade;
        this.config.httpServer.forEach(function(httpServer) {
          httpServer.on("upgrade", upgradeHandler);
        });
      } else {
        throw new Error("You must specify an httpServer on which to mount the WebSocket server.");
      }
    };
    WebSocketServer.prototype.unmount = function() {
      var upgradeHandler = this._handlers.upgrade;
      this.config.httpServer.forEach(function(httpServer) {
        httpServer.removeListener("upgrade", upgradeHandler);
      });
    };
    WebSocketServer.prototype.closeAllConnections = function() {
      this.connections.forEach(function(connection) {
        connection.close();
      });
      this.pendingRequests.forEach(function(request) {
        process.nextTick(function() {
          request.reject(503);
        });
      });
    };
    WebSocketServer.prototype.broadcast = function(data) {
      if (Buffer.isBuffer(data)) {
        this.broadcastBytes(data);
      } else if (typeof data.toString === "function") {
        this.broadcastUTF(data);
      }
    };
    WebSocketServer.prototype.broadcastUTF = function(utfData) {
      this.connections.forEach(function(connection) {
        connection.sendUTF(utfData);
      });
    };
    WebSocketServer.prototype.broadcastBytes = function(binaryData) {
      this.connections.forEach(function(connection) {
        connection.sendBytes(binaryData);
      });
    };
    WebSocketServer.prototype.shutDown = function() {
      this.unmount();
      this.closeAllConnections();
    };
    WebSocketServer.prototype.handleUpgrade = function(request, socket) {
      var self2 = this;
      var wsRequest = new WebSocketRequest(socket, request, this.config);
      try {
        wsRequest.readHandshake();
      } catch (e) {
        wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);
        debug("Invalid handshake: %s", e.message);
        this.emit("upgradeError", e);
        return;
      }
      this.pendingRequests.push(wsRequest);
      wsRequest.once("requestAccepted", this._handlers.requestAccepted);
      wsRequest.once("requestResolved", this._handlers.requestResolved);
      socket.once("close", function() {
        self2._handlers.requestResolved(wsRequest);
      });
      if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, "request") > 0) {
        this.emit("request", wsRequest);
      } else if (this.config.autoAcceptConnections) {
        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);
      } else {
        wsRequest.reject(404, "No handler is configured to accept the connection.");
      }
    };
    WebSocketServer.prototype.handleRequestAccepted = function(connection) {
      var self2 = this;
      connection.once("close", function(closeReason, description) {
        self2.handleConnectionClose(connection, closeReason, description);
      });
      this.connections.push(connection);
      this.emit("connect", connection);
    };
    WebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {
      var index2 = this.connections.indexOf(connection);
      if (index2 !== -1) {
        this.connections.splice(index2, 1);
      }
      this.emit("close", connection, closeReason, description);
    };
    WebSocketServer.prototype.handleRequestResolved = function(request) {
      var index2 = this.pendingRequests.indexOf(request);
      if (index2 !== -1) {
        this.pendingRequests.splice(index2, 1);
      }
    };
    module2.exports = WebSocketServer;
  }
});

// node_modules/websocket/lib/WebSocketClient.js
var require_WebSocketClient = __commonJS({
  "node_modules/websocket/lib/WebSocketClient.js"(exports, module2) {
    init_shims();
    var utils = require_utils();
    var extend = utils.extend;
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var http2 = require("http");
    var https2 = require("https");
    var url = require("url");
    var crypto = require("crypto");
    var WebSocketConnection = require_WebSocketConnection();
    var bufferAllocUnsafe = utils.bufferAllocUnsafe;
    var protocolSeparators = [
      "(",
      ")",
      "<",
      ">",
      "@",
      ",",
      ";",
      ":",
      "\\",
      '"',
      "/",
      "[",
      "]",
      "?",
      "=",
      "{",
      "}",
      " ",
      String.fromCharCode(9)
    ];
    var excludedTlsOptions = ["hostname", "port", "method", "path", "headers"];
    function WebSocketClient(config) {
      EventEmitter.call(this);
      this.config = {
        maxReceivedFrameSize: 1048576,
        maxReceivedMessageSize: 8388608,
        fragmentOutgoingMessages: true,
        fragmentationThreshold: 16384,
        webSocketVersion: 13,
        assembleFragments: true,
        disableNagleAlgorithm: true,
        closeTimeout: 5e3,
        tlsOptions: {}
      };
      if (config) {
        var tlsOptions;
        if (config.tlsOptions) {
          tlsOptions = config.tlsOptions;
          delete config.tlsOptions;
        } else {
          tlsOptions = {};
        }
        extend(this.config, config);
        extend(this.config.tlsOptions, tlsOptions);
      }
      this._req = null;
      switch (this.config.webSocketVersion) {
        case 8:
        case 13:
          break;
        default:
          throw new Error("Requested webSocketVersion is not supported. Allowed values are 8 and 13.");
      }
    }
    util.inherits(WebSocketClient, EventEmitter);
    WebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {
      var self2 = this;
      if (typeof protocols === "string") {
        if (protocols.length > 0) {
          protocols = [protocols];
        } else {
          protocols = [];
        }
      }
      if (!(protocols instanceof Array)) {
        protocols = [];
      }
      this.protocols = protocols;
      this.origin = origin;
      if (typeof requestUrl === "string") {
        this.url = url.parse(requestUrl);
      } else {
        this.url = requestUrl;
      }
      if (!this.url.protocol) {
        throw new Error("You must specify a full WebSocket URL, including protocol.");
      }
      if (!this.url.host) {
        throw new Error("You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.");
      }
      this.secure = this.url.protocol === "wss:";
      this.protocols.forEach(function(protocol) {
        for (var i2 = 0; i2 < protocol.length; i2++) {
          var charCode = protocol.charCodeAt(i2);
          var character = protocol.charAt(i2);
          if (charCode < 33 || charCode > 126 || protocolSeparators.indexOf(character) !== -1) {
            throw new Error('Protocol list contains invalid character "' + String.fromCharCode(charCode) + '"');
          }
        }
      });
      var defaultPorts = {
        "ws:": "80",
        "wss:": "443"
      };
      if (!this.url.port) {
        this.url.port = defaultPorts[this.url.protocol];
      }
      var nonce = bufferAllocUnsafe(16);
      for (var i = 0; i < 16; i++) {
        nonce[i] = Math.round(Math.random() * 255);
      }
      this.base64nonce = nonce.toString("base64");
      var hostHeaderValue = this.url.hostname;
      if (this.url.protocol === "ws:" && this.url.port !== "80" || this.url.protocol === "wss:" && this.url.port !== "443") {
        hostHeaderValue += ":" + this.url.port;
      }
      var reqHeaders = {};
      if (this.secure && this.config.tlsOptions.hasOwnProperty("headers")) {
        extend(reqHeaders, this.config.tlsOptions.headers);
      }
      if (headers) {
        extend(reqHeaders, headers);
      }
      extend(reqHeaders, {
        "Upgrade": "websocket",
        "Connection": "Upgrade",
        "Sec-WebSocket-Version": this.config.webSocketVersion.toString(10),
        "Sec-WebSocket-Key": this.base64nonce,
        "Host": reqHeaders.Host || hostHeaderValue
      });
      if (this.protocols.length > 0) {
        reqHeaders["Sec-WebSocket-Protocol"] = this.protocols.join(", ");
      }
      if (this.origin) {
        if (this.config.webSocketVersion === 13) {
          reqHeaders["Origin"] = this.origin;
        } else if (this.config.webSocketVersion === 8) {
          reqHeaders["Sec-WebSocket-Origin"] = this.origin;
        }
      }
      var pathAndQuery;
      if (this.url.pathname) {
        pathAndQuery = this.url.path;
      } else if (this.url.path) {
        pathAndQuery = "/" + this.url.path;
      } else {
        pathAndQuery = "/";
      }
      function handleRequestError(error3) {
        self2._req = null;
        self2.emit("connectFailed", error3);
      }
      var requestOptions = {
        agent: false
      };
      if (extraRequestOptions) {
        extend(requestOptions, extraRequestOptions);
      }
      extend(requestOptions, {
        hostname: this.url.hostname,
        port: this.url.port,
        method: "GET",
        path: pathAndQuery,
        headers: reqHeaders
      });
      if (this.secure) {
        var tlsOptions = this.config.tlsOptions;
        for (var key in tlsOptions) {
          if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {
            requestOptions[key] = tlsOptions[key];
          }
        }
      }
      var req = this._req = (this.secure ? https2 : http2).request(requestOptions);
      req.on("upgrade", function handleRequestUpgrade(response, socket, head) {
        self2._req = null;
        req.removeListener("error", handleRequestError);
        self2.socket = socket;
        self2.response = response;
        self2.firstDataChunk = head;
        self2.validateHandshake();
      });
      req.on("error", handleRequestError);
      req.on("response", function(response) {
        self2._req = null;
        if (utils.eventEmitterListenerCount(self2, "httpResponse") > 0) {
          self2.emit("httpResponse", response, self2);
          if (response.socket) {
            response.socket.end();
          }
        } else {
          var headerDumpParts = [];
          for (var headerName in response.headers) {
            headerDumpParts.push(headerName + ": " + response.headers[headerName]);
          }
          self2.failHandshake("Server responded with a non-101 status: " + response.statusCode + " " + response.statusMessage + "\nResponse Headers Follow:\n" + headerDumpParts.join("\n") + "\n");
        }
      });
      req.end();
    };
    WebSocketClient.prototype.validateHandshake = function() {
      var headers = this.response.headers;
      if (this.protocols.length > 0) {
        this.protocol = headers["sec-websocket-protocol"];
        if (this.protocol) {
          if (this.protocols.indexOf(this.protocol) === -1) {
            this.failHandshake("Server did not respond with a requested protocol.");
            return;
          }
        } else {
          this.failHandshake("Expected a Sec-WebSocket-Protocol header.");
          return;
        }
      }
      if (!(headers["connection"] && headers["connection"].toLocaleLowerCase() === "upgrade")) {
        this.failHandshake("Expected a Connection: Upgrade header from the server");
        return;
      }
      if (!(headers["upgrade"] && headers["upgrade"].toLocaleLowerCase() === "websocket")) {
        this.failHandshake("Expected an Upgrade: websocket header from the server");
        return;
      }
      var sha1 = crypto.createHash("sha1");
      sha1.update(this.base64nonce + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
      var expectedKey = sha1.digest("base64");
      if (!headers["sec-websocket-accept"]) {
        this.failHandshake("Expected Sec-WebSocket-Accept header from server");
        return;
      }
      if (headers["sec-websocket-accept"] !== expectedKey) {
        this.failHandshake("Sec-WebSocket-Accept header from server didn't match expected value of " + expectedKey);
        return;
      }
      this.succeedHandshake();
    };
    WebSocketClient.prototype.failHandshake = function(errorDescription) {
      if (this.socket && this.socket.writable) {
        this.socket.end();
      }
      this.emit("connectFailed", new Error(errorDescription));
    };
    WebSocketClient.prototype.succeedHandshake = function() {
      var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);
      connection.webSocketVersion = this.config.webSocketVersion;
      connection._addSocketEventListeners();
      this.emit("connect", connection);
      if (this.firstDataChunk.length > 0) {
        connection.handleSocketData(this.firstDataChunk);
      }
      this.firstDataChunk = null;
    };
    WebSocketClient.prototype.abort = function() {
      if (this._req) {
        this._req.abort();
      }
    };
    module2.exports = WebSocketClient;
  }
});

// node_modules/websocket/lib/WebSocketRouterRequest.js
var require_WebSocketRouterRequest = __commonJS({
  "node_modules/websocket/lib/WebSocketRouterRequest.js"(exports, module2) {
    init_shims();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    function WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {
      EventEmitter.call(this);
      this.webSocketRequest = webSocketRequest;
      if (resolvedProtocol === "____no_protocol____") {
        this.protocol = null;
      } else {
        this.protocol = resolvedProtocol;
      }
      this.origin = webSocketRequest.origin;
      this.resource = webSocketRequest.resource;
      this.resourceURL = webSocketRequest.resourceURL;
      this.httpRequest = webSocketRequest.httpRequest;
      this.remoteAddress = webSocketRequest.remoteAddress;
      this.webSocketVersion = webSocketRequest.webSocketVersion;
      this.requestedExtensions = webSocketRequest.requestedExtensions;
      this.cookies = webSocketRequest.cookies;
    }
    util.inherits(WebSocketRouterRequest, EventEmitter);
    WebSocketRouterRequest.prototype.accept = function(origin, cookies) {
      var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);
      this.emit("requestAccepted", connection);
      return connection;
    };
    WebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {
      this.webSocketRequest.reject(status, reason, extraHeaders);
      this.emit("requestRejected", this);
    };
    module2.exports = WebSocketRouterRequest;
  }
});

// node_modules/websocket/lib/WebSocketRouter.js
var require_WebSocketRouter = __commonJS({
  "node_modules/websocket/lib/WebSocketRouter.js"(exports, module2) {
    init_shims();
    var extend = require_utils().extend;
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var WebSocketRouterRequest = require_WebSocketRouterRequest();
    function WebSocketRouter(config) {
      EventEmitter.call(this);
      this.config = {
        server: null
      };
      if (config) {
        extend(this.config, config);
      }
      this.handlers = [];
      this._requestHandler = this.handleRequest.bind(this);
      if (this.config.server) {
        this.attachServer(this.config.server);
      }
    }
    util.inherits(WebSocketRouter, EventEmitter);
    WebSocketRouter.prototype.attachServer = function(server) {
      if (server) {
        this.server = server;
        this.server.on("request", this._requestHandler);
      } else {
        throw new Error("You must specify a WebSocketServer instance to attach to.");
      }
    };
    WebSocketRouter.prototype.detachServer = function() {
      if (this.server) {
        this.server.removeListener("request", this._requestHandler);
        this.server = null;
      } else {
        throw new Error("Cannot detach from server: not attached.");
      }
    };
    WebSocketRouter.prototype.mount = function(path, protocol, callback) {
      if (!path) {
        throw new Error("You must specify a path for this handler.");
      }
      if (!protocol) {
        protocol = "____no_protocol____";
      }
      if (!callback) {
        throw new Error("You must specify a callback for this handler.");
      }
      path = this.pathToRegExp(path);
      if (!(path instanceof RegExp)) {
        throw new Error("Path must be specified as either a string or a RegExp.");
      }
      var pathString = path.toString();
      protocol = protocol.toLocaleLowerCase();
      if (this.findHandlerIndex(pathString, protocol) !== -1) {
        throw new Error("You may only mount one handler per path/protocol combination.");
      }
      this.handlers.push({
        "path": path,
        "pathString": pathString,
        "protocol": protocol,
        "callback": callback
      });
    };
    WebSocketRouter.prototype.unmount = function(path, protocol) {
      var index2 = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);
      if (index2 !== -1) {
        this.handlers.splice(index2, 1);
      } else {
        throw new Error("Unable to find a route matching the specified path and protocol.");
      }
    };
    WebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {
      protocol = protocol.toLocaleLowerCase();
      for (var i = 0, len = this.handlers.length; i < len; i++) {
        var handler = this.handlers[i];
        if (handler.pathString === pathString && handler.protocol === protocol) {
          return i;
        }
      }
      return -1;
    };
    WebSocketRouter.prototype.pathToRegExp = function(path) {
      if (typeof path === "string") {
        if (path === "*") {
          path = /^.*$/;
        } else {
          path = path.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          path = new RegExp("^" + path + "$");
        }
      }
      return path;
    };
    WebSocketRouter.prototype.handleRequest = function(request) {
      var requestedProtocols = request.requestedProtocols;
      if (requestedProtocols.length === 0) {
        requestedProtocols = ["____no_protocol____"];
      }
      for (var i = 0; i < requestedProtocols.length; i++) {
        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();
        for (var j = 0, len = this.handlers.length; j < len; j++) {
          var handler = this.handlers[j];
          if (handler.path.test(request.resourceURL.pathname)) {
            if (requestedProtocol === handler.protocol || handler.protocol === "*") {
              var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);
              handler.callback(routerRequest);
              return;
            }
          }
        }
      }
      request.reject(404, "No handler is available for the given request.");
    };
    module2.exports = WebSocketRouter;
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module2) {
    init_shims();
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module2) {
    init_shims();
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/yaeti/lib/EventTarget.js
var require_EventTarget = __commonJS({
  "node_modules/yaeti/lib/EventTarget.js"(exports, module2) {
    init_shims();
    module2.exports = _EventTarget;
    function _EventTarget() {
      if (typeof this.addEventListener === "function") {
        return;
      }
      this._listeners = {};
      this.addEventListener = _addEventListener;
      this.removeEventListener = _removeEventListener;
      this.dispatchEvent = _dispatchEvent;
    }
    Object.defineProperties(_EventTarget.prototype, {
      listeners: {
        get: function() {
          return this._listeners;
        }
      }
    });
    function _addEventListener(type, newListener) {
      var listenersType, i, listener;
      if (!type || !newListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        this._listeners[type] = listenersType = [];
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (listener === newListener) {
          return;
        }
      }
      listenersType.push(newListener);
    }
    function _removeEventListener(type, oldListener) {
      var listenersType, i, listener;
      if (!type || !oldListener) {
        return;
      }
      listenersType = this._listeners[type];
      if (listenersType === void 0) {
        return;
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (listener === oldListener) {
          listenersType.splice(i, 1);
          break;
        }
      }
      if (listenersType.length === 0) {
        delete this._listeners[type];
      }
    }
    function _dispatchEvent(event) {
      var type, listenersType, dummyListener, stopImmediatePropagation = false, i, listener;
      if (!event || typeof event.type !== "string") {
        throw new Error("`event` must have a valid `type` property");
      }
      if (event._yaeti) {
        event.target = this;
        event.cancelable = true;
      }
      try {
        event.stopImmediatePropagation = function() {
          stopImmediatePropagation = true;
        };
      } catch (error3) {
      }
      type = event.type;
      listenersType = this._listeners[type] || [];
      dummyListener = this["on" + type];
      if (typeof dummyListener === "function") {
        dummyListener.call(this, event);
      }
      for (i = 0; !!(listener = listenersType[i]); i++) {
        if (stopImmediatePropagation) {
          break;
        }
        listener.call(this, event);
      }
      return !event.defaultPrevented;
    }
  }
});

// node_modules/yaeti/lib/Event.js
var require_Event = __commonJS({
  "node_modules/yaeti/lib/Event.js"(exports, module2) {
    init_shims();
    module2.exports = _Event;
    function _Event(type) {
      this.type = type;
      this.isTrusted = false;
      this._yaeti = true;
    }
  }
});

// node_modules/yaeti/index.js
var require_yaeti = __commonJS({
  "node_modules/yaeti/index.js"(exports, module2) {
    init_shims();
    module2.exports = {
      EventTarget: require_EventTarget(),
      Event: require_Event()
    };
  }
});

// node_modules/websocket/lib/W3CWebSocket.js
var require_W3CWebSocket = __commonJS({
  "node_modules/websocket/lib/W3CWebSocket.js"(exports, module2) {
    init_shims();
    var WebSocketClient = require_WebSocketClient();
    var toBuffer = require_typedarray_to_buffer();
    var yaeti = require_yaeti();
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSING = 2;
    var CLOSED = 3;
    module2.exports = W3CWebSocket;
    function W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {
      yaeti.EventTarget.call(this);
      clientConfig = clientConfig || {};
      clientConfig.assembleFragments = true;
      var self2 = this;
      this._url = url;
      this._readyState = CONNECTING;
      this._protocol = void 0;
      this._extensions = "";
      this._bufferedAmount = 0;
      this._binaryType = "arraybuffer";
      this._connection = void 0;
      this._client = new WebSocketClient(clientConfig);
      this._client.on("connect", function(connection) {
        onConnect.call(self2, connection);
      });
      this._client.on("connectFailed", function() {
        onConnectFailed.call(self2);
      });
      this._client.connect(url, protocols, origin, headers, requestOptions);
    }
    Object.defineProperties(W3CWebSocket.prototype, {
      url: { get: function() {
        return this._url;
      } },
      readyState: { get: function() {
        return this._readyState;
      } },
      protocol: { get: function() {
        return this._protocol;
      } },
      extensions: { get: function() {
        return this._extensions;
      } },
      bufferedAmount: { get: function() {
        return this._bufferedAmount;
      } }
    });
    Object.defineProperties(W3CWebSocket.prototype, {
      binaryType: {
        get: function() {
          return this._binaryType;
        },
        set: function(type) {
          if (type !== "arraybuffer") {
            throw new SyntaxError('just "arraybuffer" type allowed for "binaryType" attribute');
          }
          this._binaryType = type;
        }
      }
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket.prototype, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    [["CONNECTING", CONNECTING], ["OPEN", OPEN], ["CLOSING", CLOSING], ["CLOSED", CLOSED]].forEach(function(property) {
      Object.defineProperty(W3CWebSocket, property[0], {
        get: function() {
          return property[1];
        }
      });
    });
    W3CWebSocket.prototype.send = function(data) {
      if (this._readyState !== OPEN) {
        throw new Error("cannot call send() while not connected");
      }
      if (typeof data === "string" || data instanceof String) {
        this._connection.sendUTF(data);
      } else {
        if (data instanceof Buffer) {
          this._connection.sendBytes(data);
        } else if (data.byteLength || data.byteLength === 0) {
          data = toBuffer(data);
          this._connection.sendBytes(data);
        } else {
          throw new Error("unknown binary data:", data);
        }
      }
    };
    W3CWebSocket.prototype.close = function(code, reason) {
      switch (this._readyState) {
        case CONNECTING:
          onConnectFailed.call(this);
          this._client.on("connect", function(connection) {
            if (code) {
              connection.close(code, reason);
            } else {
              connection.close();
            }
          });
          break;
        case OPEN:
          this._readyState = CLOSING;
          if (code) {
            this._connection.close(code, reason);
          } else {
            this._connection.close();
          }
          break;
        case CLOSING:
        case CLOSED:
          break;
      }
    };
    function createCloseEvent(code, reason) {
      var event = new yaeti.Event("close");
      event.code = code;
      event.reason = reason;
      event.wasClean = typeof code === "undefined" || code === 1e3;
      return event;
    }
    function createMessageEvent(data) {
      var event = new yaeti.Event("message");
      event.data = data;
      return event;
    }
    function onConnect(connection) {
      var self2 = this;
      this._readyState = OPEN;
      this._connection = connection;
      this._protocol = connection.protocol;
      this._extensions = connection.extensions;
      this._connection.on("close", function(code, reason) {
        onClose.call(self2, code, reason);
      });
      this._connection.on("message", function(msg) {
        onMessage.call(self2, msg);
      });
      this.dispatchEvent(new yaeti.Event("open"));
    }
    function onConnectFailed() {
      destroy.call(this);
      this._readyState = CLOSED;
      try {
        this.dispatchEvent(new yaeti.Event("error"));
      } finally {
        this.dispatchEvent(createCloseEvent(1006, "connection failed"));
      }
    }
    function onClose(code, reason) {
      destroy.call(this);
      this._readyState = CLOSED;
      this.dispatchEvent(createCloseEvent(code, reason || ""));
    }
    function onMessage(message) {
      if (message.utf8Data) {
        this.dispatchEvent(createMessageEvent(message.utf8Data));
      } else if (message.binaryData) {
        if (this.binaryType === "arraybuffer") {
          var buffer = message.binaryData;
          var arraybuffer = new ArrayBuffer(buffer.length);
          var view = new Uint8Array(arraybuffer);
          for (var i = 0, len = buffer.length; i < len; ++i) {
            view[i] = buffer[i];
          }
          this.dispatchEvent(createMessageEvent(arraybuffer));
        }
      }
    }
    function destroy() {
      this._client.removeAllListeners();
      if (this._connection) {
        this._connection.removeAllListeners();
      }
    }
  }
});

// node_modules/websocket/lib/Deprecation.js
var require_Deprecation = __commonJS({
  "node_modules/websocket/lib/Deprecation.js"(exports, module2) {
    init_shims();
    var Deprecation = {
      disableWarnings: false,
      deprecationWarningMap: {},
      warn: function(deprecationName) {
        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {
          console.warn("DEPRECATION WARNING: " + this.deprecationWarningMap[deprecationName]);
          this.deprecationWarningMap[deprecationName] = false;
        }
      }
    };
    module2.exports = Deprecation;
  }
});

// node_modules/websocket/package.json
var require_package = __commonJS({
  "node_modules/websocket/package.json"(exports, module2) {
    module2.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "I\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.34",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.50",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version2 = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module2) {
    init_shims();
    module2.exports = require_package().version;
  }
});

// node_modules/websocket/lib/websocket.js
var require_websocket2 = __commonJS({
  "node_modules/websocket/lib/websocket.js"(exports, module2) {
    init_shims();
    module2.exports = {
      "server": require_WebSocketServer(),
      "client": require_WebSocketClient(),
      "router": require_WebSocketRouter(),
      "frame": require_WebSocketFrame(),
      "request": require_WebSocketRequest(),
      "connection": require_WebSocketConnection(),
      "w3cwebsocket": require_W3CWebSocket(),
      "deprecation": require_Deprecation(),
      "version": require_version2()
    };
  }
});

// node_modules/websocket/index.js
var require_websocket3 = __commonJS({
  "node_modules/websocket/index.js"(exports, module2) {
    init_shims();
    module2.exports = require_websocket2();
  }
});

// .svelte-kit/vercel/entry.js
__export(exports, {
  default: () => entry_default
});
init_shims();

// node_modules/@sveltejs/kit/dist/node.js
init_shims();
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h = req.headers;
    if (!h["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h["content-length"]);
    if (isNaN(length) && h["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      const [type] = h["content-type"].split(/;\s*/);
      if (type === "application/octet-stream") {
        return fulfil(data);
      }
      const encoding = h["content-encoding"] || "utf-8";
      fulfil(new TextDecoder(encoding).decode(data));
    });
  });
}

// .svelte-kit/output/server/app.js
init_shims();

// node_modules/@sveltejs/kit/dist/ssr.js
init_shims();
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members2 = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members2.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status,
  error: error3,
  branch,
  page: page2
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options2.get_stack(error3);
  }
  if (branch) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page: page2,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page2 && page2.host ? s$1(page2.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error3)},
					nodes: [
						${branch.map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page2.host ? s$1(page2.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page2.path)},
						query: new URLSearchParams(${s$1(page2.query.toString())}),
						params: ${s$1(page2.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url="${url}"`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const { name, message, stack } = error3;
    serialized = try_serialize({ name, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  if (loaded.error) {
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    const status = loaded.status;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error3 };
    }
    return { status, error: error3 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
function resolve(base, path) {
  const baseparts = path[0] === "/" ? [] : base.slice(1).split("/");
  const pathparts = path[0] === "/" ? path.slice(1).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  return `/${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page: page2,
  node,
  $session,
  context,
  is_leaf,
  is_error,
  status,
  error: error3
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page: page2,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        if (options2.read && url.startsWith(options2.paths.assets)) {
          url = url.replace(options2.paths.assets, "");
        }
        if (url.startsWith("//")) {
          throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
        }
        let response;
        if (/^[a-zA-Z]+:/.test(url)) {
          const request2 = new (void 0)(url, opts);
          response = await options2.hooks.serverFetch.call(null, request2);
        } else {
          const [path, search] = url.split("?");
          const resolved = resolve(request.path, path);
          const filename = resolved.slice(1);
          const filename_html = `${filename}/index.html`;
          const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
          if (asset) {
            if (options2.read) {
              response = new (void 0)(options2.read(asset.file), {
                headers: {
                  "content-type": asset.type
                }
              });
            } else {
              response = await (void 0)(`http://${page2.host}/${asset.file}`, opts);
            }
          }
          if (!response) {
            const headers = { ...opts.headers };
            if (opts.credentials !== "omit") {
              uses_credentials = true;
              headers.cookie = request.headers.cookie;
              if (!headers.authorization) {
                headers.authorization = request.headers.authorization;
              }
            }
            if (opts.body && typeof opts.body !== "string") {
              throw new Error("Request body must be a string");
            }
            const rendered = await respond({
              host: request.host,
              method: opts.method || "GET",
              headers,
              path: resolved,
              rawBody: opts.body,
              query: new URLSearchParams(search)
            }, options2, {
              fetched: url,
              initiator: route
            });
            if (rendered) {
              if (state.prerender) {
                state.prerender.dependencies.set(resolved, rendered);
              }
              response = new (void 0)(rendered.body, {
                status: rendered.status,
                headers: rendered.headers
              });
            }
          }
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new (void 0)("Not found", {
          status: 404
        });
      },
      context: { ...context }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  return {
    node,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error3 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page: page2,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page: page2,
      node: default_error,
      $session,
      context: loaded.context,
      is_leaf: false,
      is_error: true,
      status,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error3,
      branch,
      page: page2
    });
  } catch (error4) {
    options2.handle_error(error4);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
async function respond$1({ request, options: options2, state, $session, route }) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id && options2.load_component(id)));
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? leaf.ssr : options2.ssr,
    router: "router" in leaf ? leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: null
    };
  }
  let branch;
  let status = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page: page2,
              node,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({ status, error: error3 } = loaded.loaded);
            }
          } catch (e) {
            options2.handle_error(e);
            status = 500;
            error3 = e;
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page: page2,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (e) {
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error3
            });
          }
        }
        branch.push(loaded);
        if (loaded && loaded.loaded.context) {
          context = {
            ...context,
            ...loaded.loaded.context
          };
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status,
      error: error3,
      branch: branch && branch.filter(Boolean),
      page: page2
    });
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state,
      $session,
      route
    });
    if (response) {
      return response;
    }
    if (state.fetched) {
      return {
        status: 500,
        headers: {},
        body: `Bad request in load function: failed to fetch ${state.fetched}`
      };
    }
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (handler) {
    const match = route.pattern.exec(request.path);
    const params = route.params(match);
    const response = await handler({ ...request, params });
    if (response) {
      if (typeof response !== "object") {
        return error(`Invalid response from route ${request.path}: expected an object, got ${typeof response}`);
      }
      let { status = 200, body, headers = {} } = response;
      headers = lowercase_keys(headers);
      const type = headers["content-type"];
      if (type === "application/octet-stream" && !(body instanceof Uint8Array)) {
        return error(`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`);
      }
      if (body instanceof Uint8Array && type !== "application/octet-stream") {
        return error(`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`);
      }
      let normalized_body;
      if (typeof body === "object" && (!type || type === "application/json")) {
        headers = { ...headers, "content-type": "application/json" };
        normalized_body = JSON.stringify(body);
      } else {
        normalized_body = body;
      }
      return { status, body: normalized_body, headers };
    }
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        map.get(key).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  #map;
  constructor(map) {
    this.#map = map;
  }
  get(key) {
    const value = this.#map.get(key);
    return value && value[0];
  }
  getAll(key) {
    return this.#map.get(key);
  }
  has(key) {
    return this.#map.has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield key;
      }
    }
  }
  *values() {
    for (const [, value] of this.#map) {
      for (let i = 0; i < value.length; i += 1) {
        yield value;
      }
    }
  }
};
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const [type, ...directives] = headers["content-type"].split(/;\s*/);
  if (typeof raw === "string") {
    switch (type) {
      case "text/plain":
        return raw;
      case "application/json":
        return JSON.parse(raw);
      case "application/x-www-form-urlencoded":
        return get_urlencoded(raw);
      case "multipart/form-data": {
        const boundary = directives.find((directive) => directive.startsWith("boundary="));
        if (!boundary)
          throw new Error("Missing boundary");
        return get_multipart(raw, boundary.slice("boundary=".length));
      }
      default:
        throw new Error(`Invalid Content-Type ${type}`);
    }
  }
  return raw;
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  const nope = () => {
    throw new Error("Malformed form data");
  };
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    nope();
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name, value] = raw_header.split(": ");
      name = name.toLowerCase();
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name2, value2] = raw_directive.split("=");
        directives[name2] = JSON.parse(value2);
      });
      if (name === "content-disposition") {
        if (value !== "form-data")
          nope();
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      nope();
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !incoming.path.split("/").pop().includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    const headers = lowercase_keys(incoming.headers);
    return await options2.hooks.handle({
      request: {
        ...incoming,
        headers,
        body: parse_body(incoming.rawBody, headers),
        params: null,
        locals: {}
      },
      resolve: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            error: null,
            branch: [],
            page: null
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body)}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: null
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state);
      }
    });
  } catch (e) {
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// node_modules/svelte/internal/index.mjs
init_shims();
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
var tasks = new Set();
function custom_event(type, detail) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, false, false, detail);
  return e;
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// node_modules/svelte/index.mjs
init_shims();

// .svelte-kit/output/server/app.js
var import_feather_icons = __toModule(require_feather());

// node_modules/svelte/transition/index.mjs
init_shims();

// node_modules/svelte/easing/index.mjs
init_shims();

// .svelte-kit/output/server/app.js
var import_core_cjs = __toModule(require_core_cjs2());
var import_utilities_cjs = __toModule(require_utilities_cjs());
var import_svelte_apollo_client = __toModule(require_svelte_apollo_client_cjs());
var import_ws_cjs = __toModule(require_ws_cjs());
var import_websocket = __toModule(require_websocket3());

// node_modules/svelte/store/index.mjs
init_shims();
var subscriber_queue2 = [];
function writable2(value, start = noop2) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s2 = subscribers[i];
          s2[1]();
          subscriber_queue2.push(s2, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue2.length; i += 2) {
            subscriber_queue2[i][0](subscriber_queue2[i + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop2;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}

// .svelte-kit/output/server/app.js
var css$3 = {
  code: "#svelte-announcer.svelte-1pdgbjn{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\texport let props_3 = null;\\n\\texport let props_4 = null;\\n\\texport let props_5 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}>\\n\\t\\t\\t\\t\\t{#if components[3]}\\n\\t\\t\\t\\t\\t\\t<svelte:component this={components[3]} {...(props_3 || {})}>\\n\\t\\t\\t\\t\\t\\t\\t{#if components[4]}\\n\\t\\t\\t\\t\\t\\t\\t\\t<svelte:component this={components[4]} {...(props_4 || {})}>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t{#if components[5]}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<svelte:component this={components[5]} {...(props_5 || {})}/>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t\\t\\t\\t</svelte:component>\\n\\t\\t\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t\\t\\t</svelte:component>\\n\\t\\t\\t\\t\\t{/if}\\n\\t\\t\\t\\t</svelte:component>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>#svelte-announcer{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}</style>"],"names":[],"mappings":"AAoEO,gCAAiB,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB,MAAM,GAAG,CAAC,CAAC,UAAU,MAAM,GAAG,CAAC,CAAC,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,SAAS,MAAM,CAAC,SAAS,QAAQ,CAAC,IAAI,CAAC,CAAC,YAAY,MAAM,CAAC,MAAM,GAAG,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  let { props_3 = null } = $$props;
  let { props_4 = null } = $$props;
  let { props_5 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  if ($$props.props_3 === void 0 && $$bindings.props_3 && props_3 !== void 0)
    $$bindings.props_3(props_3);
  if ($$props.props_4 === void 0 && $$bindings.props_4 && props_4 !== void 0)
    $$bindings.props_4(props_4);
  if ($$props.props_5 === void 0 && $$bindings.props_5 && props_5 !== void 0)
    $$bindings.props_5(props_5);
  $$result.css.add(css$3);
  {
    stores.page.set(page2);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {
        default: () => `${components[3] ? `${validate_component(components[3] || missing_component, "svelte:component").$$render($$result, Object.assign(props_3 || {}), {}, {
          default: () => `${components[4] ? `${validate_component(components[4] || missing_component, "svelte:component").$$render($$result, Object.assign(props_4 || {}), {}, {
            default: () => `${components[5] ? `${validate_component(components[5] || missing_component, "svelte:component").$$render($$result, Object.assign(props_5 || {}), {}, {})}` : ``}`
          })}` : ``}`
        })}` : ``}`
      })}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1pdgbjn"}">${navigated ? `${escape2(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>";
var options = null;
var default_settings = { paths: { "base": "", "assets": "/." } };
function init(settings = default_settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-0210123d.js",
      css: ["/./_app/assets/start-0826e215.css", "/./_app/assets/vendor-7fec0a11.css"],
      js: ["/./_app/start-0210123d.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/singletons-bb9012b7.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22) => {
      console.error(error22.stack);
      error22.stack = options.get_stack(error22);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }, { "file": "logotypes/bluk-studio-black.svg", "size": 66505, "type": "image/svg+xml" }, { "file": "logotypes/odzi-dog-small-black.svg", "size": 1881, "type": "image/svg+xml" }],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/login\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/login/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/selector\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/selector/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/create\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/create/__layout.svelte", "src/routes/app/create/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/create\/information\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/create/__layout.svelte", "src/routes/app/create/information.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/create\/members\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/create/__layout.svelte", "src/routes/app/create/members.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/create\/finish\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/create/__layout.svelte", "src/routes/app/create/finish.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/create\/plan\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/create/__layout.svelte", "src/routes/app/create/plan.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/dashboard\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/dashboard.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/settings\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/settings/__layout.svelte", "src/routes/app/[projectId]/settings/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/settings\/general\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/settings/__layout.svelte", "src/routes/app/[projectId]/settings/general.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/settings\/danger\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/settings/__layout.svelte", "src/routes/app/[projectId]/settings/danger.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/settings\/tiles\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/settings/__layout.svelte", "src/routes/app/[projectId]/settings/tiles.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/editor\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/editor/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/app\/([^/]+?)\/editor\/explorer\/?$/,
      params: (m) => ({ projectId: d(m[1]) }),
      a: ["src/routes/__layout.svelte", "src/routes/app/__layout.svelte", "src/routes/app/[projectId]/__layout.svelte", "src/routes/app/[projectId]/editor/explorer.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  serverFetch: hooks.serverFetch || void 0
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout$4;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$7;
  }),
  "src/routes/login/index.svelte": () => Promise.resolve().then(function() {
    return index$6;
  }),
  "src/routes/app/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout$3;
  }),
  "src/routes/app/index.svelte": () => Promise.resolve().then(function() {
    return index$5;
  }),
  "src/routes/app/selector/index.svelte": () => Promise.resolve().then(function() {
    return index$4;
  }),
  "src/routes/app/create/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout$2;
  }),
  "src/routes/app/create/index.svelte": () => Promise.resolve().then(function() {
    return index$3;
  }),
  "src/routes/app/create/information.svelte": () => Promise.resolve().then(function() {
    return information;
  }),
  "src/routes/app/create/members.svelte": () => Promise.resolve().then(function() {
    return members;
  }),
  "src/routes/app/create/finish.svelte": () => Promise.resolve().then(function() {
    return finish;
  }),
  "src/routes/app/create/plan.svelte": () => Promise.resolve().then(function() {
    return plan;
  }),
  "src/routes/app/[projectId]/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout$1;
  }),
  "src/routes/app/[projectId]/index.svelte": () => Promise.resolve().then(function() {
    return index$2;
  }),
  "src/routes/app/[projectId]/dashboard.svelte": () => Promise.resolve().then(function() {
    return dashboard;
  }),
  "src/routes/app/[projectId]/settings/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  "src/routes/app/[projectId]/settings/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/app/[projectId]/settings/general.svelte": () => Promise.resolve().then(function() {
    return general;
  }),
  "src/routes/app/[projectId]/settings/danger.svelte": () => Promise.resolve().then(function() {
    return danger;
  }),
  "src/routes/app/[projectId]/settings/tiles.svelte": () => Promise.resolve().then(function() {
    return tiles;
  }),
  "src/routes/app/[projectId]/editor/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/app/[projectId]/editor/explorer.svelte": () => Promise.resolve().then(function() {
    return explorer;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "/./_app/pages/__layout.svelte-784941f1.js", "css": ["/./_app/assets/pages/__layout.svelte-d86d1d7a.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/__layout.svelte-784941f1.js", "/./_app/chunks/vendor-adcc401c.js"], "styles": null }, ".svelte-kit/build/components/error.svelte": { "entry": "/./_app/error.svelte-c8f673b2.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/error.svelte-c8f673b2.js", "/./_app/chunks/vendor-adcc401c.js"], "styles": null }, "src/routes/index.svelte": { "entry": "/./_app/pages/index.svelte-1999c8a6.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/index.svelte-1999c8a6.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js"], "styles": null }, "src/routes/login/index.svelte": { "entry": "/./_app/pages/login/index.svelte-fba1cb5b.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/login/index.svelte-fba1cb5b.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/CurrentProfile.store-6e386cb1.js"], "styles": null }, "src/routes/app/__layout.svelte": { "entry": "/./_app/pages/app/__layout.svelte-76f4a136.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/__layout.svelte-76f4a136.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/CurrentProfile.store-6e386cb1.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/index.svelte": { "entry": "/./_app/pages/app/index.svelte-02403512.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/index.svelte-02403512.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js"], "styles": null }, "src/routes/app/selector/index.svelte": { "entry": "/./_app/pages/app/selector/index.svelte-27be8fc6.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/selector/index.svelte-27be8fc6.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/create/__layout.svelte": { "entry": "/./_app/pages/app/create/__layout.svelte-1f3fd889.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/create/__layout.svelte-1f3fd889.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/create/index.svelte": { "entry": "/./_app/pages/app/create/index.svelte-0dcfbfa4.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/create/index.svelte-0dcfbfa4.js", "/./_app/chunks/vendor-adcc401c.js"], "styles": null }, "src/routes/app/create/information.svelte": { "entry": "/./_app/pages/app/create/information.svelte-22107c07.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/create/information.svelte-22107c07.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/CreateProject.store-664e8fcf.js", "/./_app/chunks/NamedProjectProperties.config-8de7d006.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js"], "styles": null }, "src/routes/app/create/members.svelte": { "entry": "/./_app/pages/app/create/members.svelte-ae8832ff.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/create/members.svelte-ae8832ff.js", "/./_app/chunks/vendor-adcc401c.js"], "styles": null }, "src/routes/app/create/finish.svelte": { "entry": "/./_app/pages/app/create/finish.svelte-77644825.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/create/finish.svelte-77644825.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/CreateProject.store-664e8fcf.js", "/./_app/chunks/NamedProjectProperties.config-8de7d006.js", "/./_app/chunks/ProjectPlans.config-cf92942c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/create/plan.svelte": { "entry": "/./_app/pages/app/create/plan.svelte-10f3e07b.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/create/plan.svelte-10f3e07b.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/CreateProject.store-664e8fcf.js", "/./_app/chunks/ProjectPlans.config-cf92942c.js"], "styles": null }, "src/routes/app/[projectId]/__layout.svelte": { "entry": "/./_app/pages/app/[projectId]/__layout.svelte-211123e3.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/__layout.svelte-211123e3.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/CurrentProfile.store-6e386cb1.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/[projectId]/index.svelte": { "entry": "/./_app/pages/app/[projectId]/index.svelte-b32976ae.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/index.svelte-b32976ae.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-e9c66975.js"], "styles": null }, "src/routes/app/[projectId]/dashboard.svelte": { "entry": "/./_app/pages/app/[projectId]/dashboard.svelte-42f10cee.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/dashboard.svelte-42f10cee.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/ControlsTile-627badc9.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/[projectId]/settings/__layout.svelte": { "entry": "/./_app/pages/app/[projectId]/settings/__layout.svelte-1a84ca06.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/settings/__layout.svelte-1a84ca06.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js"], "styles": null }, "src/routes/app/[projectId]/settings/index.svelte": { "entry": "/./_app/pages/app/[projectId]/settings/index.svelte-f6cdcceb.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/settings/index.svelte-f6cdcceb.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js"], "styles": null }, "src/routes/app/[projectId]/settings/general.svelte": { "entry": "/./_app/pages/app/[projectId]/settings/general.svelte-b2d0bf0c.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/settings/general.svelte-b2d0bf0c.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/UniversalSettingCard-2a03f517.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/[projectId]/settings/danger.svelte": { "entry": "/./_app/pages/app/[projectId]/settings/danger.svelte-81d77122.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/settings/danger.svelte-81d77122.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/RadialSpinner-87915e8f.js"], "styles": null }, "src/routes/app/[projectId]/settings/tiles.svelte": { "entry": "/./_app/pages/app/[projectId]/settings/tiles.svelte-10e1e2d3.js", "css": ["/./_app/assets/RadialSpinner.svelte_svelte&type=style&lang-a3277522.css", "/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/settings/tiles.svelte-10e1e2d3.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/SimpleIcon-9bf6c4b5.js", "/./_app/chunks/AvailablePages.store-4be7f7f6.js", "/./_app/chunks/ControlsTile-627badc9.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-e9c66975.js", "/./_app/chunks/RadialSpinner-87915e8f.js", "/./_app/chunks/UniversalSettingCard-2a03f517.js"], "styles": null }, "src/routes/app/[projectId]/editor/index.svelte": { "entry": "/./_app/pages/app/[projectId]/editor/index.svelte-9f6cfd9e.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/editor/index.svelte-9f6cfd9e.js", "/./_app/chunks/vendor-adcc401c.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-e9c66975.js"], "styles": null }, "src/routes/app/[projectId]/editor/explorer.svelte": { "entry": "/./_app/pages/app/[projectId]/editor/explorer.svelte-b6724b8d.js", "css": ["/./_app/assets/vendor-7fec0a11.css"], "js": ["/./_app/pages/app/[projectId]/editor/explorer.svelte-b6724b8d.js", "/./_app/chunks/vendor-adcc401c.js"], "styles": null } };
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var _layout$4 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${slots.default ? slots.default({}) : ``}`;
});
var __layout$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout$4
});
function load({ error: error22, status }) {
  return { props: { error: error22, status } };
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status } = $$props;
  let { error: error22 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status)}</h1>

<p>${escape2(error22.message)}</p>


${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load
});
function guard(name) {
  return () => {
    throw new Error(`Cannot call ${name}(...) on the server`);
  };
}
var goto = guard("goto");
var SimpleIcon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { name } = $$props;
  let { attrs } = $$props;
  if ($$props.name === void 0 && $$bindings.name && name !== void 0)
    $$bindings.name(name);
  if ($$props.attrs === void 0 && $$bindings.attrs && attrs !== void 0)
    $$bindings.attrs(attrs);
  return `<!-- HTML_TAG_START -->${import_feather_icons.default.icons[name].toSvg(attrs)}<!-- HTML_TAG_END -->`;
});
var getStores = () => {
  const stores = getContext("__svelte__");
  return {
    page: {
      subscribe: stores.page.subscribe
    },
    navigating: {
      subscribe: stores.navigating.subscribe
    },
    get preloading() {
      console.error("stores.preloading is deprecated; use stores.navigating instead");
      return {
        subscribe: stores.navigating.subscribe
      };
    },
    session: stores.session
  };
};
var page = {
  subscribe(fn) {
    const store = getStores().page;
    return store.subscribe(fn);
  }
};
var httpLink = new import_core_cjs.HttpLink({
  uri: "http://localhost:3001/graphql"
});
var wsLink = new import_ws_cjs.WebSocketLink({
  uri: "ws://localhost:3001/graphql",
  options: {
    reconnect: true
  },
  webSocketImpl: import_websocket.default
});
var splitLink = (0, import_core_cjs.split)(({ query }) => {
  const definition = (0, import_utilities_cjs.getMainDefinition)(query);
  return definition.kind === "OperationDefinition" && definition.operation === "subscription";
}, wsLink, httpLink);
var client = (0, import_svelte_apollo_client.SvelteApolloClient)({
  link: splitLink,
  credentials: "include",
  cache: new import_core_cjs.InMemoryCache()
});
var LoginMutation = import_core_cjs.gql`
  mutation Login($token: String!) {
    login(token: $token) {
      _id
      email
      username
    }
  }
`;
var FetchMe = import_core_cjs.gql`
  query me {
    me {
      _id
      email
      token
    }
  }
`;
var ProfileProjects$1 = import_core_cjs.gql`
  query ProfileProjects {
    ProfileProjects {
      _id
      name
      description
    }
  }
`;
var ProjectById = import_core_cjs.gql`
  query Project($projectId: String!) {
    Project(projectId: $projectId) {
      _id
      name
      description
    }
  }
`;
var CreateProject = import_core_cjs.gql`
  mutation CreateProject($input: CreateProjectInput!) {
    CreateProject(input: $input) {
      _id
    }
  }
`;
var BaseWidget = `
type
enabled
x
y
height
width
`;
var AllDashboardWidgets = `
widgets {
  __typename
  ...on ControlsWidget {
    ${BaseWidget}
  }
  ...on ConsoleWidget {
    ${BaseWidget}
  }
  ...on PlayersWidget {
    ${BaseWidget}
  }
  ...on LogsWidget {
    ${BaseWidget}
  }
}
`;
import_core_cjs.gql`
  mutation UpdateConsoleWidget(
    $dashboardId: String!
    $input: ConsoleWidgetInput!
  ) {
    UpdateConsoleWidget(
      dashboardId: $dashboardId
      input: $input
    ) {
      _id
      name
    }
  }
`;
import_core_cjs.gql`
  mutation UpdateControlsWidget(
    $dashboardId: String!
    $input: ControlsWidgetInput!
  ) {
    UpdateControlsWidget(
      dashboardId: $dashboardId
      input: $input
    ) {
      _id
      name
    }
  }
`;
import_core_cjs.gql`
  mutation UpdateLogsWidget(
    $dashboardId: String!
    $input: LogsWidgetInput!
  ) {
    UpdateLogsWidget(
      dashboardId: $dashboardId
      input: $input
    ) {
      _id
      name
    }
  }
`;
import_core_cjs.gql`
  mutation UpdatePlayersWidget(
    $dashboardId: String!
    $input: PlayersWidgetInput!
  ) {
    UpdatePlayersWidget(
      dashboardId: $dashboardId
      input: $input
    ) {
      _id
      name
    }
  }
`;
var CurrentDashboardConfig = import_core_cjs.gql`
  query CurrentDashboardConfig($projectId: String!) {
    CurrentProjectDashboard(projectId: $projectId) {
      _id
      name
      ${AllDashboardWidgets}
    }
  }
`;
import_core_cjs.gql`
  query ProjectDashboardByProfile($profileId: String!) {
    ProjectDashboardByProfile(projectId: $projectId) {
      _id
      name
      ${AllDashboardWidgets}
    }
  }
`;
var UpdateProjectDashboard = import_core_cjs.gql`
  mutation UpdateProjectDashboard(
    $dashboardId: String!
    $input: UpdateDashboardConfigInput!
  ) {
    UpdateProjectDashboard(
      dashboardId: $dashboardId
      input: $input
    ) {
      _id
      name
    }
  }
`;
var OnlineMode = import_core_cjs.gql`
  query OnlineMode($projectId: String!) {
    Project(projectId: $projectId) {
      settings {
        server {
          onlineMode
        }
      }
    }
  }
`;
var Whitelist = import_core_cjs.gql`
  query Whitelist($projectId: String!) {
    Project(projectId: $projectId) {
      settings {
        server {
          whitelist
        }
      }
    }
  }
`;
var FetchServerAddress = import_core_cjs.gql`
  query FetchServerAddress($projectId: String!) {
    Project(projectId: $projectId) {
      settings {
        server {
          address
        }
      }
    }
  }
`;
var UpdateServerAddress = import_core_cjs.gql`
  mutation UpdateServerAddress($projectId: String!, $value: String!) {
    UpdateServerSettings(
      projectId: $projectId,
      input: {
        address: $value
      }
    ) {
      server {
        address
      }
    }
  }
`;
var UpdateOnlineMode = import_core_cjs.gql`
  mutation UpdateOnlineMode(
    $projectId: String!
    $value: Boolean!
  ) {
    UpdateServerSettings(
      projectId: $projectId,
      input: {
        onlineMode: $value
      }
    ) {
      server {
        onlineMode
      }
    }
  }
`;
var UpdateWhitelist = import_core_cjs.gql`
  mutation UpdateWhitelist(
    $projectId: String!
    $value: Boolean!
  ) {
    UpdateServerSettings(
      projectId: $projectId,
      input: {
        whitelist: $value
      }
    ) {
      server {
        whitelist
      }
    }
  }
`;
var TogglePlayersWidget = import_core_cjs.gql`
  mutation TogglePlayersWidget(
    $dashboardId: String!
    $value: Boolean!
  ) {
    UpdatePlayersWidget(
      dashboardId: $dashboardId,
      input: {
        enabled: $value
      }
    ) {
      widgets {
        __typename
        ...on PlayersWidget {
          enabled
        }
      }
    }
  }
`;
var ToggleControlsWidget = import_core_cjs.gql`
  mutation ToggleControlsWidget(
    $dashboardId: String!
    $value: Boolean!
  ) {
    UpdateControlsWidget(
      dashboardId: $dashboardId,
      input: {
        enabled: $value
      }
    ) {
      widgets {
        __typename
        ...on ControlsWidget {
          enabled
        }
      }
    }
  }
`;
var ToggleConsoleWidget = import_core_cjs.gql`
  mutation ToggleConsoleWidget(
    $dashboardId: String!
    $value: Boolean!
  ) {
    UpdateConsoleWidget(
      dashboardId: $dashboardId,
      input: {
        enabled: $value
      }
    ) {
      widgets {
        __typename
        ...on ConsoleWidget {
          enabled
        }
      }
    }
  }
`;
var ToggleLogsWidget = import_core_cjs.gql`
  mutation ToggleLogsWidget(
    $dashboardId: String!
    $value: Boolean!
  ) {
    UpdateLogsWidget(
      dashboardId: $dashboardId,
      input: {
        enabled: $value
      }
    ) {
      widgets {
        __typename
        ...on LogsWidget {
          enabled
        }
      }
    }
  }
`;
import_core_cjs.gql`
  mutation DeleteProject($projectId: String!) {
    DeleteProject(projectId: $projectId) {
      _id
    }
  }
`;
var SubscribeToWorkerState = import_core_cjs.gql`
  subscription CurrentWorkerState(
    $projectId: String!
    $token: String!  
  ) {
    CurrentWorkerState(
      projectId: $projectId
      token: $token
    ) {
      state
    }
  }
`;
function _initialize$6() {
  const defaultStore = {
    loggedIn: false
  };
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  function updateProfile(profile) {
    update((object) => {
      if (profile == null) {
        object.loggedIn = false;
        object.profile = null;
      } else {
        object.loggedIn = true;
        object.profile = profile;
      }
      return object;
    });
  }
  return {
    subscribe: subscribe2,
    async authorize(token) {
      const response = await client.mutate(LoginMutation, { variables: { token } });
      if (response.errors) {
        console.error("graphql authorize mutation error", response.errors);
      } else {
        updateProfile(response.data.login);
      }
    },
    async fetchMe() {
      return new Promise((resolve2, reject) => {
        client.query(FetchMe).subscribe((response) => {
          var _a;
          if (response.loading)
            return;
          if (response.error) {
            console.error("graphql fetchme query error", response.error);
            reject({ error: true });
          } else {
            updateProfile((_a = response.data) == null ? void 0 : _a.me);
            resolve2(response);
          }
        });
      });
    }
  };
}
var CurrentProfile = _initialize$6();
function _initialize$5() {
  const defaultStore = {
    loaded: false,
    list: []
  };
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  function updateList(projects) {
    update((object) => {
      object.loaded = true;
      object.list = projects;
      return object;
    });
  }
  return {
    subscribe: subscribe2,
    clear() {
      update((object) => {
        object.loaded = false;
        object.list = [];
        return object;
      });
    },
    async fetch() {
      return new Promise((resolve2, reject) => {
        client.query(ProfileProjects$1).subscribe((response) => {
          var _a;
          if (response.loading)
            return;
          if (response.error) {
            console.error("graphql profileprojects query error", response.error);
            reject({ error: true });
          } else {
            updateList((_a = response.data) == null ? void 0 : _a.ProfileProjects);
            resolve2(response);
          }
        });
        client.query(ProfileProjects$1).refetch();
      });
    }
  };
}
var ProfileProjects = _initialize$5();
function _initialize$4() {
  const defaultStore = {};
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  return {
    subscribe: subscribe2,
    async create() {
      const project = await new Promise((resolve2) => {
        subscribe2((object) => {
          resolve2(object);
        });
      });
      const response = await client.mutate(CreateProject, {
        variables: {
          input: {
            name: project.name,
            description: project.description
          }
        }
      });
      ProfileProjects.fetch();
      return response.data.CreateProject;
    },
    setPlan(plan2) {
      update((object) => {
        object.plan = plan2;
        return object;
      });
    },
    setName(name) {
      update((object) => {
        object.name = name;
        return object;
      });
    },
    setDescription(description) {
      update((object) => {
        object.description = description;
        return object;
      });
    }
  };
}
var CreateProjectStore = _initialize$4();
function _initialize$3() {
  const defaultStore = {
    loaded: false,
    project: {},
    state: {}
  };
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  function updateProject(project) {
    update((object) => {
      object.loaded = true;
      object.project = project;
      return object;
    });
  }
  return {
    subscribe: subscribe2,
    async clear() {
      updateProject({});
    },
    async fetch(projectId) {
      return new Promise((resolve2, reject) => {
        client.query(ProjectById, { variables: { projectId } }).subscribe((response) => {
          var _a;
          if (response.loading)
            return;
          if (response.error) {
            console.error("graphql project query error", response.error);
            reject({ error: true });
          } else {
            updateProject((_a = response.data) == null ? void 0 : _a.Project);
            resolve2(response);
          }
        });
      });
    }
  };
}
var CurrentProject = _initialize$3();
function _initialize$2() {
  const defaultStore = {
    widgets: []
  };
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  function updateStore(store) {
    update((object) => {
      var _a;
      object._id = store._id, object.projectId = (_a = store.projectId) != null ? _a : object.projectId;
      object.widgets = store.widgets;
      return object;
    });
  }
  function fetchDashboard(projectId) {
    return new Promise((resolve2, reject) => {
      const query = client.query(CurrentDashboardConfig, { variables: { projectId } });
      query.refetch();
      query.subscribe((response) => {
        if (response.loading)
          return;
        if (response.error) {
          console.error("graphql project query error", response.error);
          reject({ error: true });
        } else {
          updateStore({ ...response.data.CurrentProjectDashboard, projectId });
          resolve2(response);
        }
      });
    });
  }
  return {
    subscribe: subscribe2,
    async refetch() {
      console.log("refetch");
      const dashboard2 = await new Promise((resolve2) => {
        subscribe2((object) => {
          resolve2(object);
        });
      });
      console.log(dashboard2);
      return await fetchDashboard(String(dashboard2.projectId));
    },
    async fetch(projectId) {
      console.log("fetch dashboard");
      return await fetchDashboard(projectId);
    },
    async updateLayout(dashboardId, widgets) {
      const response = await client.mutate(UpdateProjectDashboard, {
        variables: {
          dashboardId,
          input: {
            widgets: widgets.map((widget) => {
              return {
                type: widget.type,
                x: widget.x,
                y: widget.y,
                width: widget.width,
                height: widget.height
              };
            })
          }
        }
      });
      return response.data.UpdateProjectDashboard;
    }
  };
}
var ProjectDashboard = _initialize$2();
var Categories = [
  {
    id: "basic",
    title: "\u0411\u0430\u0437\u043E\u0432\u043E\u0435",
    description: "\u0411\u0430\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0438 \u043E\u0431\u044B\u0447\u043D\u044B\u0435 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B"
  },
  {
    id: "project",
    title: "\u041F\u0440\u043E\u0435\u043A\u0442",
    description: "\u0412\u0441\u0435 \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B, \u0441\u0432\u044F\u0437\u0430\u043D\u043D\u044B\u0435 \u0441 \u0442\u0435\u043A\u0443\u0449\u0438\u043C \u043F\u0440\u043E\u0435\u043A\u0442\u043E\u043C"
  }
];
var Pages = [
  {
    url: "/app/selector",
    regex: /\/app\/selector/,
    checkName: "projectSelector",
    category: "basic",
    icon: "list",
    iconColor: "#818cf8",
    title: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0441\u0435\u0440\u0432\u0435\u0440",
    description: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0441\u043F\u0438\u0441\u043A\u0443 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0441\u0435\u0440\u0432\u0435\u0440\u043E\u0432"
  },
  {
    url: "/app/create",
    regex: /\/app\/create\/[\s\S]+/,
    checkName: "createProject",
    category: "basic",
    icon: "layers",
    title: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0441\u0435\u0440\u0432\u0435\u0440",
    description: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u043D\u043E\u0432\u044B\u0439 \u0441\u0435\u0440\u0432\u0435\u0440"
  },
  {
    url: "/app/${ $page.params.projectId }/dashboard",
    regex: /\/app\/[\s\S]{24}\/dashboard/,
    checkName: "currentProject",
    category: "project",
    icon: "home",
    iconColor: "#34d399",
    title: "\u0413\u043B\u0430\u0432\u043D\u0430\u044F",
    description: "\u0412\u0441\u044F \u0441\u0430\u043C\u0430\u044F \u0432\u0430\u0436\u043D\u0430\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0442\u0435\u043A\u0443\u0449\u0435\u043C \u0441\u0435\u0440\u0432\u0435\u0440\u0435"
  },
  {
    url: "/app/${ $page.params.projectId }/editor",
    regex: /\/app\/[\s\S]{24}\/editor\/[\s\S]+/,
    checkName: "currentProject",
    category: "project",
    icon: "code",
    iconColor: "#f472b6",
    title: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440",
    description: "\u0421\u043E\u0437\u0434\u0430\u0432\u0430\u0439\u0442\u0435 \u0438 \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0441\u0432\u043E\u0438 \u043F\u043B\u0430\u0433\u0438\u043D\u044B"
  },
  {
    url: "/app/${ $page.params.projectId }/worlds",
    regex: /\/app\/[\s\S]{24}\/worlds/,
    checkName: "currentProject",
    category: "project",
    icon: "archive",
    title: "\u041C\u0438\u0440\u044B",
    description: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0432\u0441\u0435\u0445 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 \u043D\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0435 \u043C\u0438\u0440\u043E\u0432"
  },
  {
    url: "/app/${ $page.params.projectId }/settings",
    regex: /\/app\/[\s\S]{24}\/settings\/[\s\S]+/,
    checkName: "currentProject",
    category: "project",
    icon: "settings",
    title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
    description: "\u0413\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0432\u0441\u0435\u0433\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0438 \u043F\u0440\u043E\u0435\u043A\u0442\u0430"
  }
];
var CreateProjectPages = [
  {
    id: "plan",
    title: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0441\u0435\u0440\u0432\u0435\u0440",
    description: "1. \u0414\u043B\u044F \u0442\u043E\u0433\u043E, \u0447\u0442\u043E \u0431\u044B \u043D\u0430\u0447\u0430\u0442\u044C \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430, \u043F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u043B\u0430\u043D."
  },
  {
    id: "information",
    title: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0435",
    description: "2. \u0417\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u0431\u0430\u0437\u043E\u0432\u0443\u044E \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0434\u0430\u043D\u043D\u043E\u043C \u0441\u0435\u0440\u0432\u0435\u0440\u0435."
  },
  {
    id: "finish",
    title: "\u0418\u0442\u043E\u0433",
    description: "4. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0438 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043D\u043E\u0441\u0442\u044C \u0432\u0441\u0435\u0445 \u0434\u0430\u043D\u043D\u044B\u0445."
  }
];
var NamedProjectProperties = [
  {
    id: "plan",
    pageId: "plan",
    required: true,
    icon: "box",
    title: "\u041F\u043B\u0430\u043D",
    description: "\u041F\u043B\u0430\u043D, \u043A\u043E\u0442\u043E\u0440\u044B\u0439 \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u044F\u0435\u0442 \u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0440\u0435\u0441\u0443\u0440\u0441\u043E\u0432 \u0438 \u0437\u0430 \u043A\u0430\u043A\u0438\u0435 \u0434\u0435\u043D\u044C\u0433\u0438 \u0432\u044B \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u0442\u0435."
  },
  {
    id: "name",
    pageId: "information",
    required: true,
    icon: "feather",
    title: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435",
    description: "\u0423\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u043E\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432\u0430\u0448\u0435\u0433\u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0430."
  },
  {
    id: "description",
    pageId: "information",
    required: false,
    icon: "align-center",
    title: "\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435",
    description: "\u041D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0435 \u043E\u043F\u0438\u0441\u0430\u043D\u0438\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430."
  }
];
var ProjectPlans = [
  {
    id: "developer",
    price: 0,
    icon: "code",
    color: "#fbbf24",
    title: "\u041F\u043B\u0430\u043D \u0440\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\u043A\u0430",
    description: "\u041D\u0435\u043E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D\u043D\u044B\u0439 \u043F\u043B\u0430\u043D, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u043C \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0440\u0430\u0431\u043E\u0442\u0430\u044E\u0442 <span class='border-b-2 border-yellow-400'>24/7</span>, <span class='border-b-2 border-yellow-400'>\u0431\u0435\u0437\u043B\u0438\u043C\u0438\u0442\u043D\u043E\u0435 \u043A\u043E\u043B-\u0432\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u043E\u0432</span>, <span class='border-b-2 border-yellow-400'>\u0438\u0433\u0440\u043E\u043A\u043E\u0432</span> \u0438 \u043C\u043D\u043E\u0433\u043E\u0435-\u043C\u043D\u043E\u0433\u043E\u0435 \u0434\u0440\u0443\u0433\u043E\u0435."
  }
];
var SettingsCategories = [
  {
    id: "general",
    title: "\u0411\u0430\u0437\u043E\u0432\u043E\u0435",
    icon: "globe"
  },
  {
    id: "tiles",
    title: "\u0422\u0430\u0439\u043B\u044B",
    icon: "grid"
  },
  {
    id: "danger",
    title: "\u041E\u043F\u0430\u0441\u043D\u0430\u044F \u0437\u043E\u043D\u0430",
    icon: "alert-triangle"
  }
];
var ESettingCardType;
(function(ESettingCardType2) {
  ESettingCardType2["TOGGLER"] = "TOGGLER";
  ESettingCardType2["INPUT"] = "INPUT";
})(ESettingCardType || (ESettingCardType = {}));
async function toggleOnlineMode(input) {
  return new Promise((resolve2) => {
    CurrentProject.subscribe(async ({ project }) => {
      const response = await client.mutate(UpdateOnlineMode, {
        variables: {
          projectId: project._id,
          value: !input.enabled
        }
      });
      resolve2(response.data.UpdateServerSettings.server.onlineMode);
    });
  });
}
function toggleWhitelist(input) {
  return new Promise((resolve2) => {
    CurrentProject.subscribe(async ({ project }) => {
      const response = await client.mutate(UpdateWhitelist, {
        variables: {
          projectId: project._id,
          value: !input.enabled
        }
      });
      resolve2(response.data.UpdateServerSettings.server.whitelist);
    });
  });
}
async function updatePublicAddress(input) {
  return new Promise((resolve2) => {
    CurrentProject.subscribe(async ({ project }) => {
      const response = await client.mutate(UpdateServerAddress, {
        variables: {
          projectId: project._id,
          value: input.value
        }
      });
      resolve2(response.data.UpdateServerSettings.server.address);
    });
  });
}
async function getOnlineMode() {
  return new Promise((resolve2) => {
    CurrentProject.subscribe(({ project }) => {
      const projectId = project._id;
      if (!projectId)
        return;
      client.query(OnlineMode, { variables: { projectId } }).subscribe((response) => {
        var _a, _b, _c;
        if (response.loading)
          return;
        if (!response.error) {
          resolve2((_c = (_b = (_a = response.data) == null ? void 0 : _a.Project) == null ? void 0 : _b.settings.server.onlineMode) != null ? _c : false);
        } else {
          console.log("error while making request");
        }
      });
    });
  });
}
async function getWhitelist() {
  return new Promise((resolve2) => {
    CurrentProject.subscribe(({ project }) => {
      const projectId = project._id;
      if (!projectId)
        return;
      client.query(Whitelist, { variables: { projectId } }).subscribe((response) => {
        var _a, _b, _c;
        if (response.loading)
          return;
        if (!response.error) {
          resolve2((_c = (_b = (_a = response.data) == null ? void 0 : _a.Project) == null ? void 0 : _b.settings.server.whitelist) != null ? _c : false);
        } else {
          console.log("error while making request");
        }
      });
    });
  });
}
async function getPublicAddress() {
  return new Promise((resolve2) => {
    CurrentProject.subscribe(({ project }) => {
      const projectId = project._id;
      if (!projectId)
        return;
      client.query(FetchServerAddress, { variables: { projectId } }).subscribe((response) => {
        var _a, _b, _c;
        if (response.loading)
          return;
        if (!response.error) {
          resolve2((_c = (_b = (_a = response.data) == null ? void 0 : _a.Project) == null ? void 0 : _b.settings.server.address) != null ? _c : "");
        } else {
          console.log("error while making request");
        }
      });
    });
  });
}
function EnableWidget(type) {
  let query;
  switch (type) {
    case "PLAYERS":
      query = TogglePlayersWidget;
      break;
    case "CONSOLE":
      query = ToggleConsoleWidget;
      break;
    case "CONTROLS":
      query = ToggleControlsWidget;
      break;
    case "LOGS":
      query = ToggleLogsWidget;
      break;
  }
  if (query == null)
    return;
  return function(input) {
    return new Promise(async (resolve2) => {
      const dashboardId = await new Promise((resolve22) => {
        const unsubscribe = ProjectDashboard.subscribe(async ({ _id }) => {
          resolve22(_id);
        });
        unsubscribe();
      });
      await client.mutate(query, {
        variables: {
          dashboardId,
          value: !input.enabled
        }
      });
      ProjectDashboard.refetch();
      resolve2(!input.enabled);
    });
  };
}
function isWidgetEnabled(type) {
  return function() {
    return new Promise((resolve2) => {
      ProjectDashboard.subscribe((dashboard2) => {
        var _a, _b;
        const widgets = (_a = dashboard2.widgets) != null ? _a : [];
        const widget = widgets.find((x) => x.type == type);
        if (widget == null)
          return;
        resolve2((_b = widget.enabled) != null ? _b : false);
      });
    });
  };
}
var PlayersWidgetGetters = {
  isEnabled: isWidgetEnabled("PLAYERS")
};
var PlayersWidgetUpdaters = {
  enable: EnableWidget("PLAYERS")
};
var ControlsWidgetGetters = {
  isEnabled: isWidgetEnabled("CONTROLS")
};
var ControlsWidgetUpdaters = {
  enable: EnableWidget("CONTROLS")
};
var ConsoleWidgetGetters = {
  isEnabled: isWidgetEnabled("CONSOLE")
};
var ConsoleWidgetUpdaters = {
  enable: EnableWidget("CONSOLE")
};
var LogsWidgetGetters = {
  isEnabled: isWidgetEnabled("LOGS")
};
var LogsWidgetUpdaters = {
  enable: EnableWidget("LOGS")
};
var GeneralSettings = [
  {
    type: ESettingCardType.TOGGLER,
    title: "\u041E\u043D\u043B\u0430\u0439\u043D-\u0440\u0435\u0436\u0438\u043C",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "rss",
    color: "#fbbf24",
    updater: toggleOnlineMode,
    getter: getOnlineMode
  },
  {
    type: ESettingCardType.TOGGLER,
    title: "\u0412\u0430\u0439\u0442\u043B\u0438\u0441\u0442",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "shield",
    color: "#3b82f6",
    updater: toggleWhitelist,
    getter: getWhitelist
  },
  {
    type: ESettingCardType.INPUT,
    title: "\u041F\u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441\u0441",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "globe",
    color: "#10b981",
    textPlaceholder: "\u041F\u0443\u0431\u043B\u0438\u0447\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441\u0441",
    placeholder: {
      side: "right",
      text: ".bluk.studio"
    },
    footerText: '\u041F\u0440\u0438\u043D\u0438\u043C\u0430\u044E\u0442\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E <span class="bg-gray-300 rounded-full px-1.5 py-0.5">\u0410\u043D\u0433\u043B\u0438\u0439\u0441\u043A\u0438\u0435 \u0431\u0443\u043A\u0432\u044B</span> \u043C\u0430\u043A\u0441\u0438\u043C\u0443\u043C <span class="bg-gray-300 rounded-full px-1.5 py-0.5">20 \u0431\u0443\u043A\u0432</span>',
    updater: updatePublicAddress,
    getter: getPublicAddress
  }
];
var ConsoleWidgetSettings = [
  {
    type: "TOGGLER",
    title: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "check",
    color: "#10b981",
    size: "1/2",
    getter: ConsoleWidgetGetters.isEnabled,
    updater: ConsoleWidgetUpdaters.enable
  }
];
var ControlsWidgetSettings = [
  {
    type: "TOGGLER",
    title: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "check",
    color: "#10b981",
    size: "1/2",
    getter: ControlsWidgetGetters.isEnabled,
    updater: ControlsWidgetUpdaters.enable
  }
];
var LogsWidgetSettings = [
  {
    type: "TOGGLER",
    title: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "check",
    color: "#10b981",
    size: "1/2",
    getter: LogsWidgetGetters.isEnabled,
    updater: LogsWidgetUpdaters.enable
  }
];
var PlayersWidgetSettings = [
  {
    type: "TOGGLER",
    title: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0442\u044C",
    description: "Lorem ipsum dolor sit, amet consectetur adipisicing elit. Labore, a.",
    icon: "check",
    color: "#10b981",
    size: "1/2",
    getter: PlayersWidgetGetters.isEnabled,
    updater: PlayersWidgetUpdaters.enable
  }
];
var InfoFooterButtons = [
  {
    url: "editor",
    title: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440",
    icon: "code",
    isGhost: false
  },
  {
    url: "settings",
    title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
    icon: "settings",
    isGhost: true
  },
  {
    click: () => {
      document.dispatchEvent(new Event("openPageExplorer"));
    },
    title: "\u0411\u043E\u043B\u044C\u0448\u0435",
    icon: "external-link",
    isGhost: true
  }
];
function _initialize$1() {
  const defaultStore = {
    list: []
  };
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  let projects = [];
  let project = {
    current: {},
    state: {}
  };
  ProfileProjects.subscribe((object) => {
    var _a;
    projects = (_a = object == null ? void 0 : object.list) != null ? _a : [];
    updateAvailability();
  });
  CurrentProject.subscribe((object) => {
    if (object.loaded) {
      project.current = object.project;
      updateAvailability();
    }
  });
  function updateAvailability() {
    let available = [];
    Pages.forEach((page2) => {
      var _a;
      if (page2.checkName == "projectSelector") {
        if ((projects == null ? void 0 : projects.length) > 0) {
          available.push(page2);
        }
      } else if (page2.checkName == "createProject") {
        available.push(page2);
      } else if (page2.checkName == "currentProject") {
        if (((_a = project == null ? void 0 : project.current) == null ? void 0 : _a._id) != null) {
          available.push(page2);
        }
      }
    });
    updateList(available);
  }
  function updateList(pages) {
    update((object) => {
      object.list = pages;
      return object;
    });
  }
  return {
    subscribe: subscribe2
  };
}
var AvailablePages = _initialize$1();
function _initialize() {
  const defaultStore = {
    loaded: false,
    state: "DEAD"
  };
  const { subscribe: subscribe2, update } = writable2(defaultStore);
  function updateStore(store) {
    update((object) => {
      object.loaded = true;
      return {
        ...object,
        ...store
      };
    });
  }
  return {
    subscribe: subscribe2,
    async fetch(projectId) {
      const profileToken = await new Promise((resolve2) => {
        CurrentProfile.subscribe((store) => {
          if (store.loggedIn) {
            resolve2(store.profile.token);
          }
        });
      });
      const subscription = client.subscribe(SubscribeToWorkerState, {
        variables: {
          projectId,
          token: profileToken
        }
      });
      subscription.subscribe((response) => {
        console.log("response:");
        console.log(response);
        if (response.loading)
          return;
        updateStore(response.data.CurrentWorkerState);
      });
    }
  };
}
var CurrentWorkerState = _initialize();
var CurrentPageBadge = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a;
  let currentPage;
  let $page, $$unsubscribe_page;
  let $AvailablePages, $$unsubscribe_AvailablePages;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  $$unsubscribe_AvailablePages = subscribe(AvailablePages, (value) => $AvailablePages = value);
  let popoverVisible = false;
  function popoverSwitch() {
    document.removeEventListener("click", onClickListener);
    popoverVisible = popoverVisible ? false : true;
    setTimeout(() => {
      if (popoverVisible) {
        document.addEventListener("click", onClickListener);
      }
    }, 500);
  }
  page.subscribe(() => {
    if (popoverVisible)
      popoverVisible = false;
  });
  onMount(() => {
    document.addEventListener("openPageExplorer", popoverSwitch);
    currentCategoryId = currentPage === null || currentPage === void 0 ? void 0 : currentPage.category;
  });
  onDestroy(() => {
    document.removeEventListener("openPageExplorer", popoverSwitch);
  });
  function onClickListener(event) {
    if (!popoverVisible)
      return;
    const popoverElement = document.getElementById("currentPageBadge-popover");
    const buttonElement = document.getElementById("currentPageBadge-button");
    let targetElement = event.target;
    do {
      if (targetElement == popoverElement || targetElement == buttonElement) {
        return;
      }
      targetElement = targetElement.parentNode;
    } while (targetElement);
    popoverVisible = false;
  }
  let currentCategoryId;
  Categories.filter((x) => x.id == currentCategoryId)[0];
  currentPage = Pages.filter((x) => {
    return x.regex.test($page.path);
  })[0];
  $$unsubscribe_page();
  $$unsubscribe_AvailablePages();
  return `
<div class="${"mx-4 relative"}"><button id="${"currentPageBadge-button"}" class="${"px-4 w-48 py-2 border-2 border-black flex items-center justify-center"}"><p class="${"text-sm text-black mr-2"}">${escape2((_a = currentPage == null ? void 0 : currentPage.title) != null ? _a : "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E")}</p>

    ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: popoverVisible ? "chevron-up" : "chevron-down",
    attrs: {
      class: "w-4 h-4 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button>

  
  ${popoverVisible ? `<div id="${"currentPageBadge-popover"}" style="${"width: " + escape2($AvailablePages.list.length >= 6 ? "360%" : "180%") + "; margin-top: -2px;"}" class="${"z-20 overflow-x-auto w-full absolute bg-gray-100 border-2 border-black pt-3 pb-2"}">
      ${$AvailablePages.list.length < 6 ? `<div class="${"w-full px-2"}"><h1 class="${"text-md text-black font-medium"}">\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u044B</h1>
          <p class="${"text-xs text-black opacity-80"}">\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u0435\u043C \u0442\u043E\u043B\u044C\u043A\u043E \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0435 \u0432\u0430\u043C \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u044B</p></div>` : ``}

      ${$AvailablePages.list.length >= 6 ? `
        <div class="${"w-full flex items-start justify-center"}">${each(Categories, (category) => `${$AvailablePages.list.filter((x) => x.category == category.id).length > 0 ? `
              <div class="${"w-auto relative"}">
                <div class="${"w-full px-2"}"><h1 class="${"text-md text-black font-medium"}">${escape2(category.title)}</h1>
                  <p class="${"text-xs text-black opacity-80"}">${escape2(category.description)}</p></div>

                
                <div class="${"mt-4"}">${each($AvailablePages.list.filter((x) => x.category == category.id), (availablePage) => {
    var _a2;
    return `<div class="${"w-full border-t-2 border-gray-300 p-2"}">
                      <div class="${"flex items-start justify-between"}"><div class="${"flex items-start w-2/3"}">${availablePage.icon ? `
                            <div style="${"background-color: " + escape2((_a2 = availablePage.iconColor) != null ? _a2 : "#fbbf24")}" class="${"p-1.5 mr-2 mt-0.5 rounded-full"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: availablePage.icon,
      attrs: {
        class: "w-4 h-4 text-white",
        "stroke-width": "2.5"
      }
    }, {}, {})}
                            </div>` : ``}
        
                          <div><h1 class="${"text-md text-black font-medium"}">${escape2(availablePage.title)}</h1>
                            
                            ${availablePage.description ? `<p class="${"text-xs text-black opacity-80"}"><!-- HTML_TAG_START -->${availablePage.description}<!-- HTML_TAG_END --></p>` : ``}
                          </div></div>
                      
                        
                        ${availablePage == currentPage ? `<button class="${"px-2 py-1 bg-black flex items-center justify-center mt-0.5"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "check",
      attrs: {
        class: "w-4 h-4 text-white",
        "stroke-width": "2.5"
      }
    }, {}, {})}
                          
                            <p class="${"text-xs text-white ml-0.5"}">\u0412\u044B \u0442\u0443\u0442</p>
                          </button>` : `<button class="${"px-2 py-1 border-2 border-black flex items-center justify-center mt-0.5"}"><p class="${"text-xs text-black mr-0.5"}">\u041F\u0435\u0440\u0435\u0439\u0442\u0438</p>
        
                            ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "chevron-right",
      attrs: {
        class: "w-4 h-4 text-black",
        "stroke-width": "2.5"
      }
    }, {}, {})}
                          </button>`}</div>
                    </div>`;
  })}</div>
              </div>` : ``}`)}</div>` : `<div class="${"mt-4"}">
          ${each($AvailablePages.list, (availablePage) => {
    var _a2;
    return `<div class="${"w-full border-t-2 border-gray-300 p-2"}">
              <div class="${"flex items-start justify-between"}"><div class="${"flex items-start w-2/3"}">${availablePage.icon ? `
                    <div style="${"background-color: " + escape2((_a2 = availablePage.iconColor) != null ? _a2 : "#fbbf24")}" class="${"p-1.5 mr-2 mt-0.5 rounded-full"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: availablePage.icon,
      attrs: {
        class: "w-4 h-4 text-white",
        "stroke-width": "2.5"
      }
    }, {}, {})}
                    </div>` : ``}

                  <div><h1 class="${"text-md text-black font-medium"}">${escape2(availablePage.title)}</h1>
                    
                    ${availablePage.description ? `<p class="${"text-xs text-black opacity-80"}"><!-- HTML_TAG_START -->${availablePage.description}<!-- HTML_TAG_END --></p>` : ``}
                  </div></div>
              
                
                ${availablePage == currentPage ? `<button class="${"px-2 py-1 bg-black flex items-center justify-center mt-0.5"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "check",
      attrs: {
        class: "w-4 h-4 text-white",
        "stroke-width": "2.5"
      }
    }, {}, {})}
                  
                    <p class="${"text-xs text-white ml-0.5"}">\u0412\u044B \u0442\u0443\u0442</p>
                  </button>` : `<button class="${"px-2 py-1 border-2 border-black flex items-center justify-center mt-0.5"}"><p class="${"text-xs text-black mr-0.5"}">\u041F\u0435\u0440\u0435\u0439\u0442\u0438</p>

                    ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "chevron-right",
      attrs: {
        class: "w-4 h-4 text-black",
        "stroke-width": "2.5"
      }
    }, {}, {})}
                  </button>`}</div>
            </div>`;
  })}</div>`}</div>` : ``}</div>`;
});
var ApplicationHeader = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a, _b, _c, _d, _e, _f;
  let $CurrentProject, $$unsubscribe_CurrentProject;
  let $CurrentProfile, $$unsubscribe_CurrentProfile;
  $$unsubscribe_CurrentProject = subscribe(CurrentProject, (value) => $CurrentProject = value);
  $$unsubscribe_CurrentProfile = subscribe(CurrentProfile, (value) => $CurrentProfile = value);
  $$unsubscribe_CurrentProject();
  $$unsubscribe_CurrentProfile();
  return `
<header class="${"absolute z-10 inset-x-0 top-0 w-full flex items-center justify-between bg-gray-100 py-2 px-6"}">
  <div class="${"flex items-stretch"}">
    <div class="${"flex items-center"}"><img src="${"https://res.cloudinary.com/lococovu-cdn/image/upload/v1636810372/bluk-studio-black.svg"}" alt="${"bluk.studio white logotype"}" class="${"w-8 h-8"}"></div>

    ${$CurrentProject.loaded && ((_a = $CurrentProject.project) == null ? void 0 : _a._id) != null ? `
      <button class="${"ml-6 px-4 py-2 bg-black rounded-sm flex items-center justify-center"}">
        <h1 class="${"text-white text-sm mr-2"}">${escape2((_b = $CurrentProject.project) == null ? void 0 : _b.name)}</h1>

        
        <div class="${"flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-down",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div></button>` : ``}

    
    ${validate_component(CurrentPageBadge, "CurrentPageBadge").$$render($$result, {}, {}, {})}

    ${$CurrentProject.loaded && ((_c = $CurrentProject.project) == null ? void 0 : _c._id) != null ? `
      <button class="${"px-4 py-2 border-2 border-black flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "command",
    attrs: { class: "w-4 h-4", "stroke-width": "2.5" }
  }, {}, {})}</button>` : ``}</div>

  
  <div class="${"flex items-stretch"}">
    <button class="${"px-4 py-2 bg-black rounded-sm flex items-center justify-center"}">
      <div class="${"w-7 h-7 bg-red-500 rounded-full"}"></div>

      
      <div class="${"mx-3 text-left"}"><h1 class="${"text-xs text-white font-medium"}">${escape2((_e = (_d = $CurrentProfile == null ? void 0 : $CurrentProfile.profile) == null ? void 0 : _d.username) != null ? _e : "Default profile")}</h1>
        <p class="${"text-xs text-white opacity-80"}">${escape2((_f = $CurrentProfile == null ? void 0 : $CurrentProfile.profile) == null ? void 0 : _f.email)}</p></div>

      
      <div class="${"flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-down",
    attrs: {
      class: "w-5 h-5 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div></button></div></header>`;
});
var EditorHeader = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<header></header>`;
});
var PlayersTile = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => value);
  $$unsubscribe_page();
  return `
<div class="${"w-full border-b-2 border-gray-300 py-2 px-4 flex items-center justify-between"}"><h1 class="${"text-md text-black font-medium"}">\u0418\u0433\u0440\u043E\u043A\u0438</h1>

  <div class="${"flex items-center"}">
    
    
    <button>${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "settings",
    attrs: { class: "w-4 h-4", "stroke-width": "2.5" }
  }, {}, {})}</button></div></div>


<div class="${"mt-4 px-4"}">
  <div class="${"my-3 flex items-center justify-between"}">
    <div class="${"flex items-center"}"><img src="${"https://crafatar.com/avatars/1b42ff62-b4cb-4b8e-8fbd-efd24e70ced2"}" alt="${""}" class="${"w-8 h-8 rounded-sm"}">
      
      <div class="${"ml-2"}"><h1 class="${"text-base text-black font-medium"}">SniperFox213</h1>
        
        
        <div class="${"flex items-stretch"}">
          <div class="${"mr-1 rounded-full px-2 py-0.5 bg-indigo-400"}"><p class="${"text-xs text-white"}">\u041E\u043F\u0435\u0440\u0430\u0442\u043E\u0440</p></div>

          
          <div class="${"rounded-full px-2 py-0.5 bg-yellow-400"}"><p class="${"text-xs text-white"}">\u0418\u0433\u0440\u0430\u0435\u0442 4 \u0447\u0430\u0441\u043E\u0432</p></div></div></div></div>

    
    <div class="${"flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "x-circle",
    attrs: {
      class: "w-5 h-5 text-black mr-2",
      "stroke-width": "2.5"
    }
  }, {}, {})}
      ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "settings",
    attrs: {
      class: "w-5 h-5 text-black ml-2 ",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div></div>

  
  <div class="${"my-3 flex items-center justify-between"}">
    <div class="${"flex items-center"}"><img src="${"https://crafatar.com/avatars/1b42ff62-b4cb-4b8e-8fbd-efd24e70ced2"}" alt="${""}" class="${"w-8 h-8 rounded-sm"}">
      
      <div class="${"ml-2"}"><h1 class="${"text-base text-black font-medium"}">Lol</h1>
        
        
        <div class="${"flex items-stretch"}">
          <div class="${"rounded-full px-2 py-0.5 bg-yellow-400"}"><p class="${"text-xs text-white"}">\u0418\u0433\u0440\u0430\u0435\u0442 6 \u0447\u0430\u0441\u043E\u0432</p></div></div></div></div>

    
    <div class="${"flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "x-circle",
    attrs: {
      class: "w-5 h-5 text-black mr-2",
      "stroke-width": "2.5"
    }
  }, {}, {})}
      ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "settings",
    attrs: {
      class: "w-5 h-5 text-black ml-2 ",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div></div></div>`;
});
var ConsoleTile = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `
<div class="${"w-full border-b-2 border-gray-300 py-2 px-4 flex items-center justify-between"}"><h1 class="${"text-md text-black font-medium"}">\u041A\u043E\u043D\u0441\u043E\u043B\u044C</h1>

  <div class="${"flex items-center"}"><button class="${"px-3 py-1 border-2 border-black"}"><p class="${"text-xs text-black"}">\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438</p></button></div></div>


<div class="${"mt-4 px-4"}"></div>`;
});
var ControlsTile = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `
<div class="${"w-full border-b-2 border-gray-300 py-2 px-4 flex items-center justify-between"}"><h1 class="${"text-md text-black font-medium"}">\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435</h1>

  <div class="${"flex items-center"}"><button class="${"px-3 py-1 border-2 border-black"}"><p class="${"text-xs text-black"}">\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438</p></button></div></div>


<div class="${"mt-4 px-4"}">
  
  </div>`;
});
var LogsTile = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `
<div class="${"w-full border-b-2 border-gray-300 py-2 px-4 flex items-center justify-between"}"><h1 class="${"text-md text-black font-medium"}">\u041B\u043E\u0433\u0438</h1>

  <div class="${"flex items-center"}"><button class="${"px-3 py-1 border-2 border-black"}"><p class="${"text-xs text-black"}">\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438</p></button></div></div>


<div class="${"mt-4 px-4"}"></div>`;
});
function throttle(func, timeFrame) {
  let lastTime = 0;
  return function(...args) {
    let now = new Date();
    if (now - lastTime >= timeFrame) {
      func(...args);
      lastTime = now;
    }
  };
}
function getRowsCount$1(items, cols) {
  const getItemsMaxHeight = items.map((val) => {
    const item = val[cols];
    return (item && item.y) + (item && item.h) || 0;
  });
  return Math.max(...getItemsMaxHeight, 1);
}
var getColumn = (containerWidth, columns) => {
  const sortColumns = columns.slice().sort((a, b) => a[0] - b[0]);
  const breakpoint = sortColumns.find((value) => {
    const [width] = value;
    return containerWidth <= width;
  });
  if (breakpoint) {
    return breakpoint[1];
  } else {
    return sortColumns[sortColumns.length - 1][1];
  }
};
function getContainerHeight(items, yPerPx, cols) {
  return getRowsCount$1(items, cols) * yPerPx;
}
var makeMatrix$1 = (rows, cols) => Array.from(Array(rows), () => new Array(cols));
function makeMatrixFromItems$1(items, _row, _col) {
  let matrix = makeMatrix$1(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    if (value) {
      const { x, y, h } = value;
      const id = items[i].id;
      const w = Math.min(_col, value.w);
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        for (var k = x; k < x + w; k++) {
          row[k] = { ...value, id };
        }
      }
    }
  }
  return matrix;
}
function findFreeSpaceForItem$1(matrix, item) {
  const cols = matrix[0].length;
  const w = Math.min(cols, item.w);
  let xNtime = cols - w;
  let getMatrixRows = matrix.length;
  for (var i = 0; i < getMatrixRows; i++) {
    const row = matrix[i];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w);
      const empty2 = sliceA.every((val) => val === void 0);
      if (empty2) {
        const isEmpty = matrix.slice(i, i + item.h).every((a) => a.slice(j, j + w).every((n) => n === void 0));
        if (isEmpty) {
          return { y: i, x: j };
        }
      }
    }
  }
  return {
    y: getMatrixRows,
    x: 0
  };
}
function getUndefinedItems(items, col, breakpoints) {
  return items.map((value) => {
    if (!value[col]) {
      return value.id;
    }
  }).filter(Boolean);
}
function getClosestColumn(items, item, col, breakpoints) {
  return breakpoints.map(([_, column]) => item[column] && column).filter(Boolean).reduce(function(acc, value) {
    const isLower = Math.abs(value - col) < Math.abs(acc - col);
    return isLower ? value : acc;
  });
}
function specifyUndefinedColumns(items, col, breakpoints) {
  let matrix = makeMatrixFromItems$1(items, getRowsCount$1(items, col), col);
  const getUndefinedElements = getUndefinedItems(items, col);
  let newItems = [...items];
  getUndefinedElements.forEach((elementId) => {
    const getElement = items.find((item) => item.id === elementId);
    const closestColumn = getClosestColumn(items, getElement, col, breakpoints);
    const position = findFreeSpaceForItem$1(matrix, getElement[closestColumn]);
    const newItem = {
      ...getElement,
      [col]: {
        ...getElement[closestColumn],
        ...position
      }
    };
    newItems = newItems.map((value) => value.id === elementId ? newItem : value);
    matrix = makeMatrixFromItems$1(newItems, getRowsCount$1(newItems, col), col);
  });
  return newItems;
}
var css$2 = {
  code: '.svlt-grid-item.svelte-fwv2px{backface-visibility:hidden;-webkit-backface-visibility:hidden;position:absolute;touch-action:none;will-change:auto}.svlt-grid-resizer.svelte-fwv2px{bottom:0;cursor:se-resize;height:20px;position:absolute;right:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:20px}.svlt-grid-resizer.svelte-fwv2px:after{border-bottom:2px solid rgba(0,0,0,.4);border-right:2px solid rgba(0,0,0,.4);bottom:3px;content:"";height:5px;position:absolute;right:3px;width:5px}.svlt-grid-active.svelte-fwv2px{backface-visibility:hidden;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-o-backface-visibility:hidden;-ms-backface-visibility:hidden;cursor:-webkit-grabbing;cursor:grabbing;opacity:.5;position:fixed;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:3}.shadow-active.svelte-fwv2px{transition:all .2s;z-index:2}.svlt-grid-shadow.svelte-fwv2px{backface-visibility:hidden;-webkit-backface-visibility:hidden;background:red;background:pink;position:absolute;will-change:transform}',
  map: '{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<style>.svlt-grid-item{backface-visibility:hidden;-webkit-backface-visibility:hidden;position:absolute;touch-action:none;will-change:auto}.svlt-grid-resizer{bottom:0;cursor:se-resize;height:20px;position:absolute;right:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:20px}.svlt-grid-resizer:after{border-bottom:2px solid rgba(0,0,0,.4);border-right:2px solid rgba(0,0,0,.4);bottom:3px;content:\\"\\";height:5px;position:absolute;right:3px;width:5px}.svlt-grid-active{backface-visibility:hidden;-webkit-backface-visibility:hidden;-moz-backface-visibility:hidden;-o-backface-visibility:hidden;-ms-backface-visibility:hidden;cursor:-webkit-grabbing;cursor:grabbing;opacity:.5;position:fixed;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:3}.shadow-active{transition:all .2s;z-index:2}.svlt-grid-shadow{backface-visibility:hidden;-webkit-backface-visibility:hidden;background:red;background:pink;position:absolute;will-change:transform}</style>\\n\\n<div\\n  draggable={false}\\n  on:pointerdown={item && item.customDragger ? null : draggable && pointerdown}\\n  class=\\"svlt-grid-item\\"\\n  class:svlt-grid-active={active || (trans && rect)}\\n  style=\\"width: {active ? newSize.width : width}px; height:{active ? newSize.height : height}px; \\n  {active ? `transform: translate(${cordDiff.x}px, ${cordDiff.y}px);top:${rect.top}px;left:${rect.left}px;` : trans ? `transform: translate(${cordDiff.x}px, ${cordDiff.y}px); position:absolute; transition: width 0.2s, height 0.2s;` : `transition: transform 0.2s, opacity 0.2s; transform: translate(${left}px, ${top}px); `} \\">\\n  <slot movePointerDown={pointerdown} {resizePointerDown} />\\n  {#if resizable && !item.customResizer}\\n    <div class=\\"svlt-grid-resizer\\" on:pointerdown={resizePointerDown} />\\n  {/if}\\n</div>\\n\\n{#if active || trans}\\n  <div class=\\"svlt-grid-shadow shadow-active\\" style=\\"width: {shadow.w * xPerPx - gapX * 2}px; height: {shadow.h * yPerPx - gapY * 2}px; transform: translate({shadow.x * xPerPx + gapX}px, {shadow.y * yPerPx + gapY}px); \\" bind:this={shadowElement} />\\n{/if}\\n\\n<script>\\n  import { createEventDispatcher } from \\"svelte\\";\\n\\n  const dispatch = createEventDispatcher();\\n\\n  export let sensor;\\n  export let width;\\n  export let height;\\n  export let left;\\n  export let top;\\n\\n  export let resizable;\\n  export let draggable;\\n\\n  export let id;\\n  export let container;\\n\\n  export let xPerPx;\\n  export let yPerPx;\\n\\n  export let gapX;\\n  export let gapY;\\n  export let item;\\n\\n  export let max;\\n  export let min;\\n\\n  export let cols;\\n\\n  export let nativeContainer;\\n\\n  let shadowElement;\\n  let shadow = {};\\n\\n  let active = false;\\n\\n  let initX, initY;\\n\\n  let capturePos = {\\n    x: 0,\\n    y: 0,\\n  };\\n\\n  let cordDiff = { x: 0, y: 0 };\\n\\n  let newSize = { width, height };\\n  let trans = false;\\n\\n  let anima;\\n\\n  const inActivate = () => {\\n    const shadowBound = shadowElement.getBoundingClientRect();\\n    const xdragBound = rect.left + cordDiff.x;\\n    const ydragBound = rect.top + cordDiff.y;\\n\\n    cordDiff.x = shadow.x * xPerPx + gapX - (shadowBound.x - xdragBound);\\n    cordDiff.y = shadow.y * yPerPx + gapY - (shadowBound.y - ydragBound);\\n\\n    active = false;\\n    trans = true;\\n\\n    clearTimeout(anima);\\n\\n    anima = setTimeout(() => {\\n      trans = false;\\n    }, 100);\\n\\n    dispatch(\\"pointerup\\", {\\n      id,\\n    });\\n  };\\n\\n  let repaint = (cb, isPointerUp) => {\\n    dispatch(\\"repaint\\", {\\n      id,\\n      shadow,\\n      isPointerUp,\\n      onUpdate: cb,\\n    });\\n  };\\n\\n  // Autoscroll\\n  let _scrollTop = 0;\\n  let containerFrame;\\n  let rect;\\n  let scrollElement;\\n\\n  const getContainerFrame = (element) => {\\n    if (element === document.documentElement || !element) {\\n      const { height, top, right, bottom, left } = nativeContainer.getBoundingClientRect();\\n\\n      return {\\n        top: Math.max(0, top),\\n        bottom: Math.min(window.innerHeight, bottom),\\n      };\\n    }\\n\\n    return element.getBoundingClientRect();\\n  };\\n\\n  const getScroller = (element) => (!element ? document.documentElement : element);\\n\\n  const pointerdown = ({ clientX, clientY, target }) => {\\n    initX = clientX;\\n    initY = clientY;\\n\\n    capturePos = { x: left, y: top };\\n    shadow = { x: item.x, y: item.y, w: item.w, h: item.h };\\n    newSize = { width, height };\\n\\n    containerFrame = getContainerFrame(container);\\n    scrollElement = getScroller(container);\\n\\n    cordDiff = { x: 0, y: 0 };\\n    rect = target.closest(\\".svlt-grid-item\\").getBoundingClientRect();\\n\\n    active = true;\\n    trans = false;\\n    _scrollTop = scrollElement.scrollTop;\\n\\n    window.addEventListener(\\"pointermove\\", pointermove);\\n    window.addEventListener(\\"pointerup\\", pointerup);\\n  };\\n\\n  let sign = { x: 0, y: 0 };\\n  let vel = { x: 0, y: 0 };\\n  let intervalId = 0;\\n\\n  const stopAutoscroll = () => {\\n    clearInterval(intervalId);\\n    intervalId = false;\\n    sign = { x: 0, y: 0 };\\n    vel = { x: 0, y: 0 };\\n  };\\n\\n  const update = () => {\\n    const _newScrollTop = scrollElement.scrollTop - _scrollTop;\\n\\n    const boundX = capturePos.x + cordDiff.x;\\n    const boundY = capturePos.y + (cordDiff.y + _newScrollTop);\\n\\n    let gridX = Math.round(boundX / xPerPx);\\n    let gridY = Math.round(boundY / yPerPx);\\n\\n    shadow.x = Math.max(Math.min(gridX, cols - shadow.w), 0);\\n    shadow.y = Math.max(gridY, 0);\\n\\n    if (max.y) {\\n      shadow.y = Math.min(shadow.y, max.y);\\n    }\\n\\n    repaint();\\n  };\\n\\n  const pointermove = (event) => {\\n    event.preventDefault();\\n    event.stopPropagation();\\n    event.stopImmediatePropagation();\\n\\n    const { clientX, clientY } = event;\\n    cordDiff = { x: clientX - initX, y: clientY - initY };\\n\\n    const Y_SENSOR = sensor;\\n\\n    let velocityTop = Math.max(0, (containerFrame.top + Y_SENSOR - clientY) / Y_SENSOR);\\n    let velocityBottom = Math.max(0, (clientY - (containerFrame.bottom - Y_SENSOR)) / Y_SENSOR);\\n\\n    const topSensor = velocityTop > 0 && velocityBottom === 0;\\n    const bottomSensor = velocityBottom > 0 && velocityTop === 0;\\n\\n    sign.y = topSensor ? -1 : bottomSensor ? 1 : 0;\\n    vel.y = sign.y === -1 ? velocityTop : velocityBottom;\\n\\n    if (vel.y > 0) {\\n      if (!intervalId) {\\n        // Start scrolling\\n        // TODO Use requestAnimationFrame\\n        intervalId = setInterval(() => {\\n          scrollElement.scrollTop += 2 * (vel.y + Math.sign(vel.y)) * sign.y;\\n          update();\\n        }, 10);\\n      }\\n    } else if (intervalId) {\\n      stopAutoscroll();\\n    } else {\\n      update();\\n    }\\n  };\\n\\n  const pointerup = (e) => {\\n    stopAutoscroll();\\n\\n    window.removeEventListener(\\"pointerdown\\", pointerdown);\\n    window.removeEventListener(\\"pointermove\\", pointermove);\\n    window.removeEventListener(\\"pointerup\\", pointerup);\\n    repaint(inActivate, true);\\n  };\\n\\n  // Resize\\n\\n  let resizeInitPos = { x: 0, y: 0 };\\n  let initSize = { width: 0, height: 0 };\\n\\n  const resizePointerDown = (e) => {\\n    e.stopPropagation();\\n    const { pageX, pageY } = e;\\n\\n    resizeInitPos = { x: pageX, y: pageY };\\n    initSize = { width, height };\\n\\n    cordDiff = { x: 0, y: 0 };\\n    rect = e.target.closest(\\".svlt-grid-item\\").getBoundingClientRect();\\n    newSize = { width, height };\\n\\n    active = true;\\n    trans = false;\\n    shadow = { x: item.x, y: item.y, w: item.w, h: item.h };\\n\\n    containerFrame = getContainerFrame(container);\\n    scrollElement = getScroller(container);\\n\\n    window.addEventListener(\\"pointermove\\", resizePointerMove);\\n    window.addEventListener(\\"pointerup\\", resizePointerUp);\\n  };\\n\\n  const resizePointerMove = ({ pageX, pageY }) => {\\n    newSize.width = initSize.width + pageX - resizeInitPos.x;\\n    newSize.height = initSize.height + pageY - resizeInitPos.y;\\n\\n    // Get max col number\\n    let maxWidth = cols - shadow.x;\\n    maxWidth = Math.min(max.w, maxWidth) || maxWidth;\\n\\n    // Limit bound\\n    newSize.width = Math.max(Math.min(newSize.width, maxWidth * xPerPx - gapX * 2), min.w * xPerPx - gapX * 2);\\n\\n    newSize.height = Math.max(newSize.height, min.h * yPerPx - gapY * 2);\\n\\n    if (max.h) {\\n      newSize.height = Math.min(newSize.height, max.h * yPerPx - gapY * 2);\\n    }\\n    // Limit col & row\\n    shadow.w = Math.round((newSize.width + gapX * 2) / xPerPx);\\n    shadow.h = Math.round((newSize.height + gapY * 2) / yPerPx);\\n\\n    repaint();\\n  };\\n\\n  const resizePointerUp = (e) => {\\n    e.stopPropagation();\\n\\n    repaint(inActivate, true);\\n\\n    window.removeEventListener(\\"pointermove\\", resizePointerMove);\\n    window.removeEventListener(\\"pointerup\\", resizePointerUp);\\n  };\\n<\/script>\\n"],"names":[],"mappings":"AAAO,6BAAe,CAAC,oBAAoB,MAAM,CAAC,4BAA4B,MAAM,CAAC,SAAS,QAAQ,CAAC,aAAa,IAAI,CAAC,YAAY,IAAI,CAAC,gCAAkB,CAAC,OAAO,CAAC,CAAC,OAAO,SAAS,CAAC,OAAO,IAAI,CAAC,SAAS,QAAQ,CAAC,MAAM,CAAC,CAAC,oBAAoB,IAAI,CAAC,iBAAiB,IAAI,CAAC,gBAAgB,IAAI,CAAC,YAAY,IAAI,CAAC,MAAM,IAAI,CAAC,gCAAkB,MAAM,CAAC,cAAc,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,aAAa,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC,OAAO,GAAG,CAAC,SAAS,QAAQ,CAAC,MAAM,GAAG,CAAC,MAAM,GAAG,CAAC,+BAAiB,CAAC,oBAAoB,MAAM,CAAC,4BAA4B,MAAM,CAAC,yBAAyB,MAAM,CAAC,uBAAuB,MAAM,CAAC,wBAAwB,MAAM,CAAC,OAAO,gBAAgB,CAAC,OAAO,QAAQ,CAAC,QAAQ,EAAE,CAAC,SAAS,KAAK,CAAC,oBAAoB,IAAI,CAAC,iBAAiB,IAAI,CAAC,gBAAgB,IAAI,CAAC,YAAY,IAAI,CAAC,QAAQ,CAAC,CAAC,4BAAc,CAAC,WAAW,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,+BAAiB,CAAC,oBAAoB,MAAM,CAAC,4BAA4B,MAAM,CAAC,WAAW,GAAG,CAAC,WAAW,IAAI,CAAC,SAAS,QAAQ,CAAC,YAAY,SAAS,CAAC"}'
};
var MoveResize = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const dispatch = createEventDispatcher();
  let { sensor } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { left } = $$props;
  let { top } = $$props;
  let { resizable } = $$props;
  let { draggable } = $$props;
  let { id } = $$props;
  let { container } = $$props;
  let { xPerPx } = $$props;
  let { yPerPx } = $$props;
  let { gapX } = $$props;
  let { gapY } = $$props;
  let { item } = $$props;
  let { max } = $$props;
  let { min } = $$props;
  let { cols } = $$props;
  let { nativeContainer } = $$props;
  let shadowElement;
  let shadow = {};
  let active = false;
  let initX, initY;
  let capturePos = { x: 0, y: 0 };
  let cordDiff = { x: 0, y: 0 };
  let newSize = { width, height };
  let trans = false;
  let anima;
  const inActivate = () => {
    const shadowBound = shadowElement.getBoundingClientRect();
    const xdragBound = rect.left + cordDiff.x;
    const ydragBound = rect.top + cordDiff.y;
    cordDiff.x = shadow.x * xPerPx + gapX - (shadowBound.x - xdragBound);
    cordDiff.y = shadow.y * yPerPx + gapY - (shadowBound.y - ydragBound);
    active = false;
    trans = true;
    clearTimeout(anima);
    anima = setTimeout(() => {
      trans = false;
    }, 100);
    dispatch("pointerup", { id });
  };
  let repaint = (cb, isPointerUp) => {
    dispatch("repaint", { id, shadow, isPointerUp, onUpdate: cb });
  };
  let _scrollTop = 0;
  let containerFrame;
  let rect;
  let scrollElement;
  const getContainerFrame = (element) => {
    if (element === document.documentElement || !element) {
      const { height: height2, top: top2, right, bottom, left: left2 } = nativeContainer.getBoundingClientRect();
      return {
        top: Math.max(0, top2),
        bottom: Math.min(window.innerHeight, bottom)
      };
    }
    return element.getBoundingClientRect();
  };
  const getScroller = (element) => !element ? document.documentElement : element;
  const pointerdown = ({ clientX, clientY, target }) => {
    initX = clientX;
    initY = clientY;
    capturePos = { x: left, y: top };
    shadow = {
      x: item.x,
      y: item.y,
      w: item.w,
      h: item.h
    };
    newSize = { width, height };
    containerFrame = getContainerFrame(container);
    scrollElement = getScroller(container);
    cordDiff = { x: 0, y: 0 };
    rect = target.closest(".svlt-grid-item").getBoundingClientRect();
    active = true;
    trans = false;
    _scrollTop = scrollElement.scrollTop;
    window.addEventListener("pointermove", pointermove);
    window.addEventListener("pointerup", pointerup);
  };
  let sign = { x: 0, y: 0 };
  let vel = { x: 0, y: 0 };
  let intervalId = 0;
  const stopAutoscroll = () => {
    clearInterval(intervalId);
    intervalId = false;
    sign = { x: 0, y: 0 };
    vel = { x: 0, y: 0 };
  };
  const update = () => {
    const _newScrollTop = scrollElement.scrollTop - _scrollTop;
    const boundX = capturePos.x + cordDiff.x;
    const boundY = capturePos.y + (cordDiff.y + _newScrollTop);
    let gridX = Math.round(boundX / xPerPx);
    let gridY = Math.round(boundY / yPerPx);
    shadow.x = Math.max(Math.min(gridX, cols - shadow.w), 0);
    shadow.y = Math.max(gridY, 0);
    if (max.y) {
      shadow.y = Math.min(shadow.y, max.y);
    }
    repaint();
  };
  const pointermove = (event) => {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    const { clientX, clientY } = event;
    cordDiff = { x: clientX - initX, y: clientY - initY };
    const Y_SENSOR = sensor;
    let velocityTop = Math.max(0, (containerFrame.top + Y_SENSOR - clientY) / Y_SENSOR);
    let velocityBottom = Math.max(0, (clientY - (containerFrame.bottom - Y_SENSOR)) / Y_SENSOR);
    const topSensor = velocityTop > 0 && velocityBottom === 0;
    const bottomSensor = velocityBottom > 0 && velocityTop === 0;
    sign.y = topSensor ? -1 : bottomSensor ? 1 : 0;
    vel.y = sign.y === -1 ? velocityTop : velocityBottom;
    if (vel.y > 0) {
      if (!intervalId) {
        intervalId = setInterval(() => {
          scrollElement.scrollTop += 2 * (vel.y + Math.sign(vel.y)) * sign.y;
          update();
        }, 10);
      }
    } else if (intervalId) {
      stopAutoscroll();
    } else {
      update();
    }
  };
  const pointerup = (e) => {
    stopAutoscroll();
    window.removeEventListener("pointerdown", pointerdown);
    window.removeEventListener("pointermove", pointermove);
    window.removeEventListener("pointerup", pointerup);
    repaint(inActivate, true);
  };
  let resizeInitPos = { x: 0, y: 0 };
  let initSize = { width: 0, height: 0 };
  const resizePointerDown = (e) => {
    e.stopPropagation();
    const { pageX, pageY } = e;
    resizeInitPos = { x: pageX, y: pageY };
    initSize = { width, height };
    cordDiff = { x: 0, y: 0 };
    rect = e.target.closest(".svlt-grid-item").getBoundingClientRect();
    newSize = { width, height };
    active = true;
    trans = false;
    shadow = {
      x: item.x,
      y: item.y,
      w: item.w,
      h: item.h
    };
    containerFrame = getContainerFrame(container);
    scrollElement = getScroller(container);
    window.addEventListener("pointermove", resizePointerMove);
    window.addEventListener("pointerup", resizePointerUp);
  };
  const resizePointerMove = ({ pageX, pageY }) => {
    newSize.width = initSize.width + pageX - resizeInitPos.x;
    newSize.height = initSize.height + pageY - resizeInitPos.y;
    let maxWidth = cols - shadow.x;
    maxWidth = Math.min(max.w, maxWidth) || maxWidth;
    newSize.width = Math.max(Math.min(newSize.width, maxWidth * xPerPx - gapX * 2), min.w * xPerPx - gapX * 2);
    newSize.height = Math.max(newSize.height, min.h * yPerPx - gapY * 2);
    if (max.h) {
      newSize.height = Math.min(newSize.height, max.h * yPerPx - gapY * 2);
    }
    shadow.w = Math.round((newSize.width + gapX * 2) / xPerPx);
    shadow.h = Math.round((newSize.height + gapY * 2) / yPerPx);
    repaint();
  };
  const resizePointerUp = (e) => {
    e.stopPropagation();
    repaint(inActivate, true);
    window.removeEventListener("pointermove", resizePointerMove);
    window.removeEventListener("pointerup", resizePointerUp);
  };
  if ($$props.sensor === void 0 && $$bindings.sensor && sensor !== void 0)
    $$bindings.sensor(sensor);
  if ($$props.width === void 0 && $$bindings.width && width !== void 0)
    $$bindings.width(width);
  if ($$props.height === void 0 && $$bindings.height && height !== void 0)
    $$bindings.height(height);
  if ($$props.left === void 0 && $$bindings.left && left !== void 0)
    $$bindings.left(left);
  if ($$props.top === void 0 && $$bindings.top && top !== void 0)
    $$bindings.top(top);
  if ($$props.resizable === void 0 && $$bindings.resizable && resizable !== void 0)
    $$bindings.resizable(resizable);
  if ($$props.draggable === void 0 && $$bindings.draggable && draggable !== void 0)
    $$bindings.draggable(draggable);
  if ($$props.id === void 0 && $$bindings.id && id !== void 0)
    $$bindings.id(id);
  if ($$props.container === void 0 && $$bindings.container && container !== void 0)
    $$bindings.container(container);
  if ($$props.xPerPx === void 0 && $$bindings.xPerPx && xPerPx !== void 0)
    $$bindings.xPerPx(xPerPx);
  if ($$props.yPerPx === void 0 && $$bindings.yPerPx && yPerPx !== void 0)
    $$bindings.yPerPx(yPerPx);
  if ($$props.gapX === void 0 && $$bindings.gapX && gapX !== void 0)
    $$bindings.gapX(gapX);
  if ($$props.gapY === void 0 && $$bindings.gapY && gapY !== void 0)
    $$bindings.gapY(gapY);
  if ($$props.item === void 0 && $$bindings.item && item !== void 0)
    $$bindings.item(item);
  if ($$props.max === void 0 && $$bindings.max && max !== void 0)
    $$bindings.max(max);
  if ($$props.min === void 0 && $$bindings.min && min !== void 0)
    $$bindings.min(min);
  if ($$props.cols === void 0 && $$bindings.cols && cols !== void 0)
    $$bindings.cols(cols);
  if ($$props.nativeContainer === void 0 && $$bindings.nativeContainer && nativeContainer !== void 0)
    $$bindings.nativeContainer(nativeContainer);
  $$result.css.add(css$2);
  return `<div${add_attribute("draggable", false, 0)} class="${[
    "svlt-grid-item svelte-fwv2px",
    active || trans && rect ? "svlt-grid-active" : ""
  ].join(" ").trim()}" style="${"width: " + escape2(active ? newSize.width : width) + "px; height:" + escape2(active ? newSize.height : height) + "px; \n  " + escape2(active ? `transform: translate(${cordDiff.x}px, ${cordDiff.y}px);top:${rect.top}px;left:${rect.left}px;` : trans ? `transform: translate(${cordDiff.x}px, ${cordDiff.y}px); position:absolute; transition: width 0.2s, height 0.2s;` : `transition: transform 0.2s, opacity 0.2s; transform: translate(${left}px, ${top}px); `) + " "}">${slots.default ? slots.default({
    movePointerDown: pointerdown,
    resizePointerDown
  }) : ``}
  ${resizable && !item.customResizer ? `<div class="${"svlt-grid-resizer svelte-fwv2px"}"></div>` : ``}</div>

${active || trans ? `<div class="${"svlt-grid-shadow shadow-active svelte-fwv2px"}" style="${"width: " + escape2(shadow.w * xPerPx - gapX * 2) + "px; height: " + escape2(shadow.h * yPerPx - gapY * 2) + "px; transform: translate(" + escape2(shadow.x * xPerPx + gapX) + "px, " + escape2(shadow.y * yPerPx + gapY) + "px); "}"${add_attribute("this", shadowElement, 1)}></div>` : ``}`;
});
var css$1 = {
  code: ".svlt-grid-container.svelte-10ksjm1{position:relative;width:100%}",
  map: '{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<style>.svlt-grid-container{position:relative;width:100%}</style>\\n\\n<div class=\\"svlt-grid-container\\" style=\\"height: {containerHeight}px\\" bind:this={container}>\\n  {#if xPerPx || !fastStart}\\n    {#each items as item, i (item.id)}\\n      <MoveResize\\n        on:repaint={handleRepaint}\\n        on:pointerup={pointerup}\\n        id={item.id}\\n        resizable={item[getComputedCols] && item[getComputedCols].resizable}\\n        draggable={item[getComputedCols] && item[getComputedCols].draggable}\\n        {xPerPx}\\n        {yPerPx}\\n        width={Math.min(getComputedCols, item[getComputedCols] && item[getComputedCols].w) * xPerPx - gapX * 2}\\n        height={(item[getComputedCols] && item[getComputedCols].h) * yPerPx - gapY * 2}\\n        top={(item[getComputedCols] && item[getComputedCols].y) * yPerPx + gapY}\\n        left={(item[getComputedCols] && item[getComputedCols].x) * xPerPx + gapX}\\n        item={item[getComputedCols]}\\n        min={item[getComputedCols] && item[getComputedCols].min}\\n        max={item[getComputedCols] && item[getComputedCols].max}\\n        cols={getComputedCols}\\n        {gapX}\\n        {gapY}\\n        {sensor}\\n        container={scroller}\\n        nativeContainer={container}\\n        let:resizePointerDown\\n        let:movePointerDown>\\n        {#if item[getComputedCols]}\\n          <slot {movePointerDown} {resizePointerDown} dataItem={item} item={item[getComputedCols]} index={i} />\\n        {/if}\\n      </MoveResize>\\n    {/each}\\n  {/if}\\n</div>\\n\\n<script>\\n  import { getContainerHeight } from \\"./utils/container.js\\";\\n  import { moveItemsAroundItem, moveItem, getItemById, specifyUndefinedColumns, findFreeSpaceForItem } from \\"./utils/item.js\\";\\n  import { onMount, createEventDispatcher } from \\"svelte\\";\\n  import { getColumn, getRowsCount, throttle } from \\"./utils/other.js\\";\\n  import { makeMatrixFromItems } from \\"./utils/matrix.js\\";\\n  import MoveResize from \\"./MoveResize/index.svelte\\";\\n\\n  const dispatch = createEventDispatcher();\\n\\n  export let fillSpace = false;\\n  export let items;\\n  export let rowHeight;\\n  export let cols;\\n  export let gap = [10, 10];\\n  export let fastStart = false;\\n  export let throttleUpdate = 100;\\n  export let throttleResize = 100;\\n\\n  export let scroller = undefined;\\n  export let sensor = 20;\\n\\n  let getComputedCols;\\n\\n  let container;\\n\\n  $: [gapX, gapY] = gap;\\n\\n  let xPerPx = 0;\\n  let yPerPx = rowHeight;\\n\\n  let documentWidth;\\n\\n  let containerWidth;\\n\\n  $: containerHeight = getContainerHeight(items, yPerPx, getComputedCols);\\n\\n  const pointerup = (ev) => {\\n    dispatch(\\"pointerup\\", {\\n      id: ev.detail.id,\\n      cols: getComputedCols,\\n    });\\n  };\\n\\n  const onResize = throttle(() => {\\n    items = specifyUndefinedColumns(items, getComputedCols, cols);\\n    dispatch(\\"resize\\", {\\n      cols: getComputedCols,\\n      xPerPx,\\n      yPerPx,\\n      width: containerWidth,\\n    });\\n  }, throttleUpdate);\\n\\n  onMount(() => {\\n    const sizeObserver = new ResizeObserver((entries) => {\\n      let width = entries[0].contentRect.width;\\n\\n      if (width === containerWidth) return;\\n\\n      getComputedCols = getColumn(width, cols);\\n\\n      xPerPx = width / getComputedCols;\\n\\n      if (!containerWidth) {\\n        items = specifyUndefinedColumns(items, getComputedCols, cols);\\n\\n        dispatch(\\"mount\\", {\\n          cols: getComputedCols,\\n          xPerPx,\\n          yPerPx, // same as rowHeight\\n        });\\n      } else {\\n        onResize();\\n      }\\n\\n      containerWidth = width;\\n    });\\n\\n    sizeObserver.observe(container);\\n\\n    return () => sizeObserver.disconnect();\\n  });\\n\\n  const updateMatrix = ({ detail }) => {\\n    let activeItem = getItemById(detail.id, items);\\n\\n    if (activeItem) {\\n      activeItem = {\\n        ...activeItem,\\n        [getComputedCols]: {\\n          ...activeItem[getComputedCols],\\n          ...detail.shadow,\\n        },\\n      };\\n\\n      if (fillSpace) {\\n        items = moveItemsAroundItem(activeItem, items, getComputedCols, getItemById(detail.id, items));\\n      } else {\\n        items = moveItem(activeItem, items, getComputedCols, getItemById(detail.id, items));\\n      }\\n\\n      if (detail.onUpdate) detail.onUpdate();\\n\\n      dispatch(\\"change\\", {\\n        unsafeItem: activeItem,\\n        id: activeItem.id,\\n        cols: getComputedCols,\\n      });\\n    }\\n  };\\n\\n  const throttleMatrix = throttle(updateMatrix, throttleResize);\\n\\n  const handleRepaint = ({ detail }) => {\\n    if (!detail.isPointerUp) {\\n      throttleMatrix({ detail });\\n    } else {\\n      updateMatrix({ detail });\\n    }\\n  };\\n<\/script>\\n"],"names":[],"mappings":"AAAO,mCAAoB,CAAC,SAAS,QAAQ,CAAC,MAAM,IAAI,CAAC"}'
};
var Src = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let gapX;
  let gapY;
  let containerHeight;
  const dispatch = createEventDispatcher();
  let { fillSpace = false } = $$props;
  let { items } = $$props;
  let { rowHeight } = $$props;
  let { cols } = $$props;
  let { gap = [10, 10] } = $$props;
  let { fastStart = false } = $$props;
  let { throttleUpdate = 100 } = $$props;
  let { throttleResize = 100 } = $$props;
  let { scroller = void 0 } = $$props;
  let { sensor = 20 } = $$props;
  let getComputedCols;
  let container;
  let xPerPx = 0;
  let yPerPx = rowHeight;
  let containerWidth;
  const onResize = throttle(() => {
    items = specifyUndefinedColumns(items, getComputedCols, cols);
    dispatch("resize", {
      cols: getComputedCols,
      xPerPx,
      yPerPx,
      width: containerWidth
    });
  }, throttleUpdate);
  onMount(() => {
    const sizeObserver = new ResizeObserver((entries) => {
      let width = entries[0].contentRect.width;
      if (width === containerWidth)
        return;
      getComputedCols = getColumn(width, cols);
      xPerPx = width / getComputedCols;
      if (!containerWidth) {
        items = specifyUndefinedColumns(items, getComputedCols, cols);
        dispatch("mount", {
          cols: getComputedCols,
          xPerPx,
          yPerPx
        });
      } else {
        onResize();
      }
      containerWidth = width;
    });
    sizeObserver.observe(container);
    return () => sizeObserver.disconnect();
  });
  if ($$props.fillSpace === void 0 && $$bindings.fillSpace && fillSpace !== void 0)
    $$bindings.fillSpace(fillSpace);
  if ($$props.items === void 0 && $$bindings.items && items !== void 0)
    $$bindings.items(items);
  if ($$props.rowHeight === void 0 && $$bindings.rowHeight && rowHeight !== void 0)
    $$bindings.rowHeight(rowHeight);
  if ($$props.cols === void 0 && $$bindings.cols && cols !== void 0)
    $$bindings.cols(cols);
  if ($$props.gap === void 0 && $$bindings.gap && gap !== void 0)
    $$bindings.gap(gap);
  if ($$props.fastStart === void 0 && $$bindings.fastStart && fastStart !== void 0)
    $$bindings.fastStart(fastStart);
  if ($$props.throttleUpdate === void 0 && $$bindings.throttleUpdate && throttleUpdate !== void 0)
    $$bindings.throttleUpdate(throttleUpdate);
  if ($$props.throttleResize === void 0 && $$bindings.throttleResize && throttleResize !== void 0)
    $$bindings.throttleResize(throttleResize);
  if ($$props.scroller === void 0 && $$bindings.scroller && scroller !== void 0)
    $$bindings.scroller(scroller);
  if ($$props.sensor === void 0 && $$bindings.sensor && sensor !== void 0)
    $$bindings.sensor(sensor);
  $$result.css.add(css$1);
  [gapX, gapY] = gap;
  containerHeight = getContainerHeight(items, yPerPx, getComputedCols);
  return `<div class="${"svlt-grid-container svelte-10ksjm1"}" style="${"height: " + escape2(containerHeight) + "px"}"${add_attribute("this", container, 1)}>${xPerPx || !fastStart ? `${each(items, (item, i) => `${validate_component(MoveResize, "MoveResize").$$render($$result, {
    id: item.id,
    resizable: item[getComputedCols] && item[getComputedCols].resizable,
    draggable: item[getComputedCols] && item[getComputedCols].draggable,
    xPerPx,
    yPerPx,
    width: Math.min(getComputedCols, item[getComputedCols] && item[getComputedCols].w) * xPerPx - gapX * 2,
    height: (item[getComputedCols] && item[getComputedCols].h) * yPerPx - gapY * 2,
    top: (item[getComputedCols] && item[getComputedCols].y) * yPerPx + gapY,
    left: (item[getComputedCols] && item[getComputedCols].x) * xPerPx + gapX,
    item: item[getComputedCols],
    min: item[getComputedCols] && item[getComputedCols].min,
    max: item[getComputedCols] && item[getComputedCols].max,
    cols: getComputedCols,
    gapX,
    gapY,
    sensor,
    container: scroller,
    nativeContainer: container
  }, {}, {
    default: ({ resizePointerDown, movePointerDown }) => `${item[getComputedCols] ? `${slots.default ? slots.default({
      movePointerDown,
      resizePointerDown,
      dataItem: item,
      item: item[getComputedCols],
      index: i
    }) : ``}` : ``}
      `
  })}`)}` : ``}
</div>`;
});
function getRowsCount(items, cols) {
  const getItemsMaxHeight = items.map((val) => {
    const item = val[cols];
    return (item && item.y) + (item && item.h) || 0;
  });
  return Math.max(...getItemsMaxHeight, 1);
}
var makeMatrix = (rows, cols) => Array.from(Array(rows), () => new Array(cols));
function makeMatrixFromItems(items, _row, _col) {
  let matrix = makeMatrix(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    if (value) {
      const { x, y, h } = value;
      const id = items[i].id;
      const w = Math.min(_col, value.w);
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        for (var k = x; k < x + w; k++) {
          row[k] = { ...value, id };
        }
      }
    }
  }
  return matrix;
}
function findCloseBlocks(items, matrix, curObject) {
  const { h, x, y } = curObject;
  const w = Math.min(matrix[0].length, curObject.w);
  const tempR = matrix.slice(y, y + h);
  let result = [];
  for (var i = 0; i < tempR.length; i++) {
    let tempA = tempR[i].slice(x, x + w);
    result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
  }
  return [...new Set(result)];
}
function makeMatrixFromItemsIgnore(items, ignoreList, _row, _col) {
  let matrix = makeMatrix(_row, _col);
  for (var i = 0; i < items.length; i++) {
    const value = items[i][_col];
    const id = items[i].id;
    const { x, y, h } = value;
    const w = Math.min(_col, value.w);
    if (ignoreList.indexOf(id) === -1) {
      for (var j = y; j < y + h; j++) {
        const row = matrix[j];
        if (row) {
          for (var k = x; k < x + w; k++) {
            row[k] = { ...value, id };
          }
        }
      }
    }
  }
  return matrix;
}
function findItemsById(closeBlocks, items) {
  return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
}
function findFreeSpaceForItem(matrix, item) {
  const cols = matrix[0].length;
  const w = Math.min(cols, item.w);
  let xNtime = cols - w;
  let getMatrixRows = matrix.length;
  for (var i = 0; i < getMatrixRows; i++) {
    const row = matrix[i];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w);
      const empty2 = sliceA.every((val) => val === void 0);
      if (empty2) {
        const isEmpty = matrix.slice(i, i + item.h).every((a) => a.slice(j, j + w).every((n) => n === void 0));
        if (isEmpty) {
          return { y: i, x: j };
        }
      }
    }
  }
  return {
    y: getMatrixRows,
    x: 0
  };
}
var getItem = (item, col) => {
  return { ...item[col], id: item.id };
};
var updateItem = (elements, active, position, col) => {
  return elements.map((value) => {
    if (value.id === active.id) {
      return { ...value, [col]: { ...value[col], ...position } };
    }
    return value;
  });
};
function moveItem(active, items, cols, original) {
  const item = getItem(active, cols);
  let matrix = makeMatrixFromItemsIgnore(items, [item.id], getRowsCount(items, cols), cols);
  const closeBlocks = findCloseBlocks(items, matrix, item);
  let closeObj = findItemsById(closeBlocks, items);
  const fixed = closeObj.find((value) => value[cols].fixed);
  if (fixed)
    return items;
  items = updateItem(items, active, item, cols);
  matrix = makeMatrixFromItemsIgnore(items, closeBlocks, getRowsCount(items, cols), cols);
  let tempItems = items;
  let tempCloseBlocks = closeBlocks;
  let exclude = [];
  closeObj.forEach((item2) => {
    let position = findFreeSpaceForItem(matrix, item2[cols]);
    exclude.push(item2.id);
    tempItems = updateItem(tempItems, item2, position, cols);
    let getIgnoreItems = tempCloseBlocks.filter((value) => exclude.indexOf(value) === -1);
    matrix = makeMatrixFromItemsIgnore(tempItems, getIgnoreItems, getRowsCount(tempItems, cols), cols);
  });
  return tempItems;
}
function normalize2(items, col) {
  let result = items.slice();
  result.forEach((value) => {
    const getItem2 = value[col];
    if (!getItem2.static) {
      result = moveItem(getItem2, result, col);
    }
  });
  return result;
}
function adjust(items, col) {
  let matrix = makeMatrix(getRowsCount(items, col), col);
  let res = [];
  items.forEach((item) => {
    let position = findFreeSpaceForItem(matrix, item[col]);
    res.push({
      ...item,
      [col]: {
        ...item[col],
        ...position
      }
    });
    matrix = makeMatrixFromItems(res, getRowsCount(res, col), col);
  });
  return res;
}
function makeItem(item) {
  const { min = { w: 1, h: 1 }, max } = item;
  return {
    fixed: false,
    resizable: !item.fixed,
    draggable: !item.fixed,
    customDragger: false,
    customResizer: false,
    min: {
      w: Math.max(1, min.w),
      h: Math.max(1, min.h)
    },
    max: { ...max },
    ...item
  };
}
var gridHelp = {
  normalize(items, col) {
    getRowsCount(items, col);
    return normalize2(items, col);
  },
  adjust(items, col) {
    return adjust(items, col);
  },
  item(obj) {
    return makeItem(obj);
  },
  findSpace(item, items, cols) {
    let matrix = makeMatrixFromItems(items, getRowsCount(items, cols), cols);
    let position = findFreeSpaceForItem(matrix, item[cols]);
    return position;
  }
};
var css = {
  code: ".spinner.svelte-135b93{animation:svelte-135b93-spin 1s ease-in-out infinite;-webkit-animation:svelte-135b93-spin 1s ease-in-out infinite;border-radius:50%;display:inline-block}@keyframes svelte-135b93-spin{to{-webkit-transform:rotate(1turn)}}@-webkit-keyframes svelte-135b93-spin{to{-webkit-transform:rotate(1turn)}}",
  map: '{"version":3,"file":"RadialSpinner.svelte","sources":["RadialSpinner.svelte"],"sourcesContent":["<script>\\n  export let size = 30;\\n  export let color = \\"#fff\\";\\n\\n  // Let\'s prepare our style variable\\n  let style =\\n    // Border styles and colors\\n    `border: ${size/6}px solid ${color};` +\\n    `border-top-color: transparent;` +\\n    \\n    // Spinner\'s width and height\\n    `width: ${size}px;` +\\n    `height: ${size}px`;\\n<\/script>\\n\\n<div style=\\"{style}\\" class=\\"spinner\\">\\n</div>\\n\\n<style>.spinner{animation:spin 1s ease-in-out infinite;-webkit-animation:spin 1s ease-in-out infinite;border-radius:50%;display:inline-block}@keyframes spin{to{-webkit-transform:rotate(1turn)}}@-webkit-keyframes spin{to{-webkit-transform:rotate(1turn)}}</style>"],"names":[],"mappings":"AAkBO,sBAAQ,CAAC,UAAU,kBAAI,CAAC,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,kBAAkB,kBAAI,CAAC,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,cAAc,GAAG,CAAC,QAAQ,YAAY,CAAC,WAAW,kBAAI,CAAC,EAAE,CAAC,kBAAkB,OAAO,KAAK,CAAC,CAAC,CAAC,mBAAmB,kBAAI,CAAC,EAAE,CAAC,kBAAkB,OAAO,KAAK,CAAC,CAAC,CAAC"}'
};
var RadialSpinner = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { size = 30 } = $$props;
  let { color = "#fff" } = $$props;
  let style = `border: ${size / 6}px solid ${color};border-top-color: transparent;width: ${size}px;height: ${size}px`;
  if ($$props.size === void 0 && $$bindings.size && size !== void 0)
    $$bindings.size(size);
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  $$result.css.add(css);
  return `<div${add_attribute("style", style, 0)} class="${"spinner svelte-135b93"}"></div>`;
});
var COLS = 6;
function makeid(length) {
  var result = "";
  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  var charactersLength = characters.length;
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
var DashboardTiles = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $ProjectDashboard, $$unsubscribe_ProjectDashboard;
  let $CurrentProject, $$unsubscribe_CurrentProject;
  let $$unsubscribe_page;
  $$unsubscribe_ProjectDashboard = subscribe(ProjectDashboard, (value) => $ProjectDashboard = value);
  $$unsubscribe_CurrentProject = subscribe(CurrentProject, (value) => $CurrentProject = value);
  $$unsubscribe_page = subscribe(page, (value) => value);
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function syncWidgets() {
    return __awaiter(this, void 0, void 0, function* () {
      const serialized = gridItems.map((item) => {
        var _a, _b, _c, _d;
        return {
          type: item.type,
          enabled: true,
          x: (_a = item[COLS].x) !== null && _a !== void 0 ? _a : 0,
          y: (_b = item[COLS].y) !== null && _b !== void 0 ? _b : 0,
          width: (_c = item[COLS].w) !== null && _c !== void 0 ? _c : 2,
          height: (_d = item[COLS].h) !== null && _d !== void 0 ? _d : 2
        };
      });
      yield ProjectDashboard.updateLayout(String($ProjectDashboard._id), serialized);
    });
  }
  const unsubscribe = CurrentProject.subscribe(({ project }) => __awaiter(void 0, void 0, void 0, function* () {
    if (project._id) {
      yield ProjectDashboard.fetch(String($CurrentProject.project._id));
      const widgets = $ProjectDashboard.widgets.filter((widget) => widget.enabled).map((widget) => {
        return {
          [COLS]: gridHelp.item({
            x: widget.x,
            y: widget.y,
            w: widget.width,
            h: widget.height
          }),
          id: makeid(4),
          type: widget.type
        };
      });
      if ($ProjectDashboard.widgets.filter((widget) => widget.x == 0 && widget.y == 0).length == $ProjectDashboard.widgets.length) {
        gridItems = gridHelp.adjust(widgets, COLS);
        syncWidgets();
      } else {
        gridItems = widgets;
      }
      loading = false;
      unsubscribe();
    }
  }));
  let loading = true;
  let gridItems = [];
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `<section class="${"w-full h-1/2 relative mb-8"}">${loading ? `<div class="${"w-full h-full flex justify-center items-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 15 }, {}, {})}</div>` : `${gridItems.length > 0 ? `
      ${validate_component(Src, "Grid").$$render($$result, {
      rowHeight: 100,
      cols: [[, 6]],
      fillSpace: true,
      items: gridItems
    }, {
      items: ($$value) => {
        gridItems = $$value;
        $$settled = false;
      }
    }, {
      default: ({ item, dataItem }) => `<div class="${"w-full h-full bg-gray-200 rounded-sm"}">
          ${dataItem.type == "PLAYERS" ? `${validate_component(PlayersTile, "PlayersTile").$$render($$result, {}, {}, {})}
          ` : `${dataItem.type == "CONTROLS" ? `${validate_component(ControlsTile, "ControlsTile").$$render($$result, {}, {}, {})}
          ` : `${dataItem.type == "CONSOLE" ? `${validate_component(ConsoleTile, "ConsoleTile").$$render($$result, {}, {}, {})}` : ``}`}`}</div>`
    })}` : `<div class="${"w-full h-full flex justify-center items-center"}"><div class="${"w-1/3 p-4 bg-gray-100 rounded-sm text-center"}">
          <h1 class="${"text-xl text-black front-medium"}">\u041F\u0443\u0441\u0442\u043E</h1>

          
          <p class="${"text-sm text-black opacity-80 mt-1.5"}">Lorem ipsum dolor sit amet consectetur adipisicing elit. Numquam nobis at nulla sed harum quaerat!</p>

          
          <button class="${"w-full bg-black mt-6 py-2 px-4 flex items-center justify-start"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "external-link",
      attrs: {
        class: "w-4 h-4 text-white",
        "stroke-width": "2.5"
      }
    }, {}, {})}

            <p class="${"text-sm text-white ml-1.5"}">\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0432\u0438\u0434\u0436\u0435\u0442\u043E\u0432</p></button></div></div>`}`}</section>`;
  } while (!$$settled);
  $$unsubscribe_ProjectDashboard();
  $$unsubscribe_CurrentProject();
  $$unsubscribe_page();
  return $$rendered;
});
var InputSettingCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a, _b;
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let value;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    value = yield card.getter();
  }));
  let { card = {} } = $$props;
  if ($$props.card === void 0 && $$bindings.card && card !== void 0)
    $$bindings.card(card);
  return `
<div class="${"w-" + escape2((_a = card.size) != null ? _a : "1/3") + " relative p-2"}"><div class="${"bg-gray-100 p-4 w-full h-full"}">
    <div class="${"w-full flex items-center justify-between"}"><div class="${"flex items-center"}">
        <div style="${"background: " + escape2(card.color)}" class="${"p-2 rounded-full flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: card.icon,
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>
  
        
        <div class="${"ml-2 flex items-center"}"><p class="${"text-md text-black font-medium"}">${escape2(card.title)}</p>
  
          ${card.documentationLink ? `<button>${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "external-link",
    attrs: {
      class: "ml-1.5 w-3 h-3 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button>` : ``}</div></div>

      
      ${``}</div>

    
    <div class="${"my-2"}"><p class="${"text-sm text-black opacity-80"}">${escape2(card.description)}</p></div>

    
    <div class="${"w-full mt-4 bg-gray-200 rounded-md flex items-center relative"}">
      ${card.placeholder != null && card.placeholder.side == "left" ? `
        <div class="${"w-1/3 bg-gray-300 text-center py-1 rounded-l-md"}"><p class="${"text-sm text-black opacity-80"}">${escape2(card.placeholder.text)}</p></div>` : ``}

      
      <input type="${"text"}" class="${"w-2/3 bg-gray-200 text-sm text-black px-2"}"${add_attribute("placeholder", (_b = card.textPlaceholder) != null ? _b : "\u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435", 0)}${add_attribute("value", value, 1)}>

      
      ${card.placeholder != null && card.placeholder.side == "right" ? `
        <div class="${"w-1/3 bg-gray-300 text-center py-1 rounded-r-md"}"><p class="${"text-sm text-black opacity-80"}">${escape2(card.placeholder.text)}</p></div>` : ``}</div>

    
    ${card.footerText ? `<p class="${"mt-1.5 text-xs text-black opacity-80"}"><!-- HTML_TAG_START -->${card.footerText}<!-- HTML_TAG_END --></p>` : ``}</div></div>`;
});
var TogglerSettingCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a;
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let toggled;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    console.log(card.getter);
    toggled = yield card.getter();
  }));
  let { card } = $$props;
  if ($$props.card === void 0 && $$bindings.card && card !== void 0)
    $$bindings.card(card);
  return `<div class="${"w-" + escape2((_a = card.size) != null ? _a : "1/3") + " relative p-2"}"><div class="${"bg-gray-100 p-4 w-full h-full"}">
    <div class="${"w-full flex items-center justify-between"}">
      <div class="${"flex items-center"}">
        <div style="${"background: " + escape2(card.color)}" class="${"p-2 rounded-full flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: card.icon,
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>

        
        <div class="${"ml-2 flex items-center"}"><p class="${"text-md text-black font-medium"}">${escape2(card.title)}</p>

          
          ${card.documentationLink ? `<button>${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "external-link",
    attrs: {
      class: "ml-1.5 w-3 h-3 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button>` : ``}</div></div>

      
      ${toggled == null ? `
        ${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 16 }, {}, {})}` : `${toggled ? `
          <button class="${"rounded-full p-0.5 bg-indigo-500 w-10 flex justify-end"}"><div class="${"w-4 h-4 rounded-full bg-white shadow-sm"}"></div></button>` : `
          <button class="${"rounded-full p-0.5 bg-gray-300 w-10"}"><div class="${"w-4 h-4 rounded-full bg-white shadow-sm"}"></div></button>`}`}</div>

    
    <div class="${"my-2"}"><p class="${"text-sm text-black opacity-80"}">${escape2(card.description)}</p></div></div></div>`;
});
var UniversalSettingCard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { card } = $$props;
  if ($$props.card === void 0 && $$bindings.card && card !== void 0)
    $$bindings.card(card);
  return `
${(card == null ? void 0 : card.type) == ESettingCardType.TOGGLER ? `${validate_component(TogglerSettingCard, "TogglerSettingCard").$$render($$result, { card }, {}, {})}` : `${(card == null ? void 0 : card.type) == ESettingCardType.INPUT ? `${validate_component(InputSettingCard, "InputSettingCard").$$render($$result, { card }, {}, {})}` : ``}`}`;
});
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `
<section class="${"w-full h-screen bg-gray-100 flex items-center justify-between relative px-6 md:px-12"}">
  <div class="${"w-full md:w-2/4"}"><h1 class="${"text-6xl text-black font-medium"}">\u0411\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u044B\u0439 <span class="${"border-b-4 border-yellow-300"}">\u0412\u0438\u0437\u0443\u0430\u043B\u044C\u043D\u044B\u0439 \u042F\u0437\u044B\u043A</span> \u0438 <span class="${"border-b-4 border-yellow-300"}">\u0425\u043E\u0441\u0442\u0438\u043D\u0433</span> \u0434\u043B\u044F \u041C\u0430\u0439\u043D\u043A\u0440\u0430\u0444\u0442\u0430.</h1></div>

  
  <div class="${"absolute inset-x-0 bottom-0 w-full flex items-center justify-between px-6 py-4 bg-gray-200"}">
    <div class="${"flex items-center opacity-90"}">
      <div class="${"mr-2 flex items-center"}">
        <img src="${"https://res.cloudinary.com/lococovu-cdn/image/upload/v1636810372/bluk-studio-black.svg"}" alt="${"bluk.studio black logotype"}" class="${"mr-2 w-6 h-6"}">

        <h1 class="${"text-xl text-black font-bold"}">bluk</h1></div>

      
      <a href="${"#"}" class="${"text-black text-sm mx-4"}">\u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430\u0446\u0438\u044F</a>
      <a href="${"#"}" class="${"text-black text-sm mx-4"}">\u041F\u043B\u0430\u0433\u0438\u043D\u044B</a>
    
      
      <button class="${"flex items-center mx-4"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "external-link",
    attrs: {
      class: "w-4 h-4 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}
        
        <p class="${"text-black text-sm ml-1.5"}">\u0411\u043E\u043B\u044C\u0448\u0435</p></button></div>

    
    <div class="${"flex items-center"}">
      <button class="${"px-6 py-1.5 bg-black border-2 border-black rounded-sm mx-4"}"><p class="${"text-white text-sm"}">\u0412\u043E\u0439\u0442\u0438</p></button>

      
      <button class="${"px-6 py-1.5 border-2 border-black rounded-sm"}"><p class="${"text-black text-sm"}">\u0423\u0437\u043D\u0430\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435</p></button></div></div></section>`;
});
var index$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
var Login = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    const token = $page.query.get("token");
    if (!token) {
      const resourceId = "617a54db957b58a8819eafe9";
      goto(`https://cloud.odzi.dog/auth/v1/${resourceId}`);
    } else {
      CurrentProfile.authorize(token);
      CurrentProfile.subscribe((object) => {
        if (object.loggedIn)
          goto("/app");
      });
    }
  }));
  $$unsubscribe_page();
  return ``;
});
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Login
});
var _layout$3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $CurrentProfile, $$unsubscribe_CurrentProfile;
  let $page, $$unsubscribe_page;
  $$unsubscribe_CurrentProfile = subscribe(CurrentProfile, (value) => $CurrentProfile = value);
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  onMount(() => {
    CurrentProfile.fetchMe().then(() => {
      ProfileProjects.fetch();
    }).catch(() => {
      goto("/login");
    });
  });
  $$unsubscribe_CurrentProfile();
  $$unsubscribe_page();
  return `<main class="${"flex flex-col"}">${($CurrentProfile == null ? void 0 : $CurrentProfile.loggedIn) ? `
    ${$page.path.includes("editor") ? `${validate_component(EditorHeader, "EditorHeader").$$render($$result, {}, {}, {})}` : `${validate_component(ApplicationHeader, "ApplicationHeader").$$render($$result, {}, {}, {})}`}

    
    <div class="${"w-full h-screen relative overflow-y-auto pt-16"}">${slots.default ? slots.default({}) : ``}</div>` : `
    <div class="${"w-full h-screen flex items-center justify-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 15 }, {}, {})}</div>`}</main>`;
});
var __layout$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout$3
});
var App = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  onMount(() => {
    goto("/app/selector");
  });
  return ``;
});
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": App
});
var Selector = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $ProfileProjects, $$unsubscribe_ProfileProjects;
  $$unsubscribe_ProfileProjects = subscribe(ProfileProjects, (value) => $ProfileProjects = value);
  onMount(() => {
    ProfileProjects.subscribe((object) => {
      var _a;
      if (object.loaded) {
        if (!((_a = object.list) === null || _a === void 0 ? void 0 : _a.length)) {
          goto("/app/create");
        } else {
          loaded = true;
        }
      }
    });
  });
  let loaded = false;
  $$unsubscribe_ProfileProjects();
  return `
<div class="${"w-full h-full"}">
  ${!loaded ? `<div class="${"w-full h-full flex justify-center items-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 15 }, {}, {})}</div>` : `
    <section class="${"w-full flex items-stretch justify-between mt-4 px-2"}">
      <div class="${"flex items-stretch"}">
        <div class="${"w-full relative bg-gray-200 rounded-sm px-2 py-2 flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "search",
    attrs: {
      class: "w-4 h-4 text-black mr-2 opacity-40",
      "stroke-width": "2.5"
    }
  }, {}, {})}

          <input class="${"bg-gray-200"}" placeholder="${"\u041F\u043E\u0438\u0441\u043A..."}" type="${"text"}"></div></div>

      
      <div class="${"flex items-stretch"}">
        <button class="${"mx-2 px-4 cursor-not-allowed opacity-80 flex items-center justify-center border-2 border-black"}"><p class="${"text-black text-sm"}">\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u0440\u0438\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u0435</p></button>

        
        <button class="${"mx-2 px-4 flex items-center justify-center bg-black"}"><p class="${"text-white text-sm mr-2"}">\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0441\u0435\u0440\u0432\u0435\u0440</p>

          ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "layers",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button></div></section>

    
    <section class="${"w-full h-auto mt-2 overflow-y-auto overflow-x-hidden flex flex-wrap items-stretch"}">${each($ProfileProjects.list, (project) => {
    var _a;
    return `
        <div class="${"w-1/6 bg-white border-4 border-gray-200 p-4 m-2"}">
          <div class="${"w-full flex items-center justify-between"}">
            <div class="${"w-10 h-10 rounded-sm bg-red-500"}"></div>

            
            <div class="${"p-3 rounded-full bg-gray-100"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "settings",
      attrs: {
        class: "w-4 h-4 text-black",
        "stroke-width": "2.5"
      }
    }, {}, {})}
            </div></div>

          
          <div class="${"my-4"}"><h1 class="${"text-md text-black font-medium"}">${escape2(project.name)}</h1>
            <p class="${"text-xs text-black opacity-80"}">${escape2((_a = project.description) != null ? _a : "\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442...")}</p></div>

          
          <div class="${"w-full"}"><button class="${"px-2 py-1 border-2 border-black flex items-center justify-center"}"><p class="${"text-black text-xs mr-0.5"}">\u0412\u044B\u0431\u0440\u0430\u0442\u044C</p>

              ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
      name: "chevron-right",
      attrs: {
        class: "w-4 h-4 text-black",
        "stroke-width": "2.5"
      }
    }, {}, {})}
            </button></div>
        </div>`;
  })}

      </section>`}</div>`;
});
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Selector
});
var _layout$2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let loaded = false;
  let currentPage = {};
  page.subscribe((page2) => {
    const pathSplitted = page2.path.split("/");
    if (pathSplitted[pathSplitted.length - 1] != "create") {
      setTimeout(() => loaded = true, 250);
      if ((currentPage === null || currentPage === void 0 ? void 0 : currentPage.id) != pathSplitted[pathSplitted.length - 1]) {
        loaded = false;
        setTimeout(() => loaded = true, 250);
      }
      currentPage = CreateProjectPages.filter((x) => x.id == pathSplitted[pathSplitted.length - 1])[0];
    } else {
      goto("/app/create/plan", { replaceState: true });
    }
  });
  return `<div class="${"w-full h-full flex flex-col items-center py-12 justify-center bg-gradient-to-tr from-gray-900 to-black"}"><div class="${"w-1/3 relative overflow-y-auto overflow-x-hidden"}">
    <div class="${"w-full bg-white rounded-sm py-6 flex flex-col items-center justify-center"}">
      <div class="${"w-full ml-3 text-left px-6 relative"}">${(currentPage == null ? void 0 : currentPage.title) && (currentPage == null ? void 0 : currentPage.description) ? `<h1 class="${"text-xl text-black font-medium"}">${escape2(currentPage == null ? void 0 : currentPage.title)}</h1>
          <p class="${"text-xs text-black opacity-80"}">${escape2(currentPage == null ? void 0 : currentPage.description)}</p>` : `
          <div class="${"w-full h-8 rounded-full bg-gray-200"}"></div>
          <div class="${"w-1/2 flex mt-2"}"><div class="${"w-2/3 h-6 rounded-full bg-gray-200"}"></div>
            <div class="${"w-1/3 h-6 rounded-full bg-gray-200"}"></div></div>`}</div>

      
      <div class="${"w-full my-6"}">${!loaded ? `<div class="${"py-16 w-full flex justify-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 20 }, {}, {})}</div>` : `${slots.default ? slots.default({}) : ``}`}</div>

      
      <div class="${"w-full flex items-center justify-center"}">${loaded ? `${each(CreateProjectPages, (page2) => `${page2.id == (currentPage == null ? void 0 : currentPage.id) ? `<div class="${"w-4 h-4 rounded-full bg-black mx-2"}"></div>` : `<div class="${"w-4 h-4 cursor-pointer rounded-full border-2 border-black mx-2"}"></div>`}`)}` : `
          <div class="${"w-4 h-4 rounded-full bg-gray-200 mx-2"}"></div>
          <div class="${"w-4 h-4 rounded-full bg-gray-200 mx-2"}"></div>
          <div class="${"w-4 h-4 rounded-full bg-gray-200 mx-2"}"></div>`}</div></div></div></div>`;
});
var __layout$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout$2
});
var Create = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Create
});
var Information = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $CreateProjectStore, $$unsubscribe_CreateProjectStore;
  $$unsubscribe_CreateProjectStore = subscribe(CreateProjectStore, (value) => $CreateProjectStore = value);
  let name = $CreateProjectStore.name;
  let description = $CreateProjectStore.description;
  let nameProperty = NamedProjectProperties.find((x) => x.id == "name");
  let descriptionProperty = NamedProjectProperties.find((x) => x.id == "description");
  $$unsubscribe_CreateProjectStore();
  return `
<div class="${"px-4"}">
  <div class="${"w-full"}">
    <div class="${"flex items-start mb-4"}">
      <div class="${"p-2 rounded-full bg-yellow-400"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: nameProperty == null ? void 0 : nameProperty.icon,
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>

      
      <div class="${"ml-2"}"><h1 class="${"text-md text-black"}">${escape2(nameProperty == null ? void 0 : nameProperty.title)}</h1>
        <p class="${"text-xs text-black opacity-80"}">${escape2(nameProperty == null ? void 0 : nameProperty.description)}</p></div></div>

    
    <div class="${"w-full relative bg-gray-200 rounded-sm px-2 py-2"}"><input class="${"bg-gray-200"}" placeholder="${"\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435"}" type="${"text"}"${add_attribute("value", name, 1)}></div></div>

  
  <div class="${"w-full mt-6"}">
    <div class="${"flex items-start mb-4"}">
      <div class="${"p-2 rounded-full bg-indigo-400"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: descriptionProperty == null ? void 0 : descriptionProperty.icon,
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>

      
      <div class="${"ml-2"}"><h1 class="${"text-md text-black"}">${escape2(descriptionProperty == null ? void 0 : descriptionProperty.title)}</h1>
        <p class="${"text-xs text-black opacity-80"}">${escape2(descriptionProperty == null ? void 0 : descriptionProperty.description)}</p></div></div>

    
    <div class="${"w-full relative bg-gray-200 rounded-sm px-2 py-2"}"><textarea class="${"bg-gray-200 w-full"}" placeholder="${"\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435 \u0441\u0435\u0440\u0432\u0435\u0440\u0430"}" rows="${"3"}">${description || ""}</textarea></div></div>

  
  <div class="${"w-full mt-8 flex items-start justify-center"}">
    <button class="${"w-1/2 mr-2 px-2 py-1 border-2 border-black flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-left",
    attrs: {
      class: "w-4 h-4 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}

      <p class="${"text-black text-sm ml-2"}">\u0412\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F</p></button>

    
    <div class="${"w-1/2 mr-2 relative"}"><button class="${escape2(!name ? "cursor-not-allowed opacity-80" : "") + " w-full px-2 py-1.5 bg-black rounded-sm flex items-center justify-center"}"><p class="${"text-white text-sm mr-2"}">\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C</p>

        ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-right",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button>
    
      
      ${!name ? `<p class="${"text-xs text-black opacity-80 mt-0.5"}">\u0417\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u0435 <span class="${"border-b-2 border-black border-opacity-80"}">\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435</span> \u0441\u0435\u0440\u0432\u0435\u0440\u0430</p>` : ``}</div></div></div>`;
});
var information = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Information
});
var Members = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var members = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Members
});
var Finish = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let plan2;
  let $CreateProjectStore, $$unsubscribe_CreateProjectStore;
  $$unsubscribe_CreateProjectStore = subscribe(CreateProjectStore, (value) => $CreateProjectStore = value);
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  plan2 = ProjectPlans.filter((x) => x.id == $CreateProjectStore.plan)[0];
  $$unsubscribe_CreateProjectStore();
  return `
<div class="${"w-full flex flex-wrap px-4 relative items-stretch"}">${each(NamedProjectProperties, (property) => `<div class="${"w-full p-4 bg-gray-100 rounded-sm m-2 relative"}">
      ${``}

      <div class="${"flex items-center"}">
        ${property.icon ? `${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: property.icon,
    attrs: {
      class: "w-4 h-4 text-black mr-2",
      "stroke-width": "2.5"
    }
  }, {}, {})}` : ``}

        
        <h1 class="${"text-black text-md font-medium"}">${escape2(property.title)}</h1>

        
        ${!$CreateProjectStore[property.id] ? `${property.required ? `<div class="${"ml-2 px-1.5 py-0.5 rounded-full bg-red-500 flex items-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "alert-triangle",
    attrs: {
      class: "w-3 h-3 text-white",
      "stroke-width": "2"
    }
  }, {}, {})}
          
              <p class="${"text-xs text-white ml-0.5"}">\u041E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E</p>
            </div>` : `<div class="${"ml-2 px-1.5 py-0.5 rounded-full bg-yellow-500 flex items-center"}"><p class="${"text-xs text-white ml-0.5"}">\u041D\u0435\u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E</p>
            </div>`}` : ``}</div>  

      
      <p class="${"text-sm text-black opacity-80"}">${escape2(property.description)}</p>

      
      <div class="${"w-full mt-4"}">${$CreateProjectStore[property.id] ? `
          ${property.id == "plan" ? `<div class="${"w-full bg-white border-2 border-yellow-400 flex items-start rounded-sm px-2 py-4"}">
              <div style="${"background: " + escape2(plan2.color)}" class="${"p-3 rounded-full flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: plan2.icon,
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>
          
              
              <div class="${"ml-4"}">
                <h1 class="${"text-md text-black font-medium"}">${escape2(plan2.title)}</h1>
          
                
                <p class="${"text-xs text-black opacity-80"}"><!-- HTML_TAG_START -->${plan2.description}<!-- HTML_TAG_END --></p>

                
                <div class="${"flex items-stretch mt-2"}">
                  <div class="${"px-2 py-1 bg-black rounded-sm flex items-center mr-3"}">
                    ${plan2.price == 0 ? `<p class="${"text-xs text-white"}">\u0411\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u043E</p>` : ``}</div>

                  
                  <button class="${"px-2 py-1 border-2 border-black"}"><p class="${"text-black text-xs"}">\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0434\u0440\u0443\u0433\u043E\u0439</p>
                  </button></div>
              </div></div>
          ` : `${property.id == "name" || property.id == "description" ? `<div class="${"bg-white px-4 py-2 rounded-sm border-2 border-yellow-400 flex items-start justify-between"}"><h1 class="${"text-md text-black"}">${escape2($CreateProjectStore[property.id])}</h1>

              
              <button class="${"py-1"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "edit",
    attrs: {
      class: "w-4 h-4 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button>
            </div>` : ``}`}` : `<div class="${"px-4 py-1.5 rounded-sm " + escape2(property.required ? "bg-red-500" : "bg-yellow-500")}"><h1 class="${"text-white text-sm"}">\u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0435 \u0437\u0430\u0434\u0430\u043D\u043E</h1>

            ${property.pageId ? `<p class="${"text-xs text-white opacity-80"}">\u0412\u044B \u043C\u043E\u0436\u0435\u0442\u0435 \u0437\u0430\u0434\u0430\u0442\u044C \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u044D\u0442\u043E\u043C\u0443 \u043F\u0443\u043D\u043A\u0442\u0443 \u043F\u043B\u0430\u043D\u0430, \u043D\u0430\u0436\u0430\u0432 \u043D\u0430 \u043A\u043D\u043E\u043F\u043A\u0443 \u043D\u0438\u0436\u0435:</p>

              <button class="${"mt-1 px-2 py-1 rounded-sm bg-black"}"><p class="${"text-xs text-white"}">\u041F\u0435\u0440\u0435\u0439\u0442\u0438</p>
              </button>` : ``}
          </div>`}</div>
    </div>`)}

  
  <div class="${"w-full mt-8 px-2"}"><button class="${"w-full px-2 py-1.5 bg-black rounded-sm flex items-center justify-center"}">${`<p class="${"text-white text-sm mr-2"}">\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0441\u0435\u0440\u0432\u0435\u0440</p>

        ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-right",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}`}</button></div></div>`;
});
var finish = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Finish
});
var Plan = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $CreateProjectStore, $$unsubscribe_CreateProjectStore;
  $$unsubscribe_CreateProjectStore = subscribe(CreateProjectStore, (value) => $CreateProjectStore = value);
  $$unsubscribe_CreateProjectStore();
  return `
${each(ProjectPlans, (plan2) => `<div class="${"w-full border-2 " + escape2($CreateProjectStore.plan == plan2.id ? "border-yellow-400" : "border-gray-200") + " flex items-start rounded-sm px-6 py-4"}">
    <div style="${"background: " + escape2(plan2.color)}" class="${"p-3 rounded-full flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: plan2.icon,
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>

    
    <div class="${"ml-4"}">
      <div class="${"flex items-center mb-1.5"}"><h1 class="${"text-md text-black font-medium"}">${escape2(plan2.title)}</h1>

        
        ${plan2.price == 0 ? `<div class="${"ml-2 rounded-full bg-black px-2 py-1"}"><p class="${"text-xs text-white"}">\u0411\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u043E</p>
          </div>` : ``}</div>

      
      <p class="${"text-xs text-black opacity-80 mb-4"}"><!-- HTML_TAG_START -->${plan2.description}<!-- HTML_TAG_END --></p>
    
      
      <div class="${"flex items-stretch"}">
        ${$CreateProjectStore.plan == plan2.id ? `<button class="${"px-2 py-1 bg-black rounded-sm flex items-center mr-3"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "check",
    attrs: {
      class: "w-3 h-3 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}

            <p class="${"text-white text-xs ml-1.5"}">\u0412\u044B\u0431\u0440\u0430\u043D\u043D\u043E</p>
          </button>` : `<button class="${"px-2 py-1 border-2 border-black rounded-sm flex items-center mr-3"}"><p class="${"text-black text-xs mr-1.5"}">\u0412\u044B\u0431\u0440\u0430\u0442\u044C</p>

            ${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-right",
    attrs: {
      class: "w-3 h-3 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}
          </button>`}

        
        <button class="${"px-2 py-1 border-2 border-black"}"><p class="${"text-black text-xs"}">\u0423\u0437\u043D\u0430\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435</p></button>
      </div></div>
  </div>`)}


<div class="${"w-full border-2 flex items-start border-gray-200 rounded-sm px-6 py-4"}">
  <div class="${"p-3 rounded-full bg-indigo-400 flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "heart",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>

  
  <div class="${"ml-4"}">
    <div class="${"flex items-center mb-1.5"}"><h1 class="${"text-md text-black font-medium"}">\u0411\u043E\u043B\u044C\u0448\u0435 \u043F\u043B\u0430\u043D\u043E\u0432 \u043D\u0435\u0442</h1></div>

    
    <p class="${"text-xs text-black opacity-80 mb-4"}">\u0414\u0430-\u0434\u0430, \u0432\u044B \u0432\u0441\u0451 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E \u043F\u043E\u043D\u044F\u043B\u0438! \u0421\u0435\u0440\u0432\u0438\u0441 \u043F\u043E\u043B\u043D\u043E\u0441\u0442\u044C\u044E \u0431\u0435\u0441\u043F\u043B\u0430\u0442\u0435\u043D \u0438 \u043F\u043E\u0447\u0442\u0438 \u0447\u0442\u043E \u043D\u0435\u043E\u0433\u0440\u0430\u043D\u0438\u0447\u0435\u043D.</p>
  
    
    <div class="${"flex items-stretch"}">
      <button class="${"px-2 py-1 border-2 border-black"}"><p class="${"text-black text-xs"}">\u041F\u043E\u0434\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043F\u0440\u043E\u0435\u043A\u0442</p></button></div></div></div>`;
});
var plan = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Plan
});
var _layout$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let loaded;
  let $page, $$unsubscribe_page;
  let $CurrentProject, $$unsubscribe_CurrentProject;
  let $CurrentWorkerState, $$unsubscribe_CurrentWorkerState;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  $$unsubscribe_CurrentProject = subscribe(CurrentProject, (value) => $CurrentProject = value);
  $$unsubscribe_CurrentWorkerState = subscribe(CurrentWorkerState, (value) => $CurrentWorkerState = value);
  onMount(() => {
    CurrentProject.fetch($page.params.projectId);
    CurrentProject.subscribe((store) => {
      if (store.loaded) {
        console.log("loaded");
        console.log(store);
        CurrentWorkerState.fetch($page.params.projectId);
      }
    });
  });
  page.subscribe((object) => {
    const regexp = /\/app\/[\s\S]{24}\/[\s\S]+/;
    if (!regexp.test(object.path)) {
      CurrentProject.clear();
    }
  });
  loaded = $CurrentProject.loaded;
  $$unsubscribe_page();
  $$unsubscribe_CurrentProject();
  $$unsubscribe_CurrentWorkerState();
  return `
${!loaded ? `<div class="${"w-full h-full flex items-center justify-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 15 }, {}, {})}</div>` : `
  ${($CurrentWorkerState == null ? void 0 : $CurrentWorkerState.state) != "RUNNING" ? `<div class="${"w-full h-full flex flex-col items-center justify-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 15 }, {}, {})}

      
      <div class="${"text-center mt-4 w-1/3"}"><h1 class="${"text-md font-medium text-black"}">\u0417\u0430\u043F\u0443\u0441\u043A\u0430\u0435\u043C \u0441\u0435\u0440\u0432\u0435\u0440...</h1>
        <p class="${"text-sm text-black opacity-80"}">State: ${escape2($CurrentWorkerState == null ? void 0 : $CurrentWorkerState.state)} Lorem ipsum dolor, sit amet consectetur adipisicing elit. Possimus maiores sunt numquam assumenda enim facere.</p></div></div>` : `${slots.default ? slots.default({}) : ``}`}`}`;
});
var __layout$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout$1
});
var U5BprojectIdu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  onMount(() => goto(`${$page.path}/dashboard`, { replaceState: true }));
  $$unsubscribe_page();
  return ``;
});
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5BprojectIdu5D
});
var Dashboard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a;
  let project;
  let $CurrentProject, $$unsubscribe_CurrentProject;
  let $$unsubscribe_page;
  $$unsubscribe_CurrentProject = subscribe(CurrentProject, (value) => $CurrentProject = value);
  $$unsubscribe_page = subscribe(page, (value) => value);
  project = $CurrentProject.project;
  $$unsubscribe_CurrentProject();
  $$unsubscribe_page();
  return `
<section class="${"w-full bg-gray-200 px-2 py-4"}">
  <div class="${"w-full flex items-center justify-between pb-8"}">
    <div><h1 class="${"text-xl text-black font-medium"}">\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F</h1>
      <p class="${"text-xs text-black opacity-80"}">\u0413\u043B\u0430\u0432\u043D\u0430\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0441\u0435\u0440\u0432\u0435\u0440\u0435</p></div>

    
    </div>

  
  <div>
    <div class="${"px-2 flex items-start"}">
      <div class="${"w-10 h-10 rounded-sm bg-red-500"}"></div>

      
      <div class="${"ml-2"}"><h1 class="${"text-2xl text-black font-medium"}">${escape2(project.name)}</h1>
        <p class="${"text-sm text-black opacity-80"}">${escape2((_a = project.description) != null ? _a : "")}</p></div></div>

    
    <div class="${"w-full flex items-center mt-4"}">
      <div class="${"mx-1 flex items-center justify-center rounded-full bg-white px-3 py-1"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "globe",
    attrs: {
      class: "w-4 h-4 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}

        <p class="${"text-sm text-black ml-1.5"}">paradise.bluk.studio</p></div>

      
      <div class="${"mx-1 relative flex items-center justify-center rounded-full bg-white px-3 py-1"}"><div class="${"relative flex items-center mr-1.5"}">
          <div class="${"w-4 h-4 relative"}"><img src="${"https://crafatar.com/avatars/1b42ff62-b4cb-4b8e-8fbd-efd24e70ced2"}" alt="${""}" class="${"absolute w-4 h-4 rounded-sm"}"></div>

          <div class="${"w-4 h-4 relative"}"><img src="${"https://crafatar.com/avatars/65fd84d5-5904-4391-b84a-ab52ffc0a7e9"}" alt="${""}" class="${"absolute w-4 h-4 rounded-sm"}"></div>

          <div class="${"w-4 h-4 relative"}"><img src="${"https://crafatar.com/avatars/f6199c41-2d00-40b0-9d58-c4fd069c852c"}" alt="${""}" class="${"absolute w-4 h-4 rounded-sm"}"></div></div>

        <p class="${"text-black text-sm"}">10 \u0438\u0433\u0440\u043E\u043A\u043E\u0432</p></div>

      
      <div class="${"mx-1 flex items-center justify-center rounded-full bg-white px-3 py-1"}"><div class="${"w-4 h-4 mr-1.5 rounded-full bg-green-500"}"></div>

        <p class="${"text-black text-sm"}">\u0412\u043A\u043B\u044E\u0447\u0451\u043D</p></div></div></div>

  
  <div style="${"height: 2px;"}" class="${"w-full bg-gray-300 my-4 mx-2"}"></div>

  <div class="${"flex items-stretch justify-between"}">
    <div class="${"flex items-stretch"}">${each(InfoFooterButtons, (button) => `<button class="${"mx-2 px-2 py-1.5 " + escape2(button.isGhost ? "border-2 border-black text-black" : "text-white bg-black") + " flex items-center justfiy-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: button.icon,
    attrs: { class: "w-4 h-4", "stroke-width": "2.5" }
  }, {}, {})}
          
          <p class="${"text-sm ml-1.5"}">${escape2(button.title)}</p>
        </button>`)}</div>

    
    <div class="${"flex items-stretch"}">
      <button class="${"mx-2 px-2 py-1.5 bg-red-500 flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "pause",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}

        <p class="${"text-sm text-white ml-1.5"}">\u0412\u044B\u043A\u043B\u044E\u0447\u0438\u0442\u044C</p></button></div></div></section>


${validate_component(DashboardTiles, "DashboardTiles").$$render($$result, {}, {}, {})}`;
});
var dashboard = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Dashboard
});
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  let currentCategoryId;
  page.subscribe(() => {
    const splittedPath = $page.path.split("/");
    currentCategoryId = splittedPath[splittedPath.length - 1];
  });
  $$unsubscribe_page();
  return `<section class="${"w-full h-full relative flex overflow-hidden"}">
  <div class="${"w-1/4 h-full px-2 pt-4"}">
    <button class="${"mb-2 w-full bg-black px-4 py-2 flex items-center justify-start"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "chevron-left",
    attrs: { class: "w-4 h-4 text-white" }
  }, {}, {})}

      <p class="${"ml-1.5 text-white text-sm"}">\u0412\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F \u043D\u0430\u0437\u0430\u0434</p></button>

    ${each(SettingsCategories, (category) => `<button class="${"w-full px-4 py-2 my-1.5 flex items-center justify-start opacity-80 " + escape2(category.id == currentCategoryId ? "bg-gray-100" : "")}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: category.icon,
    attrs: { class: "w-4 h-4 text-black" }
  }, {}, {})}
      
        <p class="${"text-sm text-black ml-2"}">${escape2(category.title)}</p>
      </button>`)}</div>

  
  <div class="${"w-3/4 py-2 overflow-y-auto"}">${slots.default ? slots.default({}) : ``}</div></section>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
var Settings = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  onMount(() => goto(`${$page.path}/general`, { replaceState: true }));
  $$unsubscribe_page();
  return ``;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Settings
});
var General = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `
<section class="${"w-full flex flex-wrap items-stretch"}">${each(GeneralSettings, (setting) => `${validate_component(UniversalSettingCard, "UniversalSettingCard").$$render($$result, { card: setting }, {}, {})}`)}</section>`;
});
var general = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": General
});
var Danger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_CurrentProject;
  $$unsubscribe_CurrentProject = subscribe(CurrentProject, (value) => value);
  (function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  });
  $$unsubscribe_CurrentProject();
  return `
<section class="${"w-full flex flex-wrap items-stretch"}">
  

  
  <div class="${"w-1/2 relative p-2"}"><div class="${"bg-gray-100 p-4 w-full h-full"}">
      <div class="${"w-full flex items-center justify-between"}"><div class="${"flex items-center"}">
          <div class="${"p-2 bg-red-500 rounded-full flex items-center justify-center"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "alert-triangle",
    attrs: {
      class: "w-4 h-4 text-white",
      "stroke-width": "2.5"
    }
  }, {}, {})}</div>
    
          
          <div class="${"ml-2 flex items-center"}"><p class="${"text-md text-black font-medium"}">\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u043F\u0440\u043E\u0435\u043A\u0442</p></div></div>

        
        ${``}</div>

      
      <div class="${"my-2"}"><p class="${"text-sm text-black opacity-80"}">Lorem ipsum dolor sit amet consectetur adipisicing elit. Laborum possimus nostrum inventore. Explicabo atque fugit commodi!</p></div>

      
      <div class="${"w-full mt-4 bg-gray-200 rounded-md flex items-center relative"}"><button class="${"w-full px-4 py-2 bg-red-500 flex items-center justify-start"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "check",
    attrs: { class: "w-4 h-4 text-white" }
  }, {}, {})}

          <p class="${"text-sm text-white font-medium ml-2"}">\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u043F\u0440\u043E\u0435\u043A\u0442</p></button></div>

      
      <p class="${"mt-1.5 text-xs text-black opacity-80"}">Lorem ipsum dolor sit amet consectetur, adipisicing elit. Provident, a!</p></div></div></section>`;
});
var danger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Danger
});
var Tiles = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $ProjectDashboard, $$unsubscribe_ProjectDashboard;
  let $CurrentProject, $$unsubscribe_CurrentProject;
  $$unsubscribe_ProjectDashboard = subscribe(ProjectDashboard, (value) => $ProjectDashboard = value);
  $$unsubscribe_CurrentProject = subscribe(CurrentProject, (value) => $CurrentProject = value);
  onMount(() => {
    var _a;
    if ($ProjectDashboard._id == null) {
      ProjectDashboard.fetch(String((_a = $CurrentProject === null || $CurrentProject === void 0 ? void 0 : $CurrentProject.project) === null || _a === void 0 ? void 0 : _a._id));
      ProjectDashboard.subscribe((dashboard2) => {
        if (dashboard2._id) {
          loading = false;
        }
      });
    } else {
      loading = false;
    }
  });
  const settings = [
    {
      title: "\u0418\u0433\u0440\u043E\u043A\u0438",
      description: "Lorem ipsum dolor sit amet consectetur, adipisicing elit. Doloremque aut cum repudiandae aspernatur quasi laudantium.",
      component: PlayersTile,
      settings: PlayersWidgetSettings
    },
    {
      title: "\u041A\u043E\u043D\u0441\u043E\u043B\u044C",
      description: "Lorem ipsum dolor sit amet consectetur, adipisicing elit. Doloremque aut cum repudiandae aspernatur quasi laudantium.",
      component: ConsoleTile,
      settings: ConsoleWidgetSettings
    },
    {
      title: "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435",
      description: "Lorem ipsum dolor sit amet consectetur, adipisicing elit. Doloremque aut cum repudiandae aspernatur quasi laudantium.",
      component: ControlsTile,
      settings: ControlsWidgetSettings
    },
    {
      title: "\u041B\u043E\u0433\u0438",
      description: "Lorem ipsum dolor sit amet consectetur, adipisicing elit. Doloremque aut cum repudiandae aspernatur quasi laudantium.",
      component: LogsTile,
      settings: LogsWidgetSettings
    }
  ];
  let loading = true;
  $$unsubscribe_ProjectDashboard();
  $$unsubscribe_CurrentProject();
  return `

${loading ? `<div class="${"w-full h-full flex justify-center items-center"}">${validate_component(RadialSpinner, "RadialSpinner").$$render($$result, { color: "#000", size: 15 }, {}, {})}</div>` : `${each(settings, (widget) => `
    <div class="${"w-2/3 px-2"}"><h1 class="${"text-2xl text-black font-medium"}">${escape2(widget.title)}</h1>
      <p class="${"text-sm text-black opacity-80"}">${escape2(widget.description)}</p></div>

    
    <section class="${"mt-4 w-full flex items-stretch relative"}">
      <div class="${"w-1/2 flex flex-wrap items-stretch"}">${each(widget.settings, (setting) => `${validate_component(UniversalSettingCard, "UniversalSettingCard").$$render($$result, { card: setting }, {}, {})}`)}</div>

      
      <div class="${"w-1/2 flex items-center justify-center relative opacity-90"}">
        <div class="${"absolute inset-x-0 top-0 w-full p-2 flex justify-end"}"><div class="${"bg-gray-100 px-4 py-1.5 flex items-center justify-center"}"><p class="${"text-sm text-black"}">\u041F\u0440\u0435\u0434\u0432\u0430\u0440\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440</p>

            <button class="${"ml-2"}">${validate_component(SimpleIcon, "SimpleIcon").$$render($$result, {
    name: "x",
    attrs: {
      class: "w-4 h-4 text-black",
      "stroke-width": "2.5"
    }
  }, {}, {})}</button>
          </div></div>

        
        <div class="${"bg-gray-200 rounded-md border-2 border-dotted border-indigo-500"}">${validate_component(widget.component || missing_component, "svelte:component").$$render($$result, {}, {}, {})}</div>
      </div></section>

    
    <div class="${"w-full flex justify-center px-2"}"><div class="${"my-8 w-full h-2 border-b-2 border-gray-200"}"></div>
    </div>`)}`}`;
});
var tiles = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Tiles
});
var Editor = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  onMount(() => goto(`${$page.path}/explorer`, { replaceState: true }));
  $$unsubscribe_page();
  return ``;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Editor
});
var Explorer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<p>Editor Explorer</p>`;
});
var explorer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Explorer
});

// .svelte-kit/vercel/entry.js
init();
var entry_default = async (req, res) => {
  const { pathname, searchParams } = new URL(req.url || "", "http://localhost");
  let body;
  try {
    body = await getRawBody(req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  const rendered = await render({
    method: req.method,
    headers: req.headers,
    path: pathname,
    query: searchParams,
    rawBody: body
  });
  if (rendered) {
    const { status, headers, body: body2 } = rendered;
    return res.writeHead(status, headers).end(body2);
  }
  return res.writeHead(404).end();
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
